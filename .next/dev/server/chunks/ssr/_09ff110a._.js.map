{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (\r\n  <div ref={ref} className={cn(\"rounded-lg border bg-card text-card-foreground shadow-sm\", className)} {...props} />\r\n));\r\nCard.displayName = \"Card\";\r\n\r\nconst CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex flex-col space-y-1.5 p-6\", className)} {...props} />\r\n  ),\r\n);\r\nCardHeader.displayName = \"CardHeader\";\r\n\r\nconst CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <h3 ref={ref} className={cn(\"text-2xl font-semibold leading-none tracking-tight\", className)} {...props} />\r\n  ),\r\n);\r\nCardTitle.displayName = \"CardTitle\";\r\n\r\nconst CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <p ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\r\n  ),\r\n);\r\nCardDescription.displayName = \"CardDescription\";\r\n\r\nconst CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />,\r\n);\r\nCardContent.displayName = \"CardContent\";\r\n\r\nconst CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex items-center p-6 pt-0\", className)} {...props} />\r\n  ),\r\n);\r\nCardFooter.displayName = \"CardFooter\";\r\n\r\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,mNAAgB,CAAuD,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC5G,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,4DAA4D;QAAa,GAAG,KAAK;;;;;;AAEhH,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,mNAAgB,CACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;AAGvF,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,mNAAgB,CAChC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAG,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,sDAAsD;QAAa,GAAG,KAAK;;;;;;AAG3G,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,mNAAgB,CACtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAE,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;AAGrF,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,mNAAgB,CAClC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAAQ,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,YAAY;QAAa,GAAG,KAAK;;;;;;AAElG,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,mNAAgB,CACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,8BAA8B;QAAa,GAAG,KAAK;;;;;;AAGpF,WAAW,WAAW,GAAG"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/badge.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst badgeVariants = cva(\r\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\r\n        secondary: \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        destructive: \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\r\n        outline: \"text-foreground\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n    },\r\n  },\r\n);\r\n\r\nexport interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}\r\n\r\nfunction Badge({ className, variant, ...props }: BadgeProps) {\r\n  return <div className={cn(badgeVariants({ variant }), className)} {...props} />;\r\n}\r\n\r\nexport { Badge, badgeVariants };\r\n"],"names":[],"mappings":";;;;;;;AACA;AAEA;;;;AAEA,MAAM,gBAAgB,IAAA,uKAAG,EACvB,0KACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,WAAW;YACX,aAAa;YACb,SAAS;QACX;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAKF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBAAO,8OAAC;QAAI,WAAW,IAAA,yHAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAC7E"}},
    {"offset": {"line": 131, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/components/BookingCard.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { Booking } from '@/types/booking';\r\nimport { Card, CardContent, CardHeader } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Calendar, Clock, MapPin, ArrowRight } from 'lucide-react';\r\nimport { format } from 'date-fns';\r\nimport Link from 'next/link';\r\n\r\ninterface BookingCardProps {\r\n  booking: Booking;\r\n}\r\n\r\nexport function BookingCard({ booking }: BookingCardProps) {\r\n  const statusColors = {\r\n    pending: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/20 dark:text-yellow-400',\r\n    confirmed: 'bg-blue-100 text-blue-800 dark:bg-blue-900/20 dark:text-blue-400',\r\n    completed: 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-400',\r\n    cancelled: 'bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-400',\r\n  };\r\n\r\n  const paymentColors = {\r\n    pending: 'bg-gray-100 text-gray-800 dark:bg-gray-900/20 dark:text-gray-400',\r\n    paid: 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-400',\r\n    failed: 'bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-400',\r\n    refunded: 'bg-orange-100 text-orange-800 dark:bg-orange-900/20 dark:text-orange-400',\r\n  };\r\n\r\n  return (\r\n    <Card className=\"hover:shadow-md transition-shadow border-border w-full max-w-full overflow-hidden\">\r\n      <CardHeader className=\"pb-2 px-3 py-3 sm:px-4 sm:py-4 md:px-6 md:py-6\">\r\n        <div className=\"flex flex-col gap-2\">\r\n          <div className=\"flex items-start justify-between gap-2\">\r\n            <div className=\"flex-1 min-w-0\">\r\n              <h3 className=\"font-semibold text-base sm:text-lg md:text-xl truncate\">{booking.service_type}</h3>\r\n              <p className=\"text-sm text-muted-foreground mt-0.5\">#{booking.booking_number}</p>\r\n            </div>\r\n            <div className=\"flex flex-wrap gap-1.5 sm:gap-2 flex-shrink-0\">\r\n              <Badge className={`${statusColors[booking.status]} text-xs sm:text-sm px-2 sm:px-3 py-0.5`}>\r\n                {booking.status}\r\n              </Badge>\r\n              {booking.payment_status !== booking.status && (\r\n                <Badge variant=\"outline\" className={`${paymentColors[booking.payment_status]} text-xs sm:text-sm px-2 sm:px-3 py-0.5`}>\r\n                  {booking.payment_status}\r\n                </Badge>\r\n              )}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </CardHeader>\r\n      <CardContent className=\"px-3 pb-3 sm:px-4 sm:pb-4 md:px-6 md:pb-6 pt-0\">\r\n        <div className=\"space-y-2.5 sm:space-y-3\">\r\n          {/* Date & Time */}\r\n          <div className=\"flex flex-col gap-1.5 sm:flex-row sm:items-center sm:gap-3 text-sm sm:text-base\">\r\n            <div className=\"flex items-center gap-1.5 sm:gap-2\">\r\n              <Calendar className=\"w-4 h-4 sm:w-5 sm:h-5 text-muted-foreground flex-shrink-0\" />\r\n              <span className=\"whitespace-nowrap\">{format(new Date(booking.service_date), 'MMM d, yyyy')}</span>\r\n            </div>\r\n            <div className=\"flex items-center gap-1.5 sm:gap-2\">\r\n              <Clock className=\"w-4 h-4 sm:w-5 sm:h-5 text-muted-foreground flex-shrink-0\" />\r\n              <span className=\"whitespace-nowrap\">{booking.service_time}</span>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Address */}\r\n          <div className=\"flex items-start gap-1.5 sm:gap-2 text-sm sm:text-base\">\r\n            <MapPin className=\"w-4 h-4 sm:w-5 sm:h-5 text-muted-foreground mt-0.5 flex-shrink-0\" />\r\n            <span className=\"text-muted-foreground break-words leading-relaxed\">\r\n              {booking.service_address}, {booking.service_suburb}\r\n            </span>\r\n          </div>\r\n\r\n          {/* Price */}\r\n            <div className=\"flex flex-col gap-2.5 sm:flex-row sm:items-center sm:justify-between pt-2 border-t border-border\">\r\n            <div className=\"min-w-0 flex-1\">\r\n              <p className=\"text-xs sm:text-sm text-muted-foreground\">Total Amount</p>\r\n              <p className=\"text-base sm:text-lg md:text-xl font-semibold mt-0.5 break-words\">R{booking.total_amount.toFixed(2)}</p>\r\n            </div>\r\n            <Button asChild variant=\"outline\" size=\"sm\" className=\"w-full sm:w-auto text-sm sm:text-base h-9 sm:h-10 flex-shrink-0 sm:ml-2\">\r\n              <Link href={`/dashboard/bookings/${booking.id}`} className=\"flex items-center justify-center\">\r\n                View Details\r\n                <ArrowRight className=\"w-3 h-3 sm:w-4 sm:h-4 ml-1.5 sm:ml-2\" />\r\n              </Link>\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AARA;;;;;;;;AAcO,SAAS,YAAY,EAAE,OAAO,EAAoB;IACvD,MAAM,eAAe;QACnB,SAAS;QACT,WAAW;QACX,WAAW;QACX,WAAW;IACb;IAEA,MAAM,gBAAgB;QACpB,SAAS;QACT,MAAM;QACN,QAAQ;QACR,UAAU;IACZ;IAEA,qBACE,8OAAC,wIAAI;QAAC,WAAU;;0BACd,8OAAC,8IAAU;gBAAC,WAAU;0BACpB,cAAA,8OAAC;oBAAI,WAAU;8BACb,cAAA,8OAAC;wBAAI,WAAU;;0CACb,8OAAC;gCAAI,WAAU;;kDACb,8OAAC;wCAAG,WAAU;kDAA0D,QAAQ,YAAY;;;;;;kDAC5F,8OAAC;wCAAE,WAAU;;4CAAuC;4CAAE,QAAQ,cAAc;;;;;;;;;;;;;0CAE9E,8OAAC;gCAAI,WAAU;;kDACb,8OAAC,0IAAK;wCAAC,WAAW,GAAG,YAAY,CAAC,QAAQ,MAAM,CAAC,CAAC,uCAAuC,CAAC;kDACvF,QAAQ,MAAM;;;;;;oCAEhB,QAAQ,cAAc,KAAK,QAAQ,MAAM,kBACxC,8OAAC,0IAAK;wCAAC,SAAQ;wCAAU,WAAW,GAAG,aAAa,CAAC,QAAQ,cAAc,CAAC,CAAC,uCAAuC,CAAC;kDAClH,QAAQ,cAAc;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAOnC,8OAAC,+IAAW;gBAAC,WAAU;0BACrB,cAAA,8OAAC;oBAAI,WAAU;;sCAEb,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAI,WAAU;;sDACb,8OAAC,sNAAQ;4CAAC,WAAU;;;;;;sDACpB,8OAAC;4CAAK,WAAU;sDAAqB,IAAA,gKAAM,EAAC,IAAI,KAAK,QAAQ,YAAY,GAAG;;;;;;;;;;;;8CAE9E,8OAAC;oCAAI,WAAU;;sDACb,8OAAC,6MAAK;4CAAC,WAAU;;;;;;sDACjB,8OAAC;4CAAK,WAAU;sDAAqB,QAAQ,YAAY;;;;;;;;;;;;;;;;;;sCAK7D,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,oNAAM;oCAAC,WAAU;;;;;;8CAClB,8OAAC;oCAAK,WAAU;;wCACb,QAAQ,eAAe;wCAAC;wCAAG,QAAQ,cAAc;;;;;;;;;;;;;sCAKpD,8OAAC;4BAAI,WAAU;;8CACf,8OAAC;oCAAI,WAAU;;sDACb,8OAAC;4CAAE,WAAU;sDAA2C;;;;;;sDACxD,8OAAC;4CAAE,WAAU;;gDAAmE;gDAAE,QAAQ,YAAY,CAAC,OAAO,CAAC;;;;;;;;;;;;;8CAEjH,8OAAC,4IAAM;oCAAC,OAAO;oCAAC,SAAQ;oCAAU,MAAK;oCAAK,WAAU;8CACpD,cAAA,8OAAC,uKAAI;wCAAC,MAAM,CAAC,oBAAoB,EAAE,QAAQ,EAAE,EAAE;wCAAE,WAAU;;4CAAmC;0DAE5F,8OAAC,gOAAU;gDAAC,WAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQtC"}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/tabs.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Tabs = TabsPrimitive.Root;\r\n\r\nconst TabsList = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.List>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.List\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\r\n      className,\r\n    )}\r\n    {...props}\r\n  />\r\n));\r\nTabsList.displayName = TabsPrimitive.List.displayName;\r\n\r\nconst TabsTrigger = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Trigger\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\r\n      className,\r\n    )}\r\n    {...props}\r\n  />\r\n));\r\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName;\r\n\r\nconst TabsContent = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Content\r\n    ref={ref}\r\n    className={cn(\r\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\r\n      className,\r\n    )}\r\n    {...props}\r\n  />\r\n));\r\nTabsContent.displayName = TabsPrimitive.Content.displayName;\r\n\r\nexport { Tabs, TabsList, TabsTrigger, TabsContent };\r\n"],"names":[],"mappings":";;;;;;;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,OAAO,wKAAkB;AAE/B,MAAM,yBAAW,mNAAgB,CAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,wKAAkB;QACjB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,8FACA;QAED,GAAG,KAAK;;;;;;AAGb,SAAS,WAAW,GAAG,wKAAkB,CAAC,WAAW;AAErD,MAAM,4BAAc,mNAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,2KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,uYACA;QAED,GAAG,KAAK;;;;;;AAGb,YAAY,WAAW,GAAG,2KAAqB,CAAC,WAAW;AAE3D,MAAM,4BAAc,mNAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,2KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,mIACA;QAED,GAAG,KAAK;;;;;;AAGb,YAAY,WAAW,GAAG,2KAAqB,CAAC,WAAW"}},
    {"offset": {"line": 477, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/components/DashboardBookingFilters.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';\r\n\r\ninterface DashboardBookingFiltersProps {\r\n  filter: 'upcoming' | 'past';\r\n  onFilterChange: (filter: 'upcoming' | 'past') => void;\r\n}\r\n\r\nexport function DashboardBookingFilters({ filter, onFilterChange }: DashboardBookingFiltersProps) {\r\n  return (\r\n    <Tabs value={filter} onValueChange={(value) => onFilterChange(value as typeof filter)}>\r\n      <TabsList className=\"w-full sm:w-auto grid grid-cols-2 sm:inline-flex h-10 sm:h-11\">\r\n        <TabsTrigger value=\"upcoming\" className=\"text-sm sm:text-base px-3 sm:px-4\">Upcoming</TabsTrigger>\r\n        <TabsTrigger value=\"past\" className=\"text-sm sm:text-base px-3 sm:px-4\">Past</TabsTrigger>\r\n      </TabsList>\r\n    </Tabs>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;AAEA;AAFA;;;AASO,SAAS,wBAAwB,EAAE,MAAM,EAAE,cAAc,EAAgC;IAC9F,qBACE,8OAAC,wIAAI;QAAC,OAAO;QAAQ,eAAe,CAAC,QAAU,eAAe;kBAC5D,cAAA,8OAAC,4IAAQ;YAAC,WAAU;;8BAClB,8OAAC,+IAAW;oBAAC,OAAM;oBAAW,WAAU;8BAAoC;;;;;;8BAC5E,8OAAC,+IAAW;oBAAC,OAAM;oBAAO,WAAU;8BAAoC;;;;;;;;;;;;;;;;;AAIhF"}},
    {"offset": {"line": 527, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          first_name: data.first_name.trim(),\r\n          last_name: data.last_name.trim(),\r\n          email: data.email.trim(),\r\n          phone: data.phone?.trim() || null,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email: data.email.trim(),\r\n          phone: data.phone?.trim() || null,\r\n          first_name: data.first_name.trim(),\r\n          last_name: data.last_name.trim(),\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MA8BsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 541, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          first_name: data.first_name.trim(),\r\n          last_name: data.last_name.trim(),\r\n          email: data.email.trim(),\r\n          phone: data.phone?.trim() || null,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email: data.email.trim(),\r\n          phone: data.phone?.trim() || null,\r\n          first_name: data.first_name.trim(),\r\n          last_name: data.last_name.trim(),\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAOsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 555, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/quote/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { QuoteFormData, QuoteStatus, Quote, Service, AdditionalService, HomeDetailOption, CleaningEquipment } from '@/types/quote';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport interface SaveQuoteResult {\r\n  success: boolean;\r\n  data?: Quote;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Save or update a quote draft\r\n */\r\nexport async function saveQuoteDraft(\r\n  email: string,\r\n  formData: QuoteFormData\r\n): Promise<SaveQuoteResult> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    // Check if a draft already exists for this email\r\n    const { data: existingDraft } = await supabase\r\n      .from('quotes')\r\n      .select('id')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (existingDraft) {\r\n      // Update existing draft\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .update({\r\n          form_data: formData,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('id', existingDraft.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error updating quote draft:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      return { success: true, data: data as Quote };\r\n    } else {\r\n      // Create new draft\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .insert({\r\n          email: email.trim().toLowerCase(),\r\n          status: 'draft',\r\n          form_data: formData,\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error creating quote draft:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      return { success: true, data: data as Quote };\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error saving quote draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get the latest draft quote for an email\r\n */\r\nexport async function getQuoteDraft(email: string): Promise<Quote | null> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return null;\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('quotes')\r\n      .select('*')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (error) {\r\n      // If no draft exists, that's okay - return null\r\n      if (error.code === 'PGRST116') {\r\n        return null;\r\n      }\r\n      console.error('Error fetching quote draft:', error);\r\n      return null;\r\n    }\r\n\r\n    return data as Quote;\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching quote draft:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all quotes (drafts and submitted) for an email\r\n */\r\nexport async function getQuotesByEmail(email: string): Promise<Quote[]> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return [];\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('quotes')\r\n      .select('*')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .order('updated_at', { ascending: false });\r\n\r\n    if (error) {\r\n      console.error('Error fetching quotes:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as Quote[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching quotes:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Submit a quote (change status from draft to submitted)\r\n */\r\nexport async function submitQuote(\r\n  email: string,\r\n  formData: QuoteFormData\r\n): Promise<SaveQuoteResult> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    // Check if a draft exists for this email\r\n    const { data: existingDraft } = await supabase\r\n      .from('quotes')\r\n      .select('id')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (existingDraft) {\r\n      // Update existing draft to submitted\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .update({\r\n          status: 'submitted',\r\n          form_data: formData,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('id', existingDraft.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error submitting quote:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      revalidatePath('/booking/quote');\r\n      return { success: true, data: data as Quote };\r\n    } else {\r\n      // Create new submitted quote\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .insert({\r\n          email: email.trim().toLowerCase(),\r\n          status: 'submitted',\r\n          form_data: formData,\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error creating submitted quote:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      revalidatePath('/booking/quote');\r\n      return { success: true, data: data as Quote };\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error submitting quote:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get all active services ordered by display_order\r\n */\r\nexport async function getServices(): Promise<Service[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('services')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching services:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as Service[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching services:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get additional services, optionally filtered by main service\r\n */\r\nexport async function getAdditionalServices(serviceId?: string): Promise<AdditionalService[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    if (serviceId) {\r\n      // Get additional services filtered by service rules\r\n      const { data, error } = await supabase\r\n        .from('service_additional_service_rules')\r\n        .select(`\r\n          additional_service_id,\r\n          additional_services:additional_service_id(*)\r\n        `)\r\n        .eq('service_id', serviceId);\r\n\r\n      if (error) {\r\n        console.error('Error fetching additional services by service:', error);\r\n        return [];\r\n      }\r\n\r\n      // Extract and format the additional services\r\n      const additionalServices = (data || [])\r\n        .map((rule: any) => rule.additional_services)\r\n        .filter((service: AdditionalService) => service && service.is_active)\r\n        .sort((a: AdditionalService, b: AdditionalService) => a.display_order - b.display_order);\r\n\r\n      return additionalServices as AdditionalService[];\r\n    } else {\r\n      // Get all active additional services\r\n      const { data, error } = await supabase\r\n        .from('additional_services')\r\n        .select('*')\r\n        .eq('is_active', true)\r\n        .order('display_order', { ascending: true });\r\n\r\n      if (error) {\r\n        console.error('Error fetching all additional services:', error);\r\n        return [];\r\n      }\r\n\r\n      return (data || []) as AdditionalService[];\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching additional services:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get home detail options for a specific type (bedrooms, bathrooms, carpet_type, room_status)\r\n */\r\nexport async function getHomeDetailOptions(optionType: string): Promise<HomeDetailOption[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('*')\r\n      .eq('option_type', optionType)\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error(`Error fetching home detail options for ${optionType}:`, error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as HomeDetailOption[];\r\n  } catch (error) {\r\n    console.error(`Unexpected error fetching home detail options for ${optionType}:`, error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get all active cleaning equipment ordered by display_order\r\n */\r\nexport async function getCleaningEquipment(): Promise<CleaningEquipment[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('cleaning_equipment')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaning equipment:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as CleaningEquipment[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaning equipment:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MA+NsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,+CAAA"}},
    {"offset": {"line": 569, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/icon-mapper.ts"],"sourcesContent":["import {\r\n  Home,\r\n  Star,\r\n  Calendar,\r\n  Building2,\r\n  Armchair,\r\n  Grid3X3,\r\n  Layers,\r\n  LayoutGrid,\r\n  Refrigerator,\r\n  CookingPot,\r\n  Shirt,\r\n  WashingMachine,\r\n  Bed,\r\n  Wind,\r\n  LucideIcon,\r\n} from \"lucide-react\";\r\n\r\n// Map icon name strings to Lucide React icon components\r\nconst iconMap: Record<string, LucideIcon> = {\r\n  Home,\r\n  Star,\r\n  Calendar,\r\n  Building2,\r\n  Armchair,\r\n  Grid3X3,\r\n  Layers,\r\n  LayoutGrid,\r\n  Refrigerator,\r\n  CookingPot,\r\n  Shirt,\r\n  WashingMachine,\r\n  Bed,\r\n  Wind,\r\n};\r\n\r\n/**\r\n * Get a Lucide icon component by its name\r\n * @param iconName - The name of the icon (e.g., \"Home\", \"Star\")\r\n * @returns The icon component or a default icon if not found\r\n */\r\nexport function getIcon(iconName: string): LucideIcon {\r\n  const icon = iconMap[iconName];\r\n  if (!icon) {\r\n    console.warn(`Icon \"${iconName}\" not found in icon map. Using Home as fallback.`);\r\n    return Home; // Default fallback icon\r\n  }\r\n  return icon;\r\n}\r\n\r\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAkBA,wDAAwD;AACxD,MAAM,UAAsC;IAC1C,MAAA,2MAAI;IACJ,MAAA,0MAAI;IACJ,UAAA,sNAAQ;IACR,WAAA,6NAAS;IACT,UAAA,sNAAQ;IACR,SAAA,uNAAO;IACP,QAAA,gNAAM;IACN,YAAA,gOAAU;IACV,cAAA,kOAAY;IACZ,YAAA,gOAAU;IACV,OAAA,6MAAK;IACL,gBAAA,4OAAc;IACd,KAAA,uMAAG;IACH,MAAA,0MAAI;AACN;AAOO,SAAS,QAAQ,QAAgB;IACtC,MAAM,OAAO,OAAO,CAAC,SAAS;IAC9B,IAAI,CAAC,MAAM;QACT,QAAQ,IAAI,CAAC,CAAC,MAAM,EAAE,SAAS,gDAAgD,CAAC;QAChF,OAAO,2MAAI,EAAE,wBAAwB;IACvC;IACA,OAAO;AACT"}},
    {"offset": {"line": 617, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/utils/slug.ts"],"sourcesContent":["import { Service } from '@/types/quote';\r\n\r\n/**\r\n * Generate a URL-friendly slug from a service name\r\n * Examples:\r\n * - \"Standard Cleaning\"  \"standard-cleaning\"\r\n * - \"Move In/Out\"  \"move-in-out\"\r\n * - \"Airbnb Cleaning\"  \"airbnb-cleaning\"\r\n */\r\nexport function generateSlug(name: string): string {\r\n  return name\r\n    .toLowerCase()\r\n    .trim()\r\n    // Replace slashes with hyphens\r\n    .replace(/\\//g, '-')\r\n    // Replace spaces and special characters with hyphens\r\n    .replace(/[^\\w\\s-]/g, '')\r\n    .replace(/\\s+/g, '-')\r\n    // Remove multiple consecutive hyphens\r\n    .replace(/-+/g, '-')\r\n    // Remove leading/trailing hyphens\r\n    .replace(/^-+|-+$/g, '');\r\n}\r\n\r\n/**\r\n * Find a service by its slug\r\n */\r\nexport function findServiceBySlug(services: Service[], slug: string): Service | undefined {\r\n  return services.find(service => generateSlug(service.name) === slug);\r\n}\r\n\r\n/**\r\n * Get the slug for a service by its ID\r\n */\r\nexport function getServiceSlugById(services: Service[], serviceId: string): string | undefined {\r\n  const service = services.find(s => s.id === serviceId);\r\n  return service ? generateSlug(service.name) : undefined;\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;AASO,SAAS,aAAa,IAAY;IACvC,OAAO,KACJ,WAAW,GACX,IAAI,EACL,+BAA+B;KAC9B,OAAO,CAAC,OAAO,IAChB,qDAAqD;KACpD,OAAO,CAAC,aAAa,IACrB,OAAO,CAAC,QAAQ,IACjB,sCAAsC;KACrC,OAAO,CAAC,OAAO,IAChB,kCAAkC;KACjC,OAAO,CAAC,YAAY;AACzB;AAKO,SAAS,kBAAkB,QAAmB,EAAE,IAAY;IACjE,OAAO,SAAS,IAAI,CAAC,CAAA,UAAW,aAAa,QAAQ,IAAI,MAAM;AACjE;AAKO,SAAS,mBAAmB,QAAmB,EAAE,SAAiB;IACvE,MAAM,UAAU,SAAS,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;IAC5C,OAAO,UAAU,aAAa,QAAQ,IAAI,IAAI;AAChD"}},
    {"offset": {"line": 643, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useEffect, useState } from 'react';\r\nimport { useRouter } from 'next/navigation';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { BookingCard } from './components/BookingCard';\r\nimport { DashboardBookingFilters } from './components/DashboardBookingFilters';\r\nimport { getCustomerBookings, getAuthenticatedUser } from './actions';\r\nimport { getServices } from '../booking/quote/actions';\r\nimport { Booking } from '@/types/booking';\r\nimport { Loader2, ChevronRight } from 'lucide-react';\r\nimport { Card, CardContent } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { getIcon } from '@/lib/icon-mapper';\r\nimport { generateSlug } from '@/lib/utils/slug';\r\n\r\nexport default function DashboardPage() {\r\n  const router = useRouter();\r\n  const [bookings, setBookings] = useState<Booking[]>([]);\r\n  const [loading, setLoading] = useState(false);\r\n  const [userEmail, setUserEmail] = useState<string | null>(null);\r\n  const [selectedServiceId, setSelectedServiceId] = useState<string | null>(null);\r\n  const [bookingFilter, setBookingFilter] = useState<'upcoming' | 'past'>('upcoming');\r\n\r\n  // Fetch services for \"Book a service\" section\r\n  const { data: services = [], isLoading: isLoadingServices } = useQuery({\r\n    queryKey: ['services'],\r\n    queryFn: getServices,\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Get authenticated user's email\r\n  useQuery({\r\n    queryKey: ['authenticated-user'],\r\n    queryFn: async () => {\r\n      const result = await getAuthenticatedUser();\r\n      if (result.success && result.email) {\r\n        setUserEmail(result.email);\r\n        return result.email;\r\n      }\r\n      return null;\r\n    },\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  const loadBookings = async (customerEmail: string) => {\r\n    try {\r\n      setLoading(true);\r\n      const result = await getCustomerBookings(customerEmail, undefined, 'all');\r\n      if (result.success && result.bookings) {\r\n        setBookings(result.bookings);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading bookings:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Load bookings when user email is available\r\n  useEffect(() => {\r\n    if (userEmail) {\r\n      loadBookings(userEmail);\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [userEmail]);\r\n\r\n  const handleServiceClick = (serviceId: string) => {\r\n    setSelectedServiceId(serviceId);\r\n    const service = services.find(s => s.id === serviceId);\r\n    if (service) {\r\n      const slug = generateSlug(service.name);\r\n      router.push(`/booking/details/${slug}`);\r\n    }\r\n  };\r\n\r\n  const upcomingBookings = bookings.filter(\r\n    (booking) => booking.status === 'pending' || booking.status === 'confirmed'\r\n  );\r\n\r\n  const pastBookings = bookings.filter(\r\n    (booking) => booking.status === 'completed' || booking.status === 'cancelled'\r\n  );\r\n\r\n  const filteredBookings = bookingFilter === 'upcoming' ? upcomingBookings : pastBookings;\r\n\r\n  return (\r\n    <div className=\"space-y-6 md:space-y-8 w-full max-w-full overflow-x-hidden\">\r\n      {/* Book a service section */}\r\n      <div className=\"space-y-3 sm:space-y-4 w-full max-w-full overflow-x-hidden\">\r\n        <h2 className=\"text-xl sm:text-2xl md:text-3xl font-bold\">Book a service</h2>\r\n        {isLoadingServices ? (\r\n          <div className=\"flex items-center justify-center py-8\">\r\n            <Loader2 className=\"w-6 h-6 animate-spin text-primary\" />\r\n          </div>\r\n        ) : (\r\n          <div className=\"relative w-full overflow-x-hidden\">\r\n            <div \r\n              className=\"overflow-x-auto pb-3 sm:pb-4 -mx-4 px-4 sm:mx-0 sm:px-0 [&::-webkit-scrollbar]:hidden w-full\" \r\n              style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}\r\n            >\r\n              <div className=\"flex gap-3 sm:gap-4 min-w-max w-max\">\r\n                {services.map((service) => {\r\n                  const IconComponent = getIcon(service.icon_name);\r\n                  const isSelected = selectedServiceId === service.id;\r\n                  return (\r\n                    <div\r\n                      key={service.id}\r\n                      className=\"flex flex-col items-center gap-1.5 sm:gap-2 min-w-[80px] sm:min-w-[90px] md:min-w-[100px] cursor-pointer touch-manipulation\"\r\n                      onClick={() => handleServiceClick(service.id)}\r\n                    >\r\n                      <div\r\n                        className={`flex items-center justify-center p-2 sm:p-2.5 md:p-3 rounded-xl border-2 transition-all w-14 h-14 sm:w-16 sm:h-16 md:w-20 md:h-20 ${\r\n                          isSelected\r\n                            ? 'border-primary bg-primary/5'\r\n                            : 'border-border hover:border-primary/50 bg-background active:scale-95'\r\n                        }`}\r\n                      >\r\n                        <IconComponent\r\n                          className={`w-5 h-5 sm:w-6 sm:h-6 md:w-8 md:h-8 ${\r\n                            isSelected ? 'text-primary' : 'text-muted-foreground'\r\n                          }`}\r\n                        />\r\n                      </div>\r\n                      <span className=\"font-medium text-xs sm:text-sm md:text-base text-foreground text-center leading-tight px-0.5 sm:px-1\">\r\n                        {service.name.split(' ').map((word, idx, arr) => (\r\n                          <span key={idx}>\r\n                            {word}\r\n                            {idx === 0 && arr.length > 1 && <br />}\r\n                          </span>\r\n                        ))}\r\n                      </span>\r\n                      {isSelected && (\r\n                        <div className=\"w-full h-0.5 sm:h-1 bg-primary rounded-full mt-0.5 sm:mt-1\" />\r\n                      )}\r\n                    </div>\r\n                  );\r\n                })}\r\n              </div>\r\n            </div>\r\n            {services.length > 5 && (\r\n              <div className=\"hidden sm:block absolute right-0 top-1/2 -translate-y-1/2 bg-gradient-to-l from-background to-transparent w-20 h-full pointer-events-none flex items-center justify-end pr-2\">\r\n                <ChevronRight className=\"w-5 h-5 text-primary\" />\r\n              </div>\r\n            )}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Bookings section with filter */}\r\n      {userEmail && (\r\n        <div className=\"space-y-4\">\r\n          <DashboardBookingFilters filter={bookingFilter} onFilterChange={setBookingFilter} />\r\n          {loading ? (\r\n            <div className=\"flex items-center justify-center py-8\">\r\n              <Loader2 className=\"w-6 h-6 animate-spin text-primary\" />\r\n            </div>\r\n          ) : filteredBookings.length === 0 ? (\r\n            <p className=\"text-base md:text-lg text-muted-foreground text-center py-4\">\r\n              No {bookingFilter === 'upcoming' ? 'upcoming' : 'past'} bookings\r\n            </p>\r\n          ) : (\r\n            <div className=\"grid gap-3 md:gap-4\">\r\n              {filteredBookings.map((booking) => (\r\n                <BookingCard key={booking.id} booking={booking} />\r\n              ))}\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n\r\n      {!userEmail && !loading && (\r\n        <div className=\"flex items-center justify-center py-8\">\r\n          <Loader2 className=\"w-6 h-6 animate-spin text-primary\" />\r\n        </div>\r\n      )}\r\n\r\n      {/* Refer & Earn promotion card */}\r\n      <div className=\"grid md:grid-cols-2 gap-3 sm:gap-4 md:gap-6 w-full max-w-full\">\r\n        <Card className=\"bg-primary-light border-primary/20 w-full max-w-full overflow-hidden\">\r\n          <CardContent className=\"p-3 sm:p-4 md:p-6\">\r\n            <div className=\"space-y-2.5 sm:space-y-3 md:space-y-4\">\r\n              <div>\r\n                <p className=\"text-sm sm:text-base md:text-lg text-foreground leading-relaxed\">\r\n                  Invite friends & earn <strong>R150 ShaleanCred</strong> per friend referral\r\n                </p>\r\n              </div>\r\n              <Button \r\n                variant=\"outline\"\r\n                className=\"w-full border-2 text-sm sm:text-base md:text-lg h-9 sm:h-10 md:h-11\"\r\n                onClick={() => router.push('/dashboard/refer')}\r\n              >\r\n                Refer & Earn\r\n              </Button>\r\n              <p className=\"text-xs sm:text-sm text-muted-foreground text-center\">Ts & Cs apply</p>\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n      </div>\r\n\r\n      {/* Book Now button - Normal on desktop */}\r\n      <div className=\"hidden md:flex justify-center pt-2 sm:pt-3 md:pt-4\">\r\n        <Button\r\n          size=\"lg\"\r\n          className=\"bg-primary hover:bg-primary/90 text-primary-foreground w-full sm:w-auto px-6 sm:px-8 md:px-12 py-4 sm:py-5 md:py-6 text-base sm:text-lg md:text-xl h-11 sm:h-12 md:h-14\"\r\n          onClick={() => router.push('/booking/details')}\r\n        >\r\n          Book Now\r\n        </Button>\r\n      </div>\r\n      \r\n      {/* Sticky Book Now button for mobile - positioned above bottom nav */}\r\n      <div className=\"fixed bottom-16 left-0 right-0 z-40 px-8 pb-2 md:hidden flex justify-center\">\r\n        <Button\r\n          size=\"lg\"\r\n          className=\"bg-primary hover:bg-primary/90 text-primary-foreground w-auto px-8 py-4 text-base h-12 shadow-lg\"\r\n          onClick={() => router.push('/booking/details')}\r\n        >\r\n          Book Now\r\n        </Button>\r\n      </div>\r\n      \r\n      {/* Spacer for mobile to prevent content from being hidden behind sticky button */}\r\n      <div className=\"h-20 md:hidden\" />\r\n    </div>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAdA;;;;;;;;;;;;;;AAgBe,SAAS;IACtB,MAAM,SAAS,IAAA,+IAAS;IACxB,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,iNAAQ,EAAY,EAAE;IACtD,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,iNAAQ,EAAC;IACvC,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,iNAAQ,EAAgB;IAC1D,MAAM,CAAC,mBAAmB,qBAAqB,GAAG,IAAA,iNAAQ,EAAgB;IAC1E,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,iNAAQ,EAAsB;IAExE,8CAA8C;IAC9C,MAAM,EAAE,MAAM,WAAW,EAAE,EAAE,WAAW,iBAAiB,EAAE,GAAG,IAAA,uLAAQ,EAAC;QACrE,UAAU;YAAC;SAAW;QACtB,SAAS,8KAAW;QACpB,WAAW,IAAI,KAAK;IACtB;IAEA,iCAAiC;IACjC,IAAA,uLAAQ,EAAC;QACP,UAAU;YAAC;SAAqB;QAChC,SAAS;YACP,MAAM,SAAS,MAAM,IAAA,gLAAoB;YACzC,IAAI,OAAO,OAAO,IAAI,OAAO,KAAK,EAAE;gBAClC,aAAa,OAAO,KAAK;gBACzB,OAAO,OAAO,KAAK;YACrB;YACA,OAAO;QACT;QACA,WAAW,IAAI,KAAK;IACtB;IAEA,MAAM,eAAe,OAAO;QAC1B,IAAI;YACF,WAAW;YACX,MAAM,SAAS,MAAM,IAAA,+KAAmB,EAAC,eAAe,WAAW;YACnE,IAAI,OAAO,OAAO,IAAI,OAAO,QAAQ,EAAE;gBACrC,YAAY,OAAO,QAAQ;YAC7B;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;QAC3C,SAAU;YACR,WAAW;QACb;IACF;IAEA,6CAA6C;IAC7C,IAAA,kNAAS,EAAC;QACR,IAAI,WAAW;YACb,aAAa;QACf;IACA,uDAAuD;IACzD,GAAG;QAAC;KAAU;IAEd,MAAM,qBAAqB,CAAC;QAC1B,qBAAqB;QACrB,MAAM,UAAU,SAAS,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAC5C,IAAI,SAAS;YACX,MAAM,OAAO,IAAA,2IAAY,EAAC,QAAQ,IAAI;YACtC,OAAO,IAAI,CAAC,CAAC,iBAAiB,EAAE,MAAM;QACxC;IACF;IAEA,MAAM,mBAAmB,SAAS,MAAM,CACtC,CAAC,UAAY,QAAQ,MAAM,KAAK,aAAa,QAAQ,MAAM,KAAK;IAGlE,MAAM,eAAe,SAAS,MAAM,CAClC,CAAC,UAAY,QAAQ,MAAM,KAAK,eAAe,QAAQ,MAAM,KAAK;IAGpE,MAAM,mBAAmB,kBAAkB,aAAa,mBAAmB;IAE3E,qBACE,8OAAC;QAAI,WAAU;;0BAEb,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBAAG,WAAU;kCAA4C;;;;;;oBACzD,kCACC,8OAAC;wBAAI,WAAU;kCACb,cAAA,8OAAC,4NAAO;4BAAC,WAAU;;;;;;;;;;6CAGrB,8OAAC;wBAAI,WAAU;;0CACb,8OAAC;gCACC,WAAU;gCACV,OAAO;oCAAE,gBAAgB;oCAAQ,iBAAiB;gCAAO;0CAEzD,cAAA,8OAAC;oCAAI,WAAU;8CACZ,SAAS,GAAG,CAAC,CAAC;wCACb,MAAM,gBAAgB,IAAA,uIAAO,EAAC,QAAQ,SAAS;wCAC/C,MAAM,aAAa,sBAAsB,QAAQ,EAAE;wCACnD,qBACE,8OAAC;4CAEC,WAAU;4CACV,SAAS,IAAM,mBAAmB,QAAQ,EAAE;;8DAE5C,8OAAC;oDACC,WAAW,CAAC,kIAAkI,EAC5I,aACI,gCACA,uEACJ;8DAEF,cAAA,8OAAC;wDACC,WAAW,CAAC,oCAAoC,EAC9C,aAAa,iBAAiB,yBAC9B;;;;;;;;;;;8DAGN,8OAAC;oDAAK,WAAU;8DACb,QAAQ,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,MAAM,KAAK,oBACvC,8OAAC;;gEACE;gEACA,QAAQ,KAAK,IAAI,MAAM,GAAG,mBAAK,8OAAC;;;;;;2DAFxB;;;;;;;;;;gDAMd,4BACC,8OAAC;oDAAI,WAAU;;;;;;;2CA1BZ,QAAQ,EAAE;;;;;oCA8BrB;;;;;;;;;;;4BAGH,SAAS,MAAM,GAAG,mBACjB,8OAAC;gCAAI,WAAU;0CACb,cAAA,8OAAC,sOAAY;oCAAC,WAAU;;;;;;;;;;;;;;;;;;;;;;;YAQjC,2BACC,8OAAC;gBAAI,WAAU;;kCACb,8OAAC,qLAAuB;wBAAC,QAAQ;wBAAe,gBAAgB;;;;;;oBAC/D,wBACC,8OAAC;wBAAI,WAAU;kCACb,cAAA,8OAAC,4NAAO;4BAAC,WAAU;;;;;;;;;;+BAEnB,iBAAiB,MAAM,KAAK,kBAC9B,8OAAC;wBAAE,WAAU;;4BAA8D;4BACrE,kBAAkB,aAAa,aAAa;4BAAO;;;;;;6CAGzD,8OAAC;wBAAI,WAAU;kCACZ,iBAAiB,GAAG,CAAC,CAAC,wBACrB,8OAAC,6JAAW;gCAAkB,SAAS;+BAArB,QAAQ,EAAE;;;;;;;;;;;;;;;;YAOrC,CAAC,aAAa,CAAC,yBACd,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC,4NAAO;oBAAC,WAAU;;;;;;;;;;;0BAKvB,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC,wIAAI;oBAAC,WAAU;8BACd,cAAA,8OAAC,+IAAW;wBAAC,WAAU;kCACrB,cAAA,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;8CACC,cAAA,8OAAC;wCAAE,WAAU;;4CAAkE;0DACvD,8OAAC;0DAAO;;;;;;4CAAyB;;;;;;;;;;;;8CAG3D,8OAAC,4IAAM;oCACL,SAAQ;oCACR,WAAU;oCACV,SAAS,IAAM,OAAO,IAAI,CAAC;8CAC5B;;;;;;8CAGD,8OAAC;oCAAE,WAAU;8CAAuD;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAO5E,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC,4IAAM;oBACL,MAAK;oBACL,WAAU;oBACV,SAAS,IAAM,OAAO,IAAI,CAAC;8BAC5B;;;;;;;;;;;0BAMH,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC,4IAAM;oBACL,MAAK;oBACL,WAAU;oBACV,SAAS,IAAM,OAAO,IAAI,CAAC;8BAC5B;;;;;;;;;;;0BAMH,8OAAC;gBAAI,WAAU;;;;;;;;;;;;AAGrB"}}]
}