{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (\r\n  <div ref={ref} className={cn(\"rounded-lg border bg-card text-card-foreground shadow-sm\", className)} {...props} />\r\n));\r\nCard.displayName = \"Card\";\r\n\r\nconst CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex flex-col space-y-1.5 p-6\", className)} {...props} />\r\n  ),\r\n);\r\nCardHeader.displayName = \"CardHeader\";\r\n\r\nconst CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <h3 ref={ref} className={cn(\"text-2xl font-semibold leading-none tracking-tight\", className)} {...props} />\r\n  ),\r\n);\r\nCardTitle.displayName = \"CardTitle\";\r\n\r\nconst CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <p ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\r\n  ),\r\n);\r\nCardDescription.displayName = \"CardDescription\";\r\n\r\nconst CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />,\r\n);\r\nCardContent.displayName = \"CardContent\";\r\n\r\nconst CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex items-center p-6 pt-0\", className)} {...props} />\r\n  ),\r\n);\r\nCardFooter.displayName = \"CardFooter\";\r\n\r\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,mNAAgB,CAAuD,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC5G,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,4DAA4D;QAAa,GAAG,KAAK;;;;;;AAEhH,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,mNAAgB,CACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;AAGvF,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,mNAAgB,CAChC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAG,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,sDAAsD;QAAa,GAAG,KAAK;;;;;;AAG3G,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,mNAAgB,CACtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAE,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;AAGrF,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,mNAAgB,CAClC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAAQ,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,YAAY;QAAa,GAAG,KAAK;;;;;;AAElG,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,mNAAgB,CACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,8BAA8B;QAAa,GAAG,KAAK;;;;;;AAGpF,WAAW,WAAW,GAAG"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/badge.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst badgeVariants = cva(\r\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\r\n        secondary: \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        destructive: \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\r\n        outline: \"text-foreground\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n    },\r\n  },\r\n);\r\n\r\nexport interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}\r\n\r\nfunction Badge({ className, variant, ...props }: BadgeProps) {\r\n  return <div className={cn(badgeVariants({ variant }), className)} {...props} />;\r\n}\r\n\r\nexport { Badge, badgeVariants };\r\n"],"names":[],"mappings":";;;;;;;AACA;AAEA;;;;AAEA,MAAM,gBAAgB,IAAA,uKAAG,EACvB,0KACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,WAAW;YACX,aAAa;YACb,SAAS;QACX;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAKF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBAAO,8OAAC;QAAI,WAAW,IAAA,yHAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAC7E"}},
    {"offset": {"line": 131, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/components/CleanerBookingCard.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { Booking } from '@/types/booking';\r\nimport { Card, CardContent, CardHeader } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Calendar, Clock, MapPin, ArrowRight, User } from 'lucide-react';\r\nimport { format } from 'date-fns';\r\nimport Link from 'next/link';\r\n\r\ninterface CleanerBookingCardProps {\r\n  booking: Booking;\r\n  earnings?: number; // Optional: cleaner's earnings for this booking\r\n}\r\n\r\nexport function CleanerBookingCard({ booking, earnings }: CleanerBookingCardProps) {\r\n  const statusColors = {\r\n    pending: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/20 dark:text-yellow-400',\r\n    confirmed: 'bg-blue-100 text-blue-800 dark:bg-blue-900/20 dark:text-blue-400',\r\n    on_my_way: 'bg-orange-100 text-orange-800 dark:bg-orange-900/20 dark:text-orange-400',\r\n    started: 'bg-purple-100 text-purple-800 dark:bg-purple-900/20 dark:text-purple-400',\r\n    completed: 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-400',\r\n    cancelled: 'bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-400',\r\n  };\r\n\r\n  const paymentColors = {\r\n    pending: 'bg-gray-100 text-gray-800 dark:bg-gray-900/20 dark:text-gray-400',\r\n    paid: 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-400',\r\n    failed: 'bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-400',\r\n    refunded: 'bg-orange-100 text-orange-800 dark:bg-orange-900/20 dark:text-orange-400',\r\n  };\r\n\r\n  const statusLabel = booking.status.replace('_', ' ').replace(/\\b\\w/g, l => l.toUpperCase());\r\n\r\n  return (\r\n    <Card className=\"hover:shadow-md transition-shadow border-border w-full max-w-full overflow-hidden\">\r\n      <CardHeader className=\"pb-2 px-3 py-3 sm:px-4 sm:py-4 md:px-6 md:py-6\">\r\n        <div className=\"flex flex-col gap-2\">\r\n          <div className=\"flex items-start justify-between gap-2\">\r\n            <div className=\"flex-1 min-w-0\">\r\n              <h3 className=\"font-semibold text-base sm:text-lg md:text-xl truncate\">{booking.service_type}</h3>\r\n              <p className=\"text-sm text-muted-foreground mt-0.5\">#{booking.booking_number}</p>\r\n            </div>\r\n            <div className=\"flex flex-wrap gap-1.5 sm:gap-2 flex-shrink-0\">\r\n              <Badge className={`${statusColors[booking.status as keyof typeof statusColors] || statusColors.pending} text-xs sm:text-sm px-2 sm:px-3 py-0.5`}>\r\n                {statusLabel}\r\n              </Badge>\r\n              {booking.payment_status !== booking.status && (\r\n                <Badge variant=\"outline\" className={`${paymentColors[booking.payment_status] || paymentColors.pending} text-xs sm:text-sm px-2 sm:px-3 py-0.5`}>\r\n                  {booking.payment_status}\r\n                </Badge>\r\n              )}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </CardHeader>\r\n      <CardContent className=\"px-3 pb-3 sm:px-4 sm:pb-4 md:px-6 md:pb-6 pt-0\">\r\n        <div className=\"space-y-2.5 sm:space-y-3\">\r\n          {/* Customer Name */}\r\n          <div className=\"flex items-center gap-1.5 sm:gap-2 text-sm sm:text-base\">\r\n            <User className=\"w-4 h-4 sm:w-5 sm:h-5 text-muted-foreground flex-shrink-0\" />\r\n            <span className=\"font-medium\">\r\n              {booking.customer_first_name} {booking.customer_last_name}\r\n            </span>\r\n          </div>\r\n\r\n          {/* Date & Time */}\r\n          <div className=\"flex flex-col gap-1.5 sm:flex-row sm:items-center sm:gap-3 text-sm sm:text-base\">\r\n            <div className=\"flex items-center gap-1.5 sm:gap-2\">\r\n              <Calendar className=\"w-4 h-4 sm:w-5 sm:h-5 text-muted-foreground flex-shrink-0\" />\r\n              <span className=\"whitespace-nowrap\">{format(new Date(booking.service_date), 'MMM d, yyyy')}</span>\r\n            </div>\r\n            <div className=\"flex items-center gap-1.5 sm:gap-2\">\r\n              <Clock className=\"w-4 h-4 sm:w-5 sm:h-5 text-muted-foreground flex-shrink-0\" />\r\n              <span className=\"whitespace-nowrap\">{booking.service_time} ({booking.service_duration}h)</span>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Address */}\r\n          <div className=\"flex items-start gap-1.5 sm:gap-2 text-sm sm:text-base\">\r\n            <MapPin className=\"w-4 h-4 sm:w-5 sm:h-5 text-muted-foreground mt-0.5 flex-shrink-0\" />\r\n            <span className=\"text-muted-foreground break-words leading-relaxed\">\r\n              {booking.service_address}\r\n              {booking.service_apt_unit && `, ${booking.service_apt_unit}`}\r\n              , {booking.service_suburb}\r\n            </span>\r\n          </div>\r\n\r\n          {/* Lateness info if reported */}\r\n          {booking.expected_arrival_time && (\r\n            <div className=\"flex items-center gap-2 p-2 bg-orange-50 dark:bg-orange-900/20 rounded-md text-sm\">\r\n              <Clock className=\"w-4 h-4 text-orange-600 dark:text-orange-400 flex-shrink-0\" />\r\n              <div>\r\n                <p className=\"font-medium text-orange-800 dark:text-orange-300\">\r\n                  Expected arrival: {format(new Date(booking.expected_arrival_time), 'h:mm a')}\r\n                </p>\r\n                {booking.lateness_reason && (\r\n                  <p className=\"text-orange-700 dark:text-orange-400 text-xs mt-1\">\r\n                    {booking.lateness_reason}\r\n                  </p>\r\n                )}\r\n              </div>\r\n            </div>\r\n          )}\r\n\r\n          {/* Earnings */}\r\n          <div className=\"flex flex-col gap-2.5 sm:flex-row sm:items-center sm:justify-between pt-2 border-t border-border\">\r\n            <div className=\"min-w-0 flex-1\">\r\n              <p className=\"text-xs sm:text-sm text-muted-foreground\">Your Earnings</p>\r\n              <p className=\"text-base sm:text-lg md:text-xl font-semibold mt-0.5 break-words\">\r\n                R{earnings !== undefined ? earnings.toFixed(2) : '0.00'}\r\n              </p>\r\n            </div>\r\n            <Button asChild variant=\"outline\" size=\"sm\" className=\"w-full sm:w-auto text-sm sm:text-base h-9 sm:h-10 flex-shrink-0 sm:ml-2\">\r\n              <Link href={`/cleaner/bookings/${booking.id}`} className=\"flex items-center justify-center\">\r\n                View Details\r\n                <ArrowRight className=\"w-3 h-3 sm:w-4 sm:h-4 ml-1.5 sm:ml-2\" />\r\n              </Link>\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 504, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { createAdminClient } from '@/lib/supabase/server-admin';\r\nimport { Booking } from '@/types/booking';\r\nimport { Cleaner } from '@/types/booking';\r\nimport {\r\n  calculateCleanerTenure,\r\n  calculateTotalHours,\r\n  getEarningsPercentage,\r\n  calculateTotalEarningsFromBooking,\r\n  calculateCleanerEarnings,\r\n  calculateTipPerCleaner,\r\n} from '@/lib/utils/cleaner-earnings';\r\n\r\n/**\r\n * Get cleaner by phone number\r\n */\r\nexport async function getCleanerByPhone(phone: string): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    \r\n    // Normalize phone number (remove spaces, dashes, etc.)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    \r\n    const { data, error } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .or(`phone.eq.${normalizedPhone},phone.eq.+${normalizedPhone}`)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaner by phone:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!data) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: data as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerByPhone:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Authenticate cleaner with phone and password\r\n * Uses Supabase Auth - expects email format: {phone}@cleaners.shalean.local\r\n * Admin should create auth accounts with this email format when creating cleaner accounts\r\n */\r\nexport async function authenticateCleaner(\r\n  phone: string,\r\n  password: string\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // First, find the cleaner by phone to verify they exist\r\n    const cleanerResult = await getCleanerByPhone(phone);\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    const cleaner = cleanerResult.cleaner;\r\n\r\n    // Use phone-based email format for login\r\n    // Format: {phone}@cleaners.shalean.local\r\n    // Normalize phone (remove spaces, keep + if present)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    const authEmail = `${normalizedPhone}@cleaners.shalean.local`;\r\n\r\n    // Authenticate with Supabase Auth using client-side (this should be called from client)\r\n    // Note: This function should ideally be called from a client component\r\n    // For server-side, we'll return the cleaner info and let client handle auth\r\n    const supabase = await createClient();\r\n    \r\n    // Try to authenticate\r\n    const { data, error } = await supabase.auth.signInWithPassword({\r\n      email: authEmail,\r\n      password,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Authentication error:', error);\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Authentication failed' };\r\n    }\r\n\r\n    // Update cleaner's auth_user_id if not set\r\n    if (!cleaner.auth_user_id) {\r\n      try {\r\n        const adminSupabase = createAdminClient();\r\n        await adminSupabase\r\n          .from('cleaners')\r\n          .update({ auth_user_id: data.user.id })\r\n          .eq('id', cleaner.id);\r\n      } catch (updateError) {\r\n        // Log but don't fail - auth_user_id update is optional\r\n        console.warn('Could not update auth_user_id:', updateError);\r\n      }\r\n    }\r\n\r\n    return { success: true, cleaner };\r\n  } catch (error) {\r\n    console.error('Error in authenticateCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Authentication failed',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get current authenticated cleaner\r\n */\r\nexport async function getCurrentCleaner(): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    // Try to find cleaner by auth_user_id first\r\n    let cleanerQuery = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('auth_user_id', user.id)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    let { data: cleaner, error: cleanerError } = await cleanerQuery;\r\n\r\n    // If not found by auth_user_id, try to match by phone from email\r\n    if (!cleaner && !cleanerError && user.email) {\r\n      // Extract phone from email format: {phone}@cleaners.shalean.local\r\n      const phoneMatch = user.email.match(/^(.+)@cleaners\\.shalean\\.local$/);\r\n      if (phoneMatch) {\r\n        const phone = phoneMatch[1];\r\n        const phoneResult = await getCleanerByPhone(phone);\r\n        if (phoneResult.success && phoneResult.cleaner) {\r\n          cleaner = phoneResult.cleaner;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner profile not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: cleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCurrentCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get bookings assigned to the authenticated cleaner\r\n */\r\nexport async function getCleanerBookings(\r\n  filter?: 'all' | 'today' | 'upcoming' | 'past' | 'on_my_way' | 'started'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n    \r\n    // Fetch bookings where cleaner is assigned via preferred_cleaner_id (single)\r\n    let singleQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter\r\n    let arrayQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Apply filters to both queries\r\n    if (filter && filter !== 'all') {\r\n      const today = new Date().toISOString().split('T')[0];\r\n      \r\n      switch (filter) {\r\n        case 'today':\r\n          singleQuery = singleQuery.eq('service_date', today);\r\n          arrayQuery = arrayQuery.eq('service_date', today);\r\n          break;\r\n        case 'upcoming':\r\n          singleQuery = singleQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          arrayQuery = arrayQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          break;\r\n        case 'past':\r\n          singleQuery = singleQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          arrayQuery = arrayQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          break;\r\n        case 'on_my_way':\r\n          singleQuery = singleQuery.eq('status', 'on_my_way');\r\n          arrayQuery = arrayQuery.eq('status', 'on_my_way');\r\n          break;\r\n        case 'started':\r\n          singleQuery = singleQuery.eq('status', 'started');\r\n          arrayQuery = arrayQuery.eq('status', 'started');\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Execute both queries\r\n    const [singleResult, arrayResult] = await Promise.all([\r\n      singleQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true }),\r\n      arrayQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true })\r\n    ]);\r\n\r\n    if (singleResult.error) {\r\n      console.error('Error fetching cleaner bookings (single):', singleResult.error);\r\n      return { success: false, error: singleResult.error.message };\r\n    }\r\n\r\n    if (arrayResult.error) {\r\n      console.error('Error fetching cleaner bookings (array):', arrayResult.error);\r\n      return { success: false, error: arrayResult.error.message };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerBookings] Fetched bookings:', {\r\n      cleanerId,\r\n      filter,\r\n      singleBookingsCount: singleResult.data?.length || 0,\r\n      arrayBookingsCount: arrayResult.data?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const filteredArrayBookings = (arrayResult.data || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine results and remove duplicates\r\n    const allBookings = [\r\n      ...(singleResult.data || []),\r\n      ...filteredArrayBookings\r\n    ];\r\n\r\n    // Remove duplicates by booking ID\r\n    const uniqueBookingsMap = new Map<string, Booking>();\r\n    allBookings.forEach((booking: any) => {\r\n      if (booking.id && !uniqueBookingsMap.has(booking.id)) {\r\n        uniqueBookingsMap.set(booking.id, booking as Booking);\r\n      }\r\n    });\r\n\r\n    const bookings = Array.from(uniqueBookingsMap.values());\r\n\r\n    // Sort by service_date and service_time\r\n    bookings.sort((a, b) => {\r\n      const dateCompare = a.service_date.localeCompare(b.service_date);\r\n      if (dateCompare !== 0) return dateCompare;\r\n      return a.service_time.localeCompare(b.service_time);\r\n    });\r\n\r\n    return { success: true, bookings };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate cleaner earnings for a specific booking\r\n * This helper function is used to display earnings on booking details page\r\n */\r\nexport async function calculateBookingEarnings(bookingId: string): Promise<{\r\n  success: boolean;\r\n  earnings?: {\r\n    baseEarnings: number;\r\n    tipAmount: number;\r\n    totalEarnings: number;\r\n    earningsPercentage: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get the booking\r\n    const { data: booking, error: bookingError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (bookingError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Calculate tenure and total hours to determine percentage\r\n    // For single booking display, we need all paid completed bookings to calculate hours\r\n    // Use the same approach as getCleanerStats\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate base earnings\r\n    const baseEarnings = calculateCleanerEarnings(\r\n      {\r\n        service_type: booking.service_type || '',\r\n        total_amount: Number(booking.total_amount) || 0,\r\n        service_fee: Number(booking.service_fee) || 0,\r\n        preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n        preferred_cleaner_id: booking.preferred_cleaner_id,\r\n      },\r\n      cleanerId,\r\n      earningsPercentage,\r\n      booking.preferred_cleaner_ids\r\n    );\r\n\r\n    // Calculate tip per cleaner\r\n    const tipAmount = calculateTipPerCleaner(\r\n      Number(booking.tip_amount) || 0,\r\n      booking.preferred_cleaner_ids,\r\n      booking.preferred_cleaner_id\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      earnings: {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n        earningsPercentage,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error calculating booking earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get a specific booking by ID (only if assigned to authenticated cleaner)\r\n */\r\nexport async function getCleanerBookingById(\r\n  bookingId: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Fetch the booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError) {\r\n      console.error('Error fetching booking:', fetchError);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    if (!booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Verify the cleaner is assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    // Check single cleaner assignment\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    // Check multiple cleaner assignment\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    if (!isAssignedSingle && !isAssignedMultiple) {\r\n      return { \r\n        success: false, \r\n        error: 'Unauthorized: You are not assigned to this booking' \r\n      };\r\n    }\r\n\r\n    return { success: true, booking: booking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookingById:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch booking',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update booking status (with authorization check for authenticated cleaner)\r\n */\r\nexport async function updateBookingStatus(\r\n  bookingId: string,\r\n  status: Booking['status']\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // First, verify the cleaner is assigned to this booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Validate status transition\r\n    const validTransitions: Record<string, string[]> = {\r\n      'pending': ['confirmed', 'cancelled'],\r\n      'confirmed': ['on_my_way', 'cancelled'],\r\n      'on_my_way': ['started', 'cancelled'],\r\n      'started': ['completed', 'cancelled'],\r\n      'completed': [],\r\n      'cancelled': [],\r\n    };\r\n\r\n    const currentStatus = booking.status;\r\n    const allowedStatuses = validTransitions[currentStatus] || [];\r\n    \r\n    if (!allowedStatuses.includes(status) && status !== currentStatus) {\r\n      return { \r\n        success: false, \r\n        error: `Invalid status transition: cannot change from ${currentStatus} to ${status}` \r\n      };\r\n    }\r\n\r\n    // Update booking status\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({ \r\n        status,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating booking status:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in updateBookingStatus:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update booking status',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Report lateness for a booking (with authorization check for authenticated cleaner)\r\n */\r\nexport async function reportLateness(\r\n  bookingId: string,\r\n  expectedArrivalTime: string, // ISO timestamp\r\n  reason: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Verify authorization\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Update booking with lateness information\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        expected_arrival_time: expectedArrivalTime,\r\n        lateness_reason: reason,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error reporting lateness:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in reportLateness:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to report lateness',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate earnings for multiple bookings at once\r\n * This is more efficient than calculating earnings one booking at a time\r\n */\r\nexport async function calculateBookingsEarnings(bookingIds: string[]): Promise<{\r\n  success: boolean;\r\n  earnings?: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }>;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    if (bookingIds.length === 0) {\r\n      return { success: true, earnings: {} };\r\n    }\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (bookingsError || !bookings) {\r\n      return { success: false, error: 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Get all cleaner bookings to calculate hours\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    // Calculate tenure and hours\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings for each booking\r\n    const earningsRecord: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }> = {};\r\n\r\n    for (const booking of bookings) {\r\n      const baseEarnings = calculateCleanerEarnings(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage,\r\n        booking.preferred_cleaner_ids\r\n      );\r\n\r\n      const tipAmount = calculateTipPerCleaner(\r\n        Number(booking.tip_amount) || 0,\r\n        booking.preferred_cleaner_ids,\r\n        booking.preferred_cleaner_id\r\n      );\r\n\r\n      earningsRecord[booking.id] = {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n      };\r\n    }\r\n\r\n    return { success: true, earnings: earningsRecord };\r\n  } catch (error) {\r\n    console.error('Error calculating bookings earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get cleaner statistics for the authenticated cleaner\r\n */\r\nexport async function getCleanerStats(): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalBookings: number;\r\n    completedBookings: number;\r\n    upcomingBookings: number;\r\n    todayBookings: number;\r\n    totalEarnings: number;\r\n    monthlyEarnings: number;\r\n    averageRating: number;\r\n    reliabilityScore: number;\r\n    completionRate: number;\r\n    onTimeRate: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info including created_at for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('rating, reliability_score, total_bookings, completed_bookings, on_time_bookings, created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings assigned to this cleaner\r\n    // Fetch bookings with preferred_cleaner_id (single) - include all fields needed for earnings calculation\r\n    const { data: singleBookings, error: singleError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter in JS\r\n    const { data: allMultiBookings, error: multiError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_ids, preferred_cleaner_id')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    if (singleError || multiError) {\r\n      console.error('Error fetching bookings for stats:', singleError || multiError);\r\n      return { success: false, error: (singleError || multiError)?.message || 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerStats] Fetched bookings:', {\r\n      cleanerId,\r\n      singleBookingsCount: singleBookings?.length || 0,\r\n      allMultiBookingsCount: allMultiBookings?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const arrayBookings = (allMultiBookings || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates by ID\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((booking: any) => {\r\n      if (booking.id) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    arrayBookings.forEach((booking: any) => {\r\n      if (booking.id && !allBookingsMap.has(booking.id)) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    \r\n    const allBookings = Array.from(allBookingsMap.values());\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n    const now = new Date();\r\n    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];\r\n    const completedBookings = allBookings.filter(b => b.status === 'completed');\r\n    const upcomingBookings = allBookings.filter(b => \r\n      ['pending', 'confirmed', 'on_my_way', 'started'].includes(b.status) &&\r\n      b.service_date >= today\r\n    );\r\n    const todayBookings = allBookings.filter(b => b.service_date === today);\r\n    const paidBookings = allBookings.filter(b => b.payment_status === 'paid');\r\n    const monthlyPaidBookings = paidBookings.filter(b => b.service_date >= firstDayOfMonth);\r\n\r\n    // Calculate cleaner tenure and total hours for eligibility determination\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(allBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings using the new system\r\n    // Only calculate earnings for paid bookings (earnings are only paid when customer has paid)\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const totalEarnings = paidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const monthlyEarnings = monthlyPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const completionRate = cleaner.total_bookings \r\n      ? (cleaner.completed_bookings || 0) / cleaner.total_bookings * 100 \r\n      : 0;\r\n    \r\n    const onTimeRate = cleaner.completed_bookings\r\n      ? (cleaner.on_time_bookings || 0) / cleaner.completed_bookings * 100\r\n      : 0;\r\n\r\n    return {\r\n      success: true,\r\n      stats: {\r\n        totalBookings: allBookings.length,\r\n        completedBookings: completedBookings.length,\r\n        upcomingBookings: upcomingBookings.length,\r\n        todayBookings: todayBookings.length,\r\n        totalEarnings,\r\n        monthlyEarnings,\r\n        averageRating: Number(cleaner.rating) || 0,\r\n        reliabilityScore: Number(cleaner.reliability_score) || 0,\r\n        completionRate,\r\n        onTimeRate,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update cleaner availability\r\n */\r\nexport async function updateCleanerAvailability(\r\n  cleanerId: string,\r\n  updates: {\r\n    isAvailable?: boolean;\r\n    availableMonday?: boolean;\r\n    availableTuesday?: boolean;\r\n    availableWednesday?: boolean;\r\n    availableThursday?: boolean;\r\n    availableFriday?: boolean;\r\n    availableSaturday?: boolean;\r\n    availableSunday?: boolean;\r\n  }\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (updates.isAvailable !== undefined) {\r\n      updateData.is_available = updates.isAvailable;\r\n    }\r\n    if (updates.availableMonday !== undefined) {\r\n      updateData.available_monday = updates.availableMonday;\r\n    }\r\n    if (updates.availableTuesday !== undefined) {\r\n      updateData.available_tuesday = updates.availableTuesday;\r\n    }\r\n    if (updates.availableWednesday !== undefined) {\r\n      updateData.available_wednesday = updates.availableWednesday;\r\n    }\r\n    if (updates.availableThursday !== undefined) {\r\n      updateData.available_thursday = updates.availableThursday;\r\n    }\r\n    if (updates.availableFriday !== undefined) {\r\n      updateData.available_friday = updates.availableFriday;\r\n    }\r\n    if (updates.availableSaturday !== undefined) {\r\n      updateData.available_saturday = updates.availableSaturday;\r\n    }\r\n    if (updates.availableSunday !== undefined) {\r\n      updateData.available_sunday = updates.availableSunday;\r\n    }\r\n\r\n    const { data: updatedCleaner, error } = await supabase\r\n      .from('cleaners')\r\n      .update(updateData)\r\n      .eq('id', cleanerId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error updating cleaner availability:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, cleaner: updatedCleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in updateCleanerAvailability:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update availability',\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAuLsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,sDAAA"}},
    {"offset": {"line": 518, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { createAdminClient } from '@/lib/supabase/server-admin';\r\nimport { Booking } from '@/types/booking';\r\nimport { Cleaner } from '@/types/booking';\r\nimport {\r\n  calculateCleanerTenure,\r\n  calculateTotalHours,\r\n  getEarningsPercentage,\r\n  calculateTotalEarningsFromBooking,\r\n  calculateCleanerEarnings,\r\n  calculateTipPerCleaner,\r\n} from '@/lib/utils/cleaner-earnings';\r\n\r\n/**\r\n * Get cleaner by phone number\r\n */\r\nexport async function getCleanerByPhone(phone: string): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    \r\n    // Normalize phone number (remove spaces, dashes, etc.)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    \r\n    const { data, error } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .or(`phone.eq.${normalizedPhone},phone.eq.+${normalizedPhone}`)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaner by phone:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!data) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: data as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerByPhone:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Authenticate cleaner with phone and password\r\n * Uses Supabase Auth - expects email format: {phone}@cleaners.shalean.local\r\n * Admin should create auth accounts with this email format when creating cleaner accounts\r\n */\r\nexport async function authenticateCleaner(\r\n  phone: string,\r\n  password: string\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // First, find the cleaner by phone to verify they exist\r\n    const cleanerResult = await getCleanerByPhone(phone);\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    const cleaner = cleanerResult.cleaner;\r\n\r\n    // Use phone-based email format for login\r\n    // Format: {phone}@cleaners.shalean.local\r\n    // Normalize phone (remove spaces, keep + if present)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    const authEmail = `${normalizedPhone}@cleaners.shalean.local`;\r\n\r\n    // Authenticate with Supabase Auth using client-side (this should be called from client)\r\n    // Note: This function should ideally be called from a client component\r\n    // For server-side, we'll return the cleaner info and let client handle auth\r\n    const supabase = await createClient();\r\n    \r\n    // Try to authenticate\r\n    const { data, error } = await supabase.auth.signInWithPassword({\r\n      email: authEmail,\r\n      password,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Authentication error:', error);\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Authentication failed' };\r\n    }\r\n\r\n    // Update cleaner's auth_user_id if not set\r\n    if (!cleaner.auth_user_id) {\r\n      try {\r\n        const adminSupabase = createAdminClient();\r\n        await adminSupabase\r\n          .from('cleaners')\r\n          .update({ auth_user_id: data.user.id })\r\n          .eq('id', cleaner.id);\r\n      } catch (updateError) {\r\n        // Log but don't fail - auth_user_id update is optional\r\n        console.warn('Could not update auth_user_id:', updateError);\r\n      }\r\n    }\r\n\r\n    return { success: true, cleaner };\r\n  } catch (error) {\r\n    console.error('Error in authenticateCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Authentication failed',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get current authenticated cleaner\r\n */\r\nexport async function getCurrentCleaner(): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    // Try to find cleaner by auth_user_id first\r\n    let cleanerQuery = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('auth_user_id', user.id)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    let { data: cleaner, error: cleanerError } = await cleanerQuery;\r\n\r\n    // If not found by auth_user_id, try to match by phone from email\r\n    if (!cleaner && !cleanerError && user.email) {\r\n      // Extract phone from email format: {phone}@cleaners.shalean.local\r\n      const phoneMatch = user.email.match(/^(.+)@cleaners\\.shalean\\.local$/);\r\n      if (phoneMatch) {\r\n        const phone = phoneMatch[1];\r\n        const phoneResult = await getCleanerByPhone(phone);\r\n        if (phoneResult.success && phoneResult.cleaner) {\r\n          cleaner = phoneResult.cleaner;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner profile not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: cleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCurrentCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get bookings assigned to the authenticated cleaner\r\n */\r\nexport async function getCleanerBookings(\r\n  filter?: 'all' | 'today' | 'upcoming' | 'past' | 'on_my_way' | 'started'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n    \r\n    // Fetch bookings where cleaner is assigned via preferred_cleaner_id (single)\r\n    let singleQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter\r\n    let arrayQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Apply filters to both queries\r\n    if (filter && filter !== 'all') {\r\n      const today = new Date().toISOString().split('T')[0];\r\n      \r\n      switch (filter) {\r\n        case 'today':\r\n          singleQuery = singleQuery.eq('service_date', today);\r\n          arrayQuery = arrayQuery.eq('service_date', today);\r\n          break;\r\n        case 'upcoming':\r\n          singleQuery = singleQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          arrayQuery = arrayQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          break;\r\n        case 'past':\r\n          singleQuery = singleQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          arrayQuery = arrayQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          break;\r\n        case 'on_my_way':\r\n          singleQuery = singleQuery.eq('status', 'on_my_way');\r\n          arrayQuery = arrayQuery.eq('status', 'on_my_way');\r\n          break;\r\n        case 'started':\r\n          singleQuery = singleQuery.eq('status', 'started');\r\n          arrayQuery = arrayQuery.eq('status', 'started');\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Execute both queries\r\n    const [singleResult, arrayResult] = await Promise.all([\r\n      singleQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true }),\r\n      arrayQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true })\r\n    ]);\r\n\r\n    if (singleResult.error) {\r\n      console.error('Error fetching cleaner bookings (single):', singleResult.error);\r\n      return { success: false, error: singleResult.error.message };\r\n    }\r\n\r\n    if (arrayResult.error) {\r\n      console.error('Error fetching cleaner bookings (array):', arrayResult.error);\r\n      return { success: false, error: arrayResult.error.message };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerBookings] Fetched bookings:', {\r\n      cleanerId,\r\n      filter,\r\n      singleBookingsCount: singleResult.data?.length || 0,\r\n      arrayBookingsCount: arrayResult.data?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const filteredArrayBookings = (arrayResult.data || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine results and remove duplicates\r\n    const allBookings = [\r\n      ...(singleResult.data || []),\r\n      ...filteredArrayBookings\r\n    ];\r\n\r\n    // Remove duplicates by booking ID\r\n    const uniqueBookingsMap = new Map<string, Booking>();\r\n    allBookings.forEach((booking: any) => {\r\n      if (booking.id && !uniqueBookingsMap.has(booking.id)) {\r\n        uniqueBookingsMap.set(booking.id, booking as Booking);\r\n      }\r\n    });\r\n\r\n    const bookings = Array.from(uniqueBookingsMap.values());\r\n\r\n    // Sort by service_date and service_time\r\n    bookings.sort((a, b) => {\r\n      const dateCompare = a.service_date.localeCompare(b.service_date);\r\n      if (dateCompare !== 0) return dateCompare;\r\n      return a.service_time.localeCompare(b.service_time);\r\n    });\r\n\r\n    return { success: true, bookings };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate cleaner earnings for a specific booking\r\n * This helper function is used to display earnings on booking details page\r\n */\r\nexport async function calculateBookingEarnings(bookingId: string): Promise<{\r\n  success: boolean;\r\n  earnings?: {\r\n    baseEarnings: number;\r\n    tipAmount: number;\r\n    totalEarnings: number;\r\n    earningsPercentage: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get the booking\r\n    const { data: booking, error: bookingError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (bookingError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Calculate tenure and total hours to determine percentage\r\n    // For single booking display, we need all paid completed bookings to calculate hours\r\n    // Use the same approach as getCleanerStats\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate base earnings\r\n    const baseEarnings = calculateCleanerEarnings(\r\n      {\r\n        service_type: booking.service_type || '',\r\n        total_amount: Number(booking.total_amount) || 0,\r\n        service_fee: Number(booking.service_fee) || 0,\r\n        preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n        preferred_cleaner_id: booking.preferred_cleaner_id,\r\n      },\r\n      cleanerId,\r\n      earningsPercentage,\r\n      booking.preferred_cleaner_ids\r\n    );\r\n\r\n    // Calculate tip per cleaner\r\n    const tipAmount = calculateTipPerCleaner(\r\n      Number(booking.tip_amount) || 0,\r\n      booking.preferred_cleaner_ids,\r\n      booking.preferred_cleaner_id\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      earnings: {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n        earningsPercentage,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error calculating booking earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get a specific booking by ID (only if assigned to authenticated cleaner)\r\n */\r\nexport async function getCleanerBookingById(\r\n  bookingId: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Fetch the booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError) {\r\n      console.error('Error fetching booking:', fetchError);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    if (!booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Verify the cleaner is assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    // Check single cleaner assignment\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    // Check multiple cleaner assignment\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    if (!isAssignedSingle && !isAssignedMultiple) {\r\n      return { \r\n        success: false, \r\n        error: 'Unauthorized: You are not assigned to this booking' \r\n      };\r\n    }\r\n\r\n    return { success: true, booking: booking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookingById:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch booking',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update booking status (with authorization check for authenticated cleaner)\r\n */\r\nexport async function updateBookingStatus(\r\n  bookingId: string,\r\n  status: Booking['status']\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // First, verify the cleaner is assigned to this booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Validate status transition\r\n    const validTransitions: Record<string, string[]> = {\r\n      'pending': ['confirmed', 'cancelled'],\r\n      'confirmed': ['on_my_way', 'cancelled'],\r\n      'on_my_way': ['started', 'cancelled'],\r\n      'started': ['completed', 'cancelled'],\r\n      'completed': [],\r\n      'cancelled': [],\r\n    };\r\n\r\n    const currentStatus = booking.status;\r\n    const allowedStatuses = validTransitions[currentStatus] || [];\r\n    \r\n    if (!allowedStatuses.includes(status) && status !== currentStatus) {\r\n      return { \r\n        success: false, \r\n        error: `Invalid status transition: cannot change from ${currentStatus} to ${status}` \r\n      };\r\n    }\r\n\r\n    // Update booking status\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({ \r\n        status,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating booking status:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in updateBookingStatus:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update booking status',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Report lateness for a booking (with authorization check for authenticated cleaner)\r\n */\r\nexport async function reportLateness(\r\n  bookingId: string,\r\n  expectedArrivalTime: string, // ISO timestamp\r\n  reason: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Verify authorization\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Update booking with lateness information\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        expected_arrival_time: expectedArrivalTime,\r\n        lateness_reason: reason,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error reporting lateness:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in reportLateness:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to report lateness',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate earnings for multiple bookings at once\r\n * This is more efficient than calculating earnings one booking at a time\r\n */\r\nexport async function calculateBookingsEarnings(bookingIds: string[]): Promise<{\r\n  success: boolean;\r\n  earnings?: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }>;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    if (bookingIds.length === 0) {\r\n      return { success: true, earnings: {} };\r\n    }\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (bookingsError || !bookings) {\r\n      return { success: false, error: 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Get all cleaner bookings to calculate hours\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    // Calculate tenure and hours\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings for each booking\r\n    const earningsRecord: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }> = {};\r\n\r\n    for (const booking of bookings) {\r\n      const baseEarnings = calculateCleanerEarnings(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage,\r\n        booking.preferred_cleaner_ids\r\n      );\r\n\r\n      const tipAmount = calculateTipPerCleaner(\r\n        Number(booking.tip_amount) || 0,\r\n        booking.preferred_cleaner_ids,\r\n        booking.preferred_cleaner_id\r\n      );\r\n\r\n      earningsRecord[booking.id] = {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n      };\r\n    }\r\n\r\n    return { success: true, earnings: earningsRecord };\r\n  } catch (error) {\r\n    console.error('Error calculating bookings earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get cleaner statistics for the authenticated cleaner\r\n */\r\nexport async function getCleanerStats(): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalBookings: number;\r\n    completedBookings: number;\r\n    upcomingBookings: number;\r\n    todayBookings: number;\r\n    totalEarnings: number;\r\n    monthlyEarnings: number;\r\n    averageRating: number;\r\n    reliabilityScore: number;\r\n    completionRate: number;\r\n    onTimeRate: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info including created_at for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('rating, reliability_score, total_bookings, completed_bookings, on_time_bookings, created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings assigned to this cleaner\r\n    // Fetch bookings with preferred_cleaner_id (single) - include all fields needed for earnings calculation\r\n    const { data: singleBookings, error: singleError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter in JS\r\n    const { data: allMultiBookings, error: multiError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_ids, preferred_cleaner_id')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    if (singleError || multiError) {\r\n      console.error('Error fetching bookings for stats:', singleError || multiError);\r\n      return { success: false, error: (singleError || multiError)?.message || 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerStats] Fetched bookings:', {\r\n      cleanerId,\r\n      singleBookingsCount: singleBookings?.length || 0,\r\n      allMultiBookingsCount: allMultiBookings?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const arrayBookings = (allMultiBookings || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates by ID\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((booking: any) => {\r\n      if (booking.id) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    arrayBookings.forEach((booking: any) => {\r\n      if (booking.id && !allBookingsMap.has(booking.id)) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    \r\n    const allBookings = Array.from(allBookingsMap.values());\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n    const now = new Date();\r\n    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];\r\n    const completedBookings = allBookings.filter(b => b.status === 'completed');\r\n    const upcomingBookings = allBookings.filter(b => \r\n      ['pending', 'confirmed', 'on_my_way', 'started'].includes(b.status) &&\r\n      b.service_date >= today\r\n    );\r\n    const todayBookings = allBookings.filter(b => b.service_date === today);\r\n    const paidBookings = allBookings.filter(b => b.payment_status === 'paid');\r\n    const monthlyPaidBookings = paidBookings.filter(b => b.service_date >= firstDayOfMonth);\r\n\r\n    // Calculate cleaner tenure and total hours for eligibility determination\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(allBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings using the new system\r\n    // Only calculate earnings for paid bookings (earnings are only paid when customer has paid)\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const totalEarnings = paidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const monthlyEarnings = monthlyPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const completionRate = cleaner.total_bookings \r\n      ? (cleaner.completed_bookings || 0) / cleaner.total_bookings * 100 \r\n      : 0;\r\n    \r\n    const onTimeRate = cleaner.completed_bookings\r\n      ? (cleaner.on_time_bookings || 0) / cleaner.completed_bookings * 100\r\n      : 0;\r\n\r\n    return {\r\n      success: true,\r\n      stats: {\r\n        totalBookings: allBookings.length,\r\n        completedBookings: completedBookings.length,\r\n        upcomingBookings: upcomingBookings.length,\r\n        todayBookings: todayBookings.length,\r\n        totalEarnings,\r\n        monthlyEarnings,\r\n        averageRating: Number(cleaner.rating) || 0,\r\n        reliabilityScore: Number(cleaner.reliability_score) || 0,\r\n        completionRate,\r\n        onTimeRate,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update cleaner availability\r\n */\r\nexport async function updateCleanerAvailability(\r\n  cleanerId: string,\r\n  updates: {\r\n    isAvailable?: boolean;\r\n    availableMonday?: boolean;\r\n    availableTuesday?: boolean;\r\n    availableWednesday?: boolean;\r\n    availableThursday?: boolean;\r\n    availableFriday?: boolean;\r\n    availableSaturday?: boolean;\r\n    availableSunday?: boolean;\r\n  }\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (updates.isAvailable !== undefined) {\r\n      updateData.is_available = updates.isAvailable;\r\n    }\r\n    if (updates.availableMonday !== undefined) {\r\n      updateData.available_monday = updates.availableMonday;\r\n    }\r\n    if (updates.availableTuesday !== undefined) {\r\n      updateData.available_tuesday = updates.availableTuesday;\r\n    }\r\n    if (updates.availableWednesday !== undefined) {\r\n      updateData.available_wednesday = updates.availableWednesday;\r\n    }\r\n    if (updates.availableThursday !== undefined) {\r\n      updateData.available_thursday = updates.availableThursday;\r\n    }\r\n    if (updates.availableFriday !== undefined) {\r\n      updateData.available_friday = updates.availableFriday;\r\n    }\r\n    if (updates.availableSaturday !== undefined) {\r\n      updateData.available_saturday = updates.availableSaturday;\r\n    }\r\n    if (updates.availableSunday !== undefined) {\r\n      updateData.available_sunday = updates.availableSunday;\r\n    }\r\n\r\n    const { data: updatedCleaner, error } = await supabase\r\n      .from('cleaners')\r\n      .update(updateData)\r\n      .eq('id', cleanerId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error updating cleaner availability:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, cleaner: updatedCleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in updateCleanerAvailability:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update availability',\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA2sBsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 532, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/tabs.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Tabs = TabsPrimitive.Root;\r\n\r\nconst TabsList = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.List>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.List\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\r\n      className,\r\n    )}\r\n    {...props}\r\n  />\r\n));\r\nTabsList.displayName = TabsPrimitive.List.displayName;\r\n\r\nconst TabsTrigger = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Trigger\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\r\n      className,\r\n    )}\r\n    {...props}\r\n  />\r\n));\r\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName;\r\n\r\nconst TabsContent = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Content\r\n    ref={ref}\r\n    className={cn(\r\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\r\n      className,\r\n    )}\r\n    {...props}\r\n  />\r\n));\r\nTabsContent.displayName = TabsPrimitive.Content.displayName;\r\n\r\nexport { Tabs, TabsList, TabsTrigger, TabsContent };\r\n"],"names":[],"mappings":";;;;;;;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,OAAO,wKAAkB;AAE/B,MAAM,yBAAW,mNAAgB,CAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,wKAAkB;QACjB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,8FACA;QAED,GAAG,KAAK;;;;;;AAGb,SAAS,WAAW,GAAG,wKAAkB,CAAC,WAAW;AAErD,MAAM,4BAAc,mNAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,2KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,uYACA;QAED,GAAG,KAAK;;;;;;AAGb,YAAY,WAAW,GAAG,2KAAqB,CAAC,WAAW;AAE3D,MAAM,4BAAc,mNAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,2KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,mIACA;QAED,GAAG,KAAK;;;;;;AAGb,YAAY,WAAW,GAAG,2KAAqB,CAAC,WAAW"}},
    {"offset": {"line": 586, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/%28dashboard%29/bookings/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useEffect, useState } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { CleanerBookingCard } from '../../components/CleanerBookingCard';\r\nimport { getCleanerBookings, getCurrentCleaner, calculateBookingsEarnings } from '../../actions';\r\nimport { Booking } from '@/types/booking';\r\nimport { Cleaner } from '@/types/booking';\r\nimport { Loader2 } from 'lucide-react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\r\n\r\nexport default function CleanerBookingsPage() {\r\n  const [bookings, setBookings] = useState<Booking[]>([]);\r\n  const [loading, setLoading] = useState(false);\r\n  const [filter, setFilter] = useState<'all' | 'today' | 'upcoming' | 'past' | 'on_my_way' | 'started'>('today');\r\n  const [cleaner, setCleaner] = useState<Cleaner | null>(null);\r\n  const [bookingsEarnings, setBookingsEarnings] = useState<Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }>>({});\r\n\r\n  // Get current cleaner\r\n  useQuery({\r\n    queryKey: ['current-cleaner'],\r\n    queryFn: async () => {\r\n      const result = await getCurrentCleaner();\r\n      if (result.success && result.cleaner) {\r\n        setCleaner(result.cleaner);\r\n        return result.cleaner;\r\n      }\r\n      return null;\r\n    },\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  const loadBookings = async () => {\r\n    try {\r\n      setLoading(true);\r\n      const result = await getCleanerBookings(filter);\r\n      if (result.success && result.bookings) {\r\n        setBookings(result.bookings);\r\n        \r\n        // Calculate earnings for all bookings\r\n        const bookingIds = (result.bookings || []).map(b => b.id);\r\n        if (bookingIds.length > 0) {\r\n          const earningsResult = await calculateBookingsEarnings(bookingIds);\r\n          if (earningsResult.success && earningsResult.earnings) {\r\n            setBookingsEarnings(earningsResult.earnings);\r\n          }\r\n        }\r\n      } else if (result.error) {\r\n        console.error('Error loading bookings:', result.error);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading bookings:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Ensure filter is always a visible option\r\n  useEffect(() => {\r\n    if (filter === 'all' || filter === 'on_my_way' || filter === 'started') {\r\n      setFilter('today');\r\n    }\r\n  }, [filter]);\r\n\r\n  // Load bookings when cleaner is available or filter changes\r\n  useEffect(() => {\r\n    if (cleaner?.id) {\r\n      loadBookings();\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [cleaner?.id, filter]);\r\n\r\n  return (\r\n    <div className=\"space-y-4 sm:space-y-6 w-full max-w-full overflow-x-hidden\">\r\n      {/* Page Header */}\r\n      <div>\r\n        <h1 className=\"text-2xl sm:text-3xl md:text-4xl font-bold\">My Bookings</h1>\r\n        <p className=\"text-base sm:text-lg text-muted-foreground mt-1\">\r\n          View and manage all your assigned bookings\r\n        </p>\r\n      </div>\r\n\r\n      {/* Filters */}\r\n      {cleaner && (\r\n        <Tabs value={filter} onValueChange={(value) => setFilter(value as typeof filter)} className=\"w-full\">\r\n          <TabsList className=\"grid w-full grid-cols-3\">\r\n            <TabsTrigger value=\"today\">Today</TabsTrigger>\r\n            <TabsTrigger value=\"upcoming\">Upcoming</TabsTrigger>\r\n            <TabsTrigger value=\"past\">Past</TabsTrigger>\r\n          </TabsList>\r\n        </Tabs>\r\n      )}\r\n\r\n      {/* Bookings List */}\r\n      {!cleaner ? (\r\n        <div className=\"flex items-center justify-center py-8 sm:py-12\">\r\n          <Loader2 className=\"w-6 h-6 sm:w-8 sm:h-8 animate-spin text-primary\" />\r\n        </div>\r\n      ) : loading ? (\r\n        <div className=\"flex items-center justify-center py-8 sm:py-12\">\r\n          <Loader2 className=\"w-6 h-6 sm:w-8 sm:h-8 animate-spin text-primary\" />\r\n        </div>\r\n      ) : bookings.length === 0 ? (\r\n        <Card className=\"w-full max-w-full overflow-hidden\">\r\n          <CardHeader className=\"px-4 py-4 sm:px-6 sm:py-6\">\r\n            <CardTitle className=\"text-lg sm:text-xl\">No Bookings Found</CardTitle>\r\n            <CardDescription className=\"text-sm mt-1\">\r\n              {`You don't have any ${filter.replace('_', ' ')} bookings.`}\r\n            </CardDescription>\r\n          </CardHeader>\r\n        </Card>\r\n      ) : (\r\n        <div className=\"grid gap-3 sm:gap-4\">\r\n          {bookings.map((booking) => (\r\n            <CleanerBookingCard \r\n              key={booking.id} \r\n              booking={booking} \r\n              earnings={bookingsEarnings[booking.id]?.totalEarnings}\r\n            />\r\n          ))}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n"],"names":[],"mappings":"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"}}]
}