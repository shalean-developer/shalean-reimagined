{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst buttonVariants = cva(\r\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-lg text-sm font-semibold ring-offset-background transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90 shadow-button hover:shadow-lg hover:-translate-y-0.5\",\r\n        destructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\r\n        outline: \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\r\n        secondary: \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\r\n        link: \"text-primary underline-offset-4 hover:underline\",\r\n        hero: \"bg-primary text-primary-foreground shadow-button hover:shadow-lg hover:-translate-y-0.5 hover:bg-primary/90\",\r\n        heroOutline: \"border-2 border-primary bg-transparent text-primary hover:bg-primary hover:text-primary-foreground\",\r\n        cta: \"bg-primary text-primary-foreground shadow-button hover:shadow-lg hover:-translate-y-1 hover:bg-primary/90\",\r\n      },\r\n      size: {\r\n        default: \"h-10 px-4 py-2\",\r\n        sm: \"h-9 rounded-md px-3\",\r\n        lg: \"h-12 rounded-lg px-6\",\r\n        xl: \"h-14 rounded-xl px-8 text-base\",\r\n        icon: \"h-10 w-10\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n      size: \"default\",\r\n    },\r\n  },\r\n);\r\n\r\nexport interface ButtonProps\r\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\r\n    VariantProps<typeof buttonVariants> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\r\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\r\n    const Comp = asChild ? Slot : \"button\";\r\n    return <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />;\r\n  },\r\n);\r\nButton.displayName = \"Button\";\r\n\r\nexport { Button, buttonVariants };\r\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,iBAAiB,IAAA,uKAAG,EACxB,wWACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aAAa;YACb,SAAS;YACT,WAAW;YACX,OAAO;YACP,MAAM;YACN,MAAM;YACN,aAAa;YACb,KAAK;QACP;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,MAAM;QACR;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AASF,MAAM,uBAAS,mNAAgB,CAC7B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,KAAK,EAAE,GAAG,OAAO,EAAE;IACxD,MAAM,OAAO,UAAU,wKAAI,GAAG;IAC9B,qBAAO,8OAAC;QAAK,WAAW,IAAA,yHAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QAAK,KAAK;QAAM,GAAG,KAAK;;;;;;AAC/F;AAEF,OAAO,WAAW,GAAG"}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\r\n  ({ className, type, ...props }, ref) => {\r\n    return (\r\n      <input\r\n        type={type}\r\n        className={cn(\r\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\r\n          className,\r\n        )}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    );\r\n  },\r\n);\r\nInput.displayName = \"Input\";\r\n\r\nexport { Input };\r\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,mNAAgB,CAC5B,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAO,EAAE;IAC9B,qBACE,8OAAC;QACC,MAAM;QACN,WAAW,IAAA,yHAAE,EACX,kYACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;AAEF,MAAM,WAAW,GAAG"}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/label.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as LabelPrimitive from \"@radix-ui/react-label\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst labelVariants = cva(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\");\r\n\r\nconst Label = React.forwardRef<\r\n  React.ElementRef<typeof LabelPrimitive.Root>,\r\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>\r\n>(({ className, ...props }, ref) => (\r\n  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />\r\n));\r\nLabel.displayName = LabelPrimitive.Root.displayName;\r\n\r\nexport { Label };\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,gBAAgB,IAAA,uKAAG,EAAC;AAE1B,MAAM,sBAAQ,mNAAgB,CAG5B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,yKAAmB;QAAC,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,iBAAiB;QAAa,GAAG,KAAK;;;;;;AAErF,MAAM,WAAW,GAAG,yKAAmB,CAAC,WAAW"}},
    {"offset": {"line": 126, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/textarea.tsx"],"sourcesContent":["import * as React from \"react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nexport interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\r\n\r\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(({ className, ...props }, ref) => {\r\n  return (\r\n    <textarea\r\n      className={cn(\r\n        \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n        className,\r\n      )}\r\n      ref={ref}\r\n      {...props}\r\n    />\r\n  );\r\n});\r\nTextarea.displayName = \"Textarea\";\r\n\r\nexport { Textarea };\r\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAIA,MAAM,yBAAW,mNAAgB,CAAqC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE;IAC9F,qBACE,8OAAC;QACC,WAAW,IAAA,yHAAE,EACX,wSACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;AACA,SAAS,WAAW,GAAG"}},
    {"offset": {"line": 153, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/select.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as SelectPrimitive from \"@radix-ui/react-select\";\r\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Select = SelectPrimitive.Root;\r\n\r\nconst SelectGroup = SelectPrimitive.Group;\r\n\r\nconst SelectValue = SelectPrimitive.Value;\r\n\r\nconst SelectTrigger = React.forwardRef<\r\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\r\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\r\n>(({ className, children, ...props }, ref) => (\r\n  <SelectPrimitive.Trigger\r\n    ref={ref}\r\n    className={cn(\r\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\r\n      className,\r\n    )}\r\n    {...props}\r\n  >\r\n    {children}\r\n    <SelectPrimitive.Icon asChild>\r\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\r\n    </SelectPrimitive.Icon>\r\n  </SelectPrimitive.Trigger>\r\n));\r\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName;\r\n\r\nconst SelectScrollUpButton = React.forwardRef<\r\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\r\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\r\n>(({ className, ...props }, ref) => (\r\n  <SelectPrimitive.ScrollUpButton\r\n    ref={ref}\r\n    className={cn(\"flex cursor-default items-center justify-center py-1\", className)}\r\n    {...props}\r\n  >\r\n    <ChevronUp className=\"h-4 w-4\" />\r\n  </SelectPrimitive.ScrollUpButton>\r\n));\r\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;\r\n\r\nconst SelectScrollDownButton = React.forwardRef<\r\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\r\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\r\n>(({ className, ...props }, ref) => (\r\n  <SelectPrimitive.ScrollDownButton\r\n    ref={ref}\r\n    className={cn(\"flex cursor-default items-center justify-center py-1\", className)}\r\n    {...props}\r\n  >\r\n    <ChevronDown className=\"h-4 w-4\" />\r\n  </SelectPrimitive.ScrollDownButton>\r\n));\r\nSelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName;\r\n\r\nconst SelectContent = React.forwardRef<\r\n  React.ElementRef<typeof SelectPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\r\n>(({ className, children, position = \"popper\", ...props }, ref) => (\r\n  <SelectPrimitive.Portal>\r\n    <SelectPrimitive.Content\r\n      ref={ref}\r\n      className={cn(\r\n        \"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\r\n        position === \"popper\" &&\r\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\r\n        className,\r\n      )}\r\n      position={position}\r\n      {...props}\r\n    >\r\n      <SelectScrollUpButton />\r\n      <SelectPrimitive.Viewport\r\n        className={cn(\r\n          \"p-1\",\r\n          position === \"popper\" &&\r\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\",\r\n        )}\r\n      >\r\n        {children}\r\n      </SelectPrimitive.Viewport>\r\n      <SelectScrollDownButton />\r\n    </SelectPrimitive.Content>\r\n  </SelectPrimitive.Portal>\r\n));\r\nSelectContent.displayName = SelectPrimitive.Content.displayName;\r\n\r\nconst SelectLabel = React.forwardRef<\r\n  React.ElementRef<typeof SelectPrimitive.Label>,\r\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\r\n>(({ className, ...props }, ref) => (\r\n  <SelectPrimitive.Label ref={ref} className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)} {...props} />\r\n));\r\nSelectLabel.displayName = SelectPrimitive.Label.displayName;\r\n\r\nconst SelectItem = React.forwardRef<\r\n  React.ElementRef<typeof SelectPrimitive.Item>,\r\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\r\n>(({ className, children, ...props }, ref) => (\r\n  <SelectPrimitive.Item\r\n    ref={ref}\r\n    className={cn(\r\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground\",\r\n      className,\r\n    )}\r\n    {...props}\r\n  >\r\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\r\n      <SelectPrimitive.ItemIndicator>\r\n        <Check className=\"h-4 w-4\" />\r\n      </SelectPrimitive.ItemIndicator>\r\n    </span>\r\n\r\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\r\n  </SelectPrimitive.Item>\r\n));\r\nSelectItem.displayName = SelectPrimitive.Item.displayName;\r\n\r\nconst SelectSeparator = React.forwardRef<\r\n  React.ElementRef<typeof SelectPrimitive.Separator>,\r\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\r\n>(({ className, ...props }, ref) => (\r\n  <SelectPrimitive.Separator ref={ref} className={cn(\"-mx-1 my-1 h-px bg-muted\", className)} {...props} />\r\n));\r\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName;\r\n\r\nexport {\r\n  Select,\r\n  SelectGroup,\r\n  SelectValue,\r\n  SelectTrigger,\r\n  SelectContent,\r\n  SelectLabel,\r\n  SelectItem,\r\n  SelectSeparator,\r\n  SelectScrollUpButton,\r\n  SelectScrollDownButton,\r\n};\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAAA;AAAA;AAEA;;;;;;AAEA,MAAM,SAAS,0KAAoB;AAEnC,MAAM,cAAc,2KAAqB;AAEzC,MAAM,cAAc,2KAAqB;AAEzC,MAAM,8BAAgB,mNAAgB,CAGpC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,8OAAC,6KAAuB;QACtB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,mTACA;QAED,GAAG,KAAK;;YAER;0BACD,8OAAC,0KAAoB;gBAAC,OAAO;0BAC3B,cAAA,8OAAC,mOAAW;oBAAC,WAAU;;;;;;;;;;;;;;;;;AAI7B,cAAc,WAAW,GAAG,6KAAuB,CAAC,WAAW;AAE/D,MAAM,qCAAuB,mNAAgB,CAG3C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,oLAA8B;QAC7B,KAAK;QACL,WAAW,IAAA,yHAAE,EAAC,wDAAwD;QACrE,GAAG,KAAK;kBAET,cAAA,8OAAC,6NAAS;YAAC,WAAU;;;;;;;;;;;AAGzB,qBAAqB,WAAW,GAAG,oLAA8B,CAAC,WAAW;AAE7E,MAAM,uCAAyB,mNAAgB,CAG7C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,sLAAgC;QAC/B,KAAK;QACL,WAAW,IAAA,yHAAE,EAAC,wDAAwD;QACrE,GAAG,KAAK;kBAET,cAAA,8OAAC,mOAAW;YAAC,WAAU;;;;;;;;;;;AAG3B,uBAAuB,WAAW,GAAG,sLAAgC,CAAC,WAAW;AAEjF,MAAM,8BAAgB,mNAAgB,CAGpC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,WAAW,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACzD,8OAAC,4KAAsB;kBACrB,cAAA,8OAAC,6KAAuB;YACtB,KAAK;YACL,WAAW,IAAA,yHAAE,EACX,ucACA,aAAa,YACX,mIACF;YAEF,UAAU;YACT,GAAG,KAAK;;8BAET,8OAAC;;;;;8BACD,8OAAC,8KAAwB;oBACvB,WAAW,IAAA,yHAAE,EACX,OACA,aAAa,YACX;8BAGH;;;;;;8BAEH,8OAAC;;;;;;;;;;;;;;;;AAIP,cAAc,WAAW,GAAG,6KAAuB,CAAC,WAAW;AAE/D,MAAM,4BAAc,mNAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,2KAAqB;QAAC,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,0CAA0C;QAAa,GAAG,KAAK;;;;;;AAEhH,YAAY,WAAW,GAAG,2KAAqB,CAAC,WAAW;AAE3D,MAAM,2BAAa,mNAAgB,CAGjC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,8OAAC,0KAAoB;QACnB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,6NACA;QAED,GAAG,KAAK;;0BAET,8OAAC;gBAAK,WAAU;0BACd,cAAA,8OAAC,mLAA6B;8BAC5B,cAAA,8OAAC,6MAAK;wBAAC,WAAU;;;;;;;;;;;;;;;;0BAIrB,8OAAC,8KAAwB;0BAAE;;;;;;;;;;;;AAG/B,WAAW,WAAW,GAAG,0KAAoB,CAAC,WAAW;AAEzD,MAAM,gCAAkB,mNAAgB,CAGtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,+KAAyB;QAAC,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,4BAA4B;QAAa,GAAG,KAAK;;;;;;AAEtG,gBAAgB,WAAW,GAAG,+KAAyB,CAAC,WAAW"}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/checkbox.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\";\r\nimport { Check } from \"lucide-react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Checkbox = React.forwardRef<\r\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\r\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\r\n>(({ className, ...props }, ref) => (\r\n  <CheckboxPrimitive.Root\r\n    ref={ref}\r\n    className={cn(\r\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n      className,\r\n    )}\r\n    {...props}\r\n  >\r\n    <CheckboxPrimitive.Indicator className={cn(\"flex items-center justify-center text-current\")}>\r\n      <Check className=\"h-4 w-4\" />\r\n    </CheckboxPrimitive.Indicator>\r\n  </CheckboxPrimitive.Root>\r\n));\r\nCheckbox.displayName = CheckboxPrimitive.Root.displayName;\r\n\r\nexport { Checkbox };\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,yBAAW,mNAAgB,CAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,4KAAsB;QACrB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,kTACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,iLAA2B;YAAC,WAAW,IAAA,yHAAE,EAAC;sBACzC,cAAA,8OAAC,6MAAK;gBAAC,WAAU;;;;;;;;;;;;;;;;AAIvB,SAAS,WAAW,GAAG,4KAAsB,CAAC,WAAW"}},
    {"offset": {"line": 395, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/radio-group.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as RadioGroupPrimitive from \"@radix-ui/react-radio-group\";\r\nimport { Circle } from \"lucide-react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst RadioGroup = React.forwardRef<\r\n  React.ElementRef<typeof RadioGroupPrimitive.Root>,\r\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>\r\n>(({ className, ...props }, ref) => {\r\n  return <RadioGroupPrimitive.Root className={cn(\"grid gap-2\", className)} {...props} ref={ref} />;\r\n});\r\nRadioGroup.displayName = RadioGroupPrimitive.Root.displayName;\r\n\r\nconst RadioGroupItem = React.forwardRef<\r\n  React.ElementRef<typeof RadioGroupPrimitive.Item>,\r\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>\r\n>(({ className, ...props }, ref) => {\r\n  return (\r\n    <RadioGroupPrimitive.Item\r\n      ref={ref}\r\n      className={cn(\r\n        \"aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n        className,\r\n      )}\r\n      {...props}\r\n    >\r\n      <RadioGroupPrimitive.Indicator className=\"flex items-center justify-center\">\r\n        <Circle className=\"h-2.5 w-2.5 fill-current text-current\" />\r\n      </RadioGroupPrimitive.Indicator>\r\n    </RadioGroupPrimitive.Item>\r\n  );\r\n});\r\nRadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;\r\n\r\nexport { RadioGroup, RadioGroupItem };\r\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,2BAAa,mNAAgB,CAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE;IAC1B,qBAAO,8OAAC,kLAAwB;QAAC,WAAW,IAAA,yHAAE,EAAC,cAAc;QAAa,GAAG,KAAK;QAAE,KAAK;;;;;;AAC3F;AACA,WAAW,WAAW,GAAG,kLAAwB,CAAC,WAAW;AAE7D,MAAM,+BAAiB,mNAAgB,CAGrC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE;IAC1B,qBACE,8OAAC,kLAAwB;QACvB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,4OACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,uLAA6B;YAAC,WAAU;sBACvC,cAAA,8OAAC,gNAAM;gBAAC,WAAU;;;;;;;;;;;;;;;;AAI1B;AACA,eAAe,WAAW,GAAG,kLAAwB,CAAC,WAAW"}},
    {"offset": {"line": 454, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/popover.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Popover = PopoverPrimitive.Root;\r\n\r\nconst PopoverTrigger = PopoverPrimitive.Trigger;\r\n\r\nconst PopoverContent = React.forwardRef<\r\n  React.ElementRef<typeof PopoverPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\r\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\r\n  <PopoverPrimitive.Portal>\r\n    <PopoverPrimitive.Content\r\n      ref={ref}\r\n      align={align}\r\n      sideOffset={sideOffset}\r\n      className={cn(\r\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  </PopoverPrimitive.Portal>\r\n));\r\nPopoverContent.displayName = PopoverPrimitive.Content.displayName;\r\n\r\nexport { Popover, PopoverTrigger, PopoverContent };\r\n"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,UAAU,2KAAqB;AAErC,MAAM,iBAAiB,8KAAwB;AAE/C,MAAM,+BAAiB,mNAAgB,CAGrC,CAAC,EAAE,SAAS,EAAE,QAAQ,QAAQ,EAAE,aAAa,CAAC,EAAE,GAAG,OAAO,EAAE,oBAC5D,8OAAC,6KAAuB;kBACtB,cAAA,8OAAC,8KAAwB;YACvB,KAAK;YACL,OAAO;YACP,YAAY;YACZ,WAAW,IAAA,yHAAE,EACX,8aACA;YAED,GAAG,KAAK;;;;;;;;;;;AAIf,eAAe,WAAW,GAAG,8KAAwB,CAAC,WAAW"}},
    {"offset": {"line": 495, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/calendar.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport { ChevronLeft, ChevronRight } from \"lucide-react\";\r\nimport { DayPicker } from \"react-day-picker\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\nimport { buttonVariants } from \"@/components/ui/button\";\r\n\r\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>;\r\n\r\nfunction Calendar({ className, classNames, showOutsideDays = true, ...props }: CalendarProps) {\r\n  return (\r\n    <DayPicker\r\n      showOutsideDays={showOutsideDays}\r\n      className={cn(\"p-3\", className)}\r\n      classNames={{\r\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\r\n        month: \"space-y-4\",\r\n        caption: \"flex justify-center pt-1 relative items-center mb-4\",\r\n        caption_label: \"text-sm font-medium\",\r\n        nav: \"space-x-1 flex items-center\",\r\n        nav_button: cn(\r\n          buttonVariants({ variant: \"outline\" }),\r\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\",\r\n        ),\r\n        nav_button_previous: \"absolute left-1\",\r\n        nav_button_next: \"absolute right-1\",\r\n        table: \"w-full border-collapse space-y-1\",\r\n        head_row: \"flex w-full mt-2\",\r\n        head_cell: \"h-9 w-9 text-muted-foreground rounded-md font-normal text-[0.8rem] text-center p-0\",\r\n        row: \"flex w-full mt-2\",\r\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\r\n        day: cn(buttonVariants({ variant: \"ghost\" }), \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"),\r\n        day_range_end: \"day-range-end\",\r\n        day_selected:\r\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\r\n        day_today: \"bg-accent text-accent-foreground\",\r\n        day_outside:\r\n          \"day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30\",\r\n        day_disabled: \"text-muted-foreground opacity-50\",\r\n        day_range_middle: \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\r\n        day_hidden: \"invisible\",\r\n        ...classNames,\r\n      }}\r\n      components={{\r\n        IconLeft: () => <ChevronLeft className=\"h-4 w-4\" />,\r\n        IconRight: () => <ChevronRight className=\"h-4 w-4\" />,\r\n      }}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\nCalendar.displayName = \"Calendar\";\r\n\r\nexport { Calendar };\r\n"],"names":[],"mappings":";;;;;AACA;AAAA;AACA;AAEA;AACA;;;;;;AAIA,SAAS,SAAS,EAAE,SAAS,EAAE,UAAU,EAAE,kBAAkB,IAAI,EAAE,GAAG,OAAsB;IAC1F,qBACE,8OAAC,2KAAS;QACR,iBAAiB;QACjB,WAAW,IAAA,yHAAE,EAAC,OAAO;QACrB,YAAY;YACV,QAAQ;YACR,OAAO;YACP,SAAS;YACT,eAAe;YACf,KAAK;YACL,YAAY,IAAA,yHAAE,EACZ,IAAA,oJAAc,EAAC;gBAAE,SAAS;YAAU,IACpC;YAEF,qBAAqB;YACrB,iBAAiB;YACjB,OAAO;YACP,UAAU;YACV,WAAW;YACX,KAAK;YACL,MAAM;YACN,KAAK,IAAA,yHAAE,EAAC,IAAA,oJAAc,EAAC;gBAAE,SAAS;YAAQ,IAAI;YAC9C,eAAe;YACf,cACE;YACF,WAAW;YACX,aACE;YACF,cAAc;YACd,kBAAkB;YAClB,YAAY;YACZ,GAAG,UAAU;QACf;QACA,YAAY;YACV,UAAU,kBAAM,8OAAC,mOAAW;oBAAC,WAAU;;;;;;YACvC,WAAW,kBAAM,8OAAC,sOAAY;oBAAC,WAAU;;;;;;QAC3C;QACC,GAAG,KAAK;;;;;;AAGf;AACA,SAAS,WAAW,GAAG"}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/dialog.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\";\r\nimport { X } from \"lucide-react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Dialog = DialogPrimitive.Root;\r\n\r\nconst DialogTrigger = DialogPrimitive.Trigger;\r\n\r\nconst DialogPortal = DialogPrimitive.Portal;\r\n\r\nconst DialogClose = DialogPrimitive.Close;\r\n\r\nconst DialogOverlay = React.forwardRef<\r\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\r\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\r\n>(({ className, ...props }, ref) => (\r\n  <DialogPrimitive.Overlay\r\n    ref={ref}\r\n    className={cn(\r\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\r\n      className,\r\n    )}\r\n    {...props}\r\n  />\r\n));\r\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName;\r\n\r\nconst DialogContent = React.forwardRef<\r\n  React.ElementRef<typeof DialogPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\r\n>(({ className, children, ...props }, ref) => (\r\n  <DialogPortal>\r\n    <DialogOverlay />\r\n    <DialogPrimitive.Content\r\n      ref={ref}\r\n      className={cn(\r\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\r\n        className,\r\n      )}\r\n      {...props}\r\n    >\r\n      {children}\r\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-accent data-[state=open]:text-muted-foreground hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none\">\r\n        <X className=\"h-4 w-4\" />\r\n        <span className=\"sr-only\">Close</span>\r\n      </DialogPrimitive.Close>\r\n    </DialogPrimitive.Content>\r\n  </DialogPortal>\r\n));\r\nDialogContent.displayName = DialogPrimitive.Content.displayName;\r\n\r\nconst DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div className={cn(\"flex flex-col space-y-1.5 text-center sm:text-left\", className)} {...props} />\r\n);\r\nDialogHeader.displayName = \"DialogHeader\";\r\n\r\nconst DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div className={cn(\"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\", className)} {...props} />\r\n);\r\nDialogFooter.displayName = \"DialogFooter\";\r\n\r\nconst DialogTitle = React.forwardRef<\r\n  React.ElementRef<typeof DialogPrimitive.Title>,\r\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\r\n>(({ className, ...props }, ref) => (\r\n  <DialogPrimitive.Title\r\n    ref={ref}\r\n    className={cn(\"text-lg font-semibold leading-none tracking-tight\", className)}\r\n    {...props}\r\n  />\r\n));\r\nDialogTitle.displayName = DialogPrimitive.Title.displayName;\r\n\r\nconst DialogDescription = React.forwardRef<\r\n  React.ElementRef<typeof DialogPrimitive.Description>,\r\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\r\n>(({ className, ...props }, ref) => (\r\n  <DialogPrimitive.Description ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\r\n));\r\nDialogDescription.displayName = DialogPrimitive.Description.displayName;\r\n\r\nexport {\r\n  Dialog,\r\n  DialogPortal,\r\n  DialogOverlay,\r\n  DialogClose,\r\n  DialogTrigger,\r\n  DialogContent,\r\n  DialogHeader,\r\n  DialogFooter,\r\n  DialogTitle,\r\n  DialogDescription,\r\n};\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,SAAS,0KAAoB;AAEnC,MAAM,gBAAgB,6KAAuB;AAE7C,MAAM,eAAe,4KAAsB;AAE3C,MAAM,cAAc,2KAAqB;AAEzC,MAAM,8BAAgB,mNAAgB,CAGpC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,6KAAuB;QACtB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,0JACA;QAED,GAAG,KAAK;;;;;;AAGb,cAAc,WAAW,GAAG,6KAAuB,CAAC,WAAW;AAE/D,MAAM,8BAAgB,mNAAgB,CAGpC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,8OAAC;;0BACC,8OAAC;;;;;0BACD,8OAAC,6KAAuB;gBACtB,KAAK;gBACL,WAAW,IAAA,yHAAE,EACX,+fACA;gBAED,GAAG,KAAK;;oBAER;kCACD,8OAAC,2KAAqB;wBAAC,WAAU;;0CAC/B,8OAAC,iMAAC;gCAAC,WAAU;;;;;;0CACb,8OAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;AAKlC,cAAc,WAAW,GAAG,6KAAuB,CAAC,WAAW;AAE/D,MAAM,eAAe,CAAC,EAAE,SAAS,EAAE,GAAG,OAA6C,iBACjF,8OAAC;QAAI,WAAW,IAAA,yHAAE,EAAC,sDAAsD;QAAa,GAAG,KAAK;;;;;;AAEhG,aAAa,WAAW,GAAG;AAE3B,MAAM,eAAe,CAAC,EAAE,SAAS,EAAE,GAAG,OAA6C,iBACjF,8OAAC;QAAI,WAAW,IAAA,yHAAE,EAAC,iEAAiE;QAAa,GAAG,KAAK;;;;;;AAE3G,aAAa,WAAW,GAAG;AAE3B,MAAM,4BAAc,mNAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,2KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,yHAAE,EAAC,qDAAqD;QAClE,GAAG,KAAK;;;;;;AAGb,YAAY,WAAW,GAAG,2KAAqB,CAAC,WAAW;AAE3D,MAAM,kCAAoB,mNAAgB,CAGxC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,iLAA2B;QAAC,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;AAE7G,kBAAkB,WAAW,GAAG,iLAA2B,CAAC,WAAW"}},
    {"offset": {"line": 710, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/quote/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { QuoteFormData, QuoteStatus, Quote, Service, AdditionalService, HomeDetailOption, CleaningEquipment } from '@/types/quote';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport interface SaveQuoteResult {\r\n  success: boolean;\r\n  data?: Quote;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Save or update a quote draft\r\n */\r\nexport async function saveQuoteDraft(\r\n  email: string,\r\n  formData: QuoteFormData\r\n): Promise<SaveQuoteResult> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    // Check if a draft already exists for this email\r\n    const { data: existingDraft } = await supabase\r\n      .from('quotes')\r\n      .select('id')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (existingDraft) {\r\n      // Update existing draft\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .update({\r\n          form_data: formData,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('id', existingDraft.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error updating quote draft:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      return { success: true, data: data as Quote };\r\n    } else {\r\n      // Create new draft\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .insert({\r\n          email: email.trim().toLowerCase(),\r\n          status: 'draft',\r\n          form_data: formData,\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error creating quote draft:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      return { success: true, data: data as Quote };\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error saving quote draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get the latest draft quote for an email\r\n */\r\nexport async function getQuoteDraft(email: string): Promise<Quote | null> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return null;\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('quotes')\r\n      .select('*')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (error) {\r\n      // If no draft exists, that's okay - return null\r\n      if (error.code === 'PGRST116') {\r\n        return null;\r\n      }\r\n      console.error('Error fetching quote draft:', error);\r\n      return null;\r\n    }\r\n\r\n    return data as Quote;\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching quote draft:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all quotes (drafts and submitted) for an email\r\n */\r\nexport async function getQuotesByEmail(email: string): Promise<Quote[]> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return [];\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('quotes')\r\n      .select('*')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .order('updated_at', { ascending: false });\r\n\r\n    if (error) {\r\n      console.error('Error fetching quotes:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as Quote[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching quotes:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Submit a quote (change status from draft to submitted)\r\n */\r\nexport async function submitQuote(\r\n  email: string,\r\n  formData: QuoteFormData\r\n): Promise<SaveQuoteResult> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    // Check if a draft exists for this email\r\n    const { data: existingDraft } = await supabase\r\n      .from('quotes')\r\n      .select('id')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (existingDraft) {\r\n      // Update existing draft to submitted\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .update({\r\n          status: 'submitted',\r\n          form_data: formData,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('id', existingDraft.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error submitting quote:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      revalidatePath('/booking/quote');\r\n      return { success: true, data: data as Quote };\r\n    } else {\r\n      // Create new submitted quote\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .insert({\r\n          email: email.trim().toLowerCase(),\r\n          status: 'submitted',\r\n          form_data: formData,\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error creating submitted quote:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      revalidatePath('/booking/quote');\r\n      return { success: true, data: data as Quote };\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error submitting quote:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get all active services ordered by display_order\r\n */\r\nexport async function getServices(): Promise<Service[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('services')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching services:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as Service[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching services:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get additional services, optionally filtered by main service\r\n */\r\nexport async function getAdditionalServices(serviceId?: string): Promise<AdditionalService[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    if (serviceId) {\r\n      // Get additional services filtered by service rules\r\n      const { data, error } = await supabase\r\n        .from('service_additional_service_rules')\r\n        .select(`\r\n          additional_service_id,\r\n          additional_services:additional_service_id(*)\r\n        `)\r\n        .eq('service_id', serviceId);\r\n\r\n      if (error) {\r\n        console.error('Error fetching additional services by service:', error);\r\n        return [];\r\n      }\r\n\r\n      // Extract and format the additional services\r\n      const additionalServices = (data || [])\r\n        .map((rule: any) => rule.additional_services)\r\n        .filter((service: AdditionalService) => service && service.is_active)\r\n        .sort((a: AdditionalService, b: AdditionalService) => a.display_order - b.display_order);\r\n\r\n      return additionalServices as AdditionalService[];\r\n    } else {\r\n      // Get all active additional services\r\n      const { data, error } = await supabase\r\n        .from('additional_services')\r\n        .select('*')\r\n        .eq('is_active', true)\r\n        .order('display_order', { ascending: true });\r\n\r\n      if (error) {\r\n        console.error('Error fetching all additional services:', error);\r\n        return [];\r\n      }\r\n\r\n      return (data || []) as AdditionalService[];\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching additional services:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get home detail options for a specific type (bedrooms, bathrooms, carpet_type, room_status)\r\n */\r\nexport async function getHomeDetailOptions(optionType: string): Promise<HomeDetailOption[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('*')\r\n      .eq('option_type', optionType)\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error(`Error fetching home detail options for ${optionType}:`, error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as HomeDetailOption[];\r\n  } catch (error) {\r\n    console.error(`Unexpected error fetching home detail options for ${optionType}:`, error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get all active cleaning equipment ordered by display_order\r\n */\r\nexport async function getCleaningEquipment(): Promise<CleaningEquipment[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('cleaning_equipment')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaning equipment:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as CleaningEquipment[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaning equipment:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MA0SsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 724, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/quote/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { QuoteFormData, QuoteStatus, Quote, Service, AdditionalService, HomeDetailOption, CleaningEquipment } from '@/types/quote';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport interface SaveQuoteResult {\r\n  success: boolean;\r\n  data?: Quote;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Save or update a quote draft\r\n */\r\nexport async function saveQuoteDraft(\r\n  email: string,\r\n  formData: QuoteFormData\r\n): Promise<SaveQuoteResult> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    // Check if a draft already exists for this email\r\n    const { data: existingDraft } = await supabase\r\n      .from('quotes')\r\n      .select('id')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (existingDraft) {\r\n      // Update existing draft\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .update({\r\n          form_data: formData,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('id', existingDraft.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error updating quote draft:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      return { success: true, data: data as Quote };\r\n    } else {\r\n      // Create new draft\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .insert({\r\n          email: email.trim().toLowerCase(),\r\n          status: 'draft',\r\n          form_data: formData,\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error creating quote draft:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      return { success: true, data: data as Quote };\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error saving quote draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get the latest draft quote for an email\r\n */\r\nexport async function getQuoteDraft(email: string): Promise<Quote | null> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return null;\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('quotes')\r\n      .select('*')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (error) {\r\n      // If no draft exists, that's okay - return null\r\n      if (error.code === 'PGRST116') {\r\n        return null;\r\n      }\r\n      console.error('Error fetching quote draft:', error);\r\n      return null;\r\n    }\r\n\r\n    return data as Quote;\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching quote draft:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all quotes (drafts and submitted) for an email\r\n */\r\nexport async function getQuotesByEmail(email: string): Promise<Quote[]> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return [];\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('quotes')\r\n      .select('*')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .order('updated_at', { ascending: false });\r\n\r\n    if (error) {\r\n      console.error('Error fetching quotes:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as Quote[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching quotes:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Submit a quote (change status from draft to submitted)\r\n */\r\nexport async function submitQuote(\r\n  email: string,\r\n  formData: QuoteFormData\r\n): Promise<SaveQuoteResult> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    // Check if a draft exists for this email\r\n    const { data: existingDraft } = await supabase\r\n      .from('quotes')\r\n      .select('id')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (existingDraft) {\r\n      // Update existing draft to submitted\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .update({\r\n          status: 'submitted',\r\n          form_data: formData,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('id', existingDraft.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error submitting quote:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      revalidatePath('/booking/quote');\r\n      return { success: true, data: data as Quote };\r\n    } else {\r\n      // Create new submitted quote\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .insert({\r\n          email: email.trim().toLowerCase(),\r\n          status: 'submitted',\r\n          form_data: formData,\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error creating submitted quote:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      revalidatePath('/booking/quote');\r\n      return { success: true, data: data as Quote };\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error submitting quote:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get all active services ordered by display_order\r\n */\r\nexport async function getServices(): Promise<Service[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('services')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching services:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as Service[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching services:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get additional services, optionally filtered by main service\r\n */\r\nexport async function getAdditionalServices(serviceId?: string): Promise<AdditionalService[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    if (serviceId) {\r\n      // Get additional services filtered by service rules\r\n      const { data, error } = await supabase\r\n        .from('service_additional_service_rules')\r\n        .select(`\r\n          additional_service_id,\r\n          additional_services:additional_service_id(*)\r\n        `)\r\n        .eq('service_id', serviceId);\r\n\r\n      if (error) {\r\n        console.error('Error fetching additional services by service:', error);\r\n        return [];\r\n      }\r\n\r\n      // Extract and format the additional services\r\n      const additionalServices = (data || [])\r\n        .map((rule: any) => rule.additional_services)\r\n        .filter((service: AdditionalService) => service && service.is_active)\r\n        .sort((a: AdditionalService, b: AdditionalService) => a.display_order - b.display_order);\r\n\r\n      return additionalServices as AdditionalService[];\r\n    } else {\r\n      // Get all active additional services\r\n      const { data, error } = await supabase\r\n        .from('additional_services')\r\n        .select('*')\r\n        .eq('is_active', true)\r\n        .order('display_order', { ascending: true });\r\n\r\n      if (error) {\r\n        console.error('Error fetching all additional services:', error);\r\n        return [];\r\n      }\r\n\r\n      return (data || []) as AdditionalService[];\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching additional services:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get home detail options for a specific type (bedrooms, bathrooms, carpet_type, room_status)\r\n */\r\nexport async function getHomeDetailOptions(optionType: string): Promise<HomeDetailOption[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('*')\r\n      .eq('option_type', optionType)\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error(`Error fetching home detail options for ${optionType}:`, error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as HomeDetailOption[];\r\n  } catch (error) {\r\n    console.error(`Unexpected error fetching home detail options for ${optionType}:`, error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get all active cleaning equipment ordered by display_order\r\n */\r\nexport async function getCleaningEquipment(): Promise<CleaningEquipment[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('cleaning_equipment')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaning equipment:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as CleaningEquipment[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaning equipment:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAoUsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 738, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/book/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { BookingFormData, BookingCreateInput, WorkingHour, TimeSlotAvailability, Cleaner, CleanerWithAvailability } from '@/types/booking';\r\nimport { calculatePrice } from '@/lib/pricing/calculator';\r\nimport { generateBookingNumber } from '@/lib/utils/booking-number';\r\nimport { initializePayment } from '@/lib/paystack/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { calculateReliabilityScore, calculateCompletionRate, calculateOnTimeRate } from '@/lib/utils/cleaner-utils';\r\nimport { calculateBookingDatesForMonth, calculateNextBookingDate, formatDateForDB } from '@/lib/utils/recurring-dates';\r\nimport { isValidFrequencyForService, requiresTeamBooking } from '@/lib/utils/service-validation';\r\n\r\n/**\r\n * Get available working hours (30-minute interval start times)\r\n */\r\nexport async function getWorkingHours(): Promise<WorkingHour[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('working_hours')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as WorkingHour[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get working hours from home_detail_options (backward compatibility)\r\n */\r\nexport async function getWorkingHoursFromOptions(): Promise<Array<{ value: string; label: string }>> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('value, label')\r\n      .eq('option_type', 'working_hours')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours from options:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []).map((item) => ({\r\n      value: item.value,\r\n      label: item.label,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours from options:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check cleaner availability for a specific date and time slot\r\n * Returns availability status and count of available cleaners\r\n */\r\nexport async function checkCleanerAvailabilityForSlot(\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<TimeSlotAvailability> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, check if any active cleaners exist in the system\r\n    const { data: activeCleaners, error: cleanersError } = await supabase\r\n      .from('cleaners')\r\n      .select('id')\r\n      .eq('is_active', true);\r\n\r\n    if (cleanersError) {\r\n      console.error('Error checking active cleaners:', cleanersError);\r\n      // If we can't check cleaners, assume unavailable for safety\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    // If no active cleaners exist, no slots are available\r\n    if (!activeCleaners || activeCleaners.length === 0) {\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    const totalCleaners = activeCleaners.length;\r\n\r\n    // Query bookings for the specified date that might overlap\r\n    // We need to check for bookings where:\r\n    // (booking_start_time < new_end_time) AND (booking_end_time > new_start_time)\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid, cancelled/completed)\r\n    // Cleaners should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration, preferred_cleaner_id, preferred_cleaner_ids, number_of_cleaners')\r\n      .eq('service_date', serviceDate)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking bookings:', bookingsError);\r\n      // If we can't check bookings, assume available (optimistic approach)\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      // No bookings for this date, all cleaners are available\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Track which cleaners are booked (by ID)\r\n    const bookedCleanerIds = new Set<string>();\r\n    \r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n      \r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number' \r\n          ? booking.service_duration \r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        // There's an overlap\r\n        // Check preferred_cleaner_ids first (new multi-cleaner support)\r\n        if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n          // Multiple cleaners are assigned\r\n          booking.preferred_cleaner_ids.forEach((cleanerId: string) => {\r\n            if (cleanerId) bookedCleanerIds.add(cleanerId);\r\n          });\r\n        } else if (booking.preferred_cleaner_id) {\r\n          // Single cleaner assigned (backward compatibility)\r\n          bookedCleanerIds.add(booking.preferred_cleaner_id);\r\n        } else {\r\n          // If no preferred cleaner, use number_of_cleaners to count generic cleaner slots\r\n          // This handles bookings without specific cleaner assignments\r\n          const numCleaners = booking.number_of_cleaners || 1;\r\n          // We don't add specific IDs here, but count them in bookingsWithoutPreferredCleaner\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate available cleaners\r\n    // Count bookings without preferred cleaners (generic assignments)\r\n    // These use number_of_cleaners to determine how many cleaner slots are taken\r\n    const bookingsWithoutPreferredCleaner = bookings.filter(\r\n      (b) => {\r\n        const hasPreferredCleaners = (b.preferred_cleaner_ids && Array.isArray(b.preferred_cleaner_ids) && b.preferred_cleaner_ids.length > 0) || b.preferred_cleaner_id;\r\n        if (hasPreferredCleaners) return false;\r\n        \r\n        // Check for time overlap\r\n        const [hours, mins] = b.service_time.split(':').slice(0, 2).map(Number);\r\n        const start = hours * 60 + mins;\r\n        const duration = Math.round((typeof b.service_duration === 'number' ? b.service_duration : parseFloat(b.service_duration || '0')) * 60);\r\n        const end = start + duration;\r\n        return newStartTimeMinutes < end && newEndTimeMinutes > start;\r\n      }\r\n    ).reduce((sum, b) => {\r\n      // Sum up the number_of_cleaners for bookings without preferred cleaners\r\n      return sum + (b.number_of_cleaners || 1);\r\n    }, 0);\r\n\r\n    const unavailableCleaners = bookedCleanerIds.size + bookingsWithoutPreferredCleaner;\r\n    const availableCleanersCount = Math.max(0, totalCleaners - unavailableCleaners);\r\n\r\n    return {\r\n      available: availableCleanersCount > 0,\r\n      availableCleanersCount,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking cleaner availability:', error);\r\n    // On error, assume unavailable for safety\r\n    return { available: false, availableCleanersCount: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Check team availability for a specific date for team-based services\r\n * Returns which teams (1, 2, or 3) are available and which are booked\r\n */\r\nexport async function checkTeamAvailabilityForDate(\r\n  serviceDate: string,\r\n  serviceType: string\r\n): Promise<{\r\n  availableTeams: number[];\r\n  bookedTeams: number[];\r\n  allTeamsBooked: boolean;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Only check for team-based services (Deep Cleaning and Move In/Out)\r\n    if (!requiresTeamBooking(serviceType)) {\r\n      return {\r\n        availableTeams: [],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Query bookings for the specified date and service type\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Teams should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('team_number')\r\n      .eq('service_date', serviceDate)\r\n      .eq('service_type', serviceType)\r\n      .not('team_number', 'is', null)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking team bookings:', bookingsError);\r\n      // If we can't check bookings, assume all teams available (optimistic approach)\r\n      return {\r\n        availableTeams: [1, 2, 3],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Extract booked team numbers\r\n    const bookedTeams = (bookings || [])\r\n      .map((booking) => booking.team_number)\r\n      .filter((teamNumber): teamNumber is number => teamNumber !== null && teamNumber >= 1 && teamNumber <= 3);\r\n\r\n    // Get unique booked teams (in case of duplicates)\r\n    const bookedTeamsSet = new Set(bookedTeams);\r\n\r\n    // Calculate available teams (1, 2, 3 minus booked teams)\r\n    const allTeams = [1, 2, 3];\r\n    const availableTeams = allTeams.filter((team) => !bookedTeamsSet.has(team));\r\n\r\n    return {\r\n      availableTeams,\r\n      bookedTeams: Array.from(bookedTeamsSet),\r\n      allTeamsBooked: availableTeams.length === 0,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking team availability:', error);\r\n    // On error, assume all teams available for safety (let database constraint catch duplicates)\r\n    return {\r\n      availableTeams: [1, 2, 3],\r\n      bookedTeams: [],\r\n      allTeamsBooked: false,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check availability for all time slots for a given date\r\n */\r\nexport async function checkAvailabilityForAllSlots(\r\n  serviceDate: string,\r\n  workingHours: WorkingHour[],\r\n  serviceDuration: number,\r\n  serviceType?: string\r\n): Promise<Record<string, TimeSlotAvailability>> {\r\n  const availability: Record<string, TimeSlotAvailability> = {};\r\n\r\n  // If service requires team booking, check team availability instead\r\n  if (serviceType && requiresTeamBooking(serviceType)) {\r\n    const teamAvailability = await checkTeamAvailabilityForDate(serviceDate, serviceType);\r\n    \r\n    // For team-based services, availability is day-based, not time-based\r\n    // If all teams are booked, all slots are unavailable\r\n    // Otherwise, slots are available (but we'll show team selection in UI)\r\n    const slotsAvailable = !teamAvailability.allTeamsBooked;\r\n    const availableTeamsCount = teamAvailability.availableTeams.length;\r\n    \r\n    // Set same availability for all time slots\r\n    workingHours.forEach((hour) => {\r\n      availability[hour.start_time] = {\r\n        available: slotsAvailable,\r\n        availableCleanersCount: availableTeamsCount,\r\n      };\r\n    });\r\n\r\n    return availability;\r\n  }\r\n\r\n  // For regular services, check individual cleaner availability per time slot\r\n  const promises = workingHours.map(async (hour) => {\r\n    const slotAvailability = await checkCleanerAvailabilityForSlot(\r\n      serviceDate,\r\n      hour.start_time,\r\n      serviceDuration\r\n    );\r\n    return { time: hour.start_time, availability: slotAvailability };\r\n  });\r\n\r\n  const results = await Promise.all(promises);\r\n  \r\n  results.forEach(({ time, availability: avail }) => {\r\n    availability[time] = avail;\r\n  });\r\n\r\n  return availability;\r\n}\r\n\r\n/**\r\n * Validate discount code\r\n */\r\nexport async function validateDiscountCode(code: string, subtotal: number): Promise<{\r\n  valid: boolean;\r\n  discountAmount: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (!code || !code.trim()) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('discount_codes')\r\n      .select('*')\r\n      .eq('code', code.trim().toUpperCase())\r\n      .eq('is_active', true)\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      return { valid: false, discountAmount: 0, error: 'Invalid discount code' };\r\n    }\r\n\r\n    // Check validity dates\r\n    const now = new Date();\r\n    const validFrom = new Date(data.valid_from);\r\n    const validUntil = new Date(data.valid_until);\r\n\r\n    if (now < validFrom || now > validUntil) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has expired' };\r\n    }\r\n\r\n    // Check max uses\r\n    if (data.max_uses && data.used_count >= data.max_uses) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has reached maximum uses' };\r\n    }\r\n\r\n    // Check min purchase amount\r\n    if (data.min_purchase_amount && subtotal < data.min_purchase_amount) {\r\n      return { \r\n        valid: false, \r\n        discountAmount: 0, \r\n        error: `Minimum purchase amount of R${data.min_purchase_amount} required` \r\n      };\r\n    }\r\n\r\n    // Calculate discount amount\r\n    let discountAmount = 0;\r\n    if (data.discount_type === 'percentage') {\r\n      discountAmount = (subtotal * data.discount_value) / 100;\r\n      if (data.max_discount_amount && discountAmount > data.max_discount_amount) {\r\n        discountAmount = data.max_discount_amount;\r\n      }\r\n    } else {\r\n      discountAmount = data.discount_value;\r\n    }\r\n\r\n    // Ensure discount doesn't exceed subtotal\r\n    discountAmount = Math.min(discountAmount, subtotal);\r\n\r\n    return { valid: true, discountAmount };\r\n  } catch (error) {\r\n    console.error('Error validating discount code:', error);\r\n    return { valid: false, discountAmount: 0, error: 'Error validating discount code' };\r\n  }\r\n}\r\n\r\n/**\r\n * Create booking draft (before payment)\r\n */\r\nexport async function createBookingDraft(formData: BookingFormData): Promise<{\r\n  success: boolean;\r\n  bookingId?: string;\r\n  bookingIds?: string[];\r\n  totalAmount?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current user if logged in\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n    const userId = user?.id || null;\r\n\r\n    // Get service name\r\n    const { data: service } = await supabase\r\n      .from('services')\r\n      .select('name')\r\n      .eq('id', formData.serviceId)\r\n      .single();\r\n\r\n    if (!service) {\r\n      return { success: false, error: 'Service not found' };\r\n    }\r\n\r\n    // Validate that the selected frequency is valid for this service\r\n    if (!isValidFrequencyForService(service.name, formData.cleaningFrequency)) {\r\n      return { \r\n        success: false, \r\n        error: `Recurring bookings are only available for Standard Cleaning and Airbnb Cleaning services. Selected service: ${service.name}` \r\n      };\r\n    }\r\n\r\n    // Check if service requires team booking\r\n    const isTeamBooking = requiresTeamBooking(service.name);\r\n\r\n    // Validate team booking requirements\r\n    if (isTeamBooking) {\r\n      if (!formData.teamNumber || (formData.teamNumber < 1 || formData.teamNumber > 3)) {\r\n        return {\r\n          success: false,\r\n          error: 'Please select a team (1, 2, or 3) for this service',\r\n        };\r\n      }\r\n\r\n      // Check team availability for each booking date\r\n      const startDate = new Date(formData.serviceDate);\r\n      const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n      \r\n      for (const bookingDate of bookingDates) {\r\n        const teamAvailability = await checkTeamAvailabilityForDate(\r\n          formatDateForDB(bookingDate),\r\n          service.name\r\n        );\r\n        \r\n        if (!teamAvailability.availableTeams.includes(formData.teamNumber!)) {\r\n          const dateStr = formatDateForDB(bookingDate);\r\n          return {\r\n            success: false,\r\n            error: `Team ${formData.teamNumber} is already booked for ${dateStr}. Please select a different team or date.`,\r\n          };\r\n        }\r\n      }\r\n    } else {\r\n      // For non-team bookings, ensure teamNumber is not set\r\n      if (formData.teamNumber !== null && formData.teamNumber !== undefined) {\r\n        return {\r\n          success: false,\r\n          error: 'Team selection is only available for Deep Cleaning and Move In/Out services',\r\n        };\r\n      }\r\n    }\r\n\r\n    // Calculate pricing\r\n    const priceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount: 0, // Will calculate discount in next step\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Apply discount code if provided\r\n    let discountAmount = 0;\r\n    if (formData.discountCode) {\r\n      const discountValidation = await validateDiscountCode(\r\n        formData.discountCode,\r\n        priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount\r\n      );\r\n      if (discountValidation.valid) {\r\n        discountAmount = discountValidation.discountAmount;\r\n      }\r\n    }\r\n\r\n    // Recalculate with discount\r\n    const finalPriceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount,\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Determine if this is a recurring booking\r\n    // Note: Team-based services (Deep Cleaning and Move In/Out) don't support recurring bookings\r\n    // but we'll handle it gracefully if somehow a recurring frequency is selected\r\n    const isRecurring = formData.cleaningFrequency !== 'one-time';\r\n\r\n    // Calculate booking dates based on frequency\r\n    const startDate = new Date(formData.serviceDate);\r\n    const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n\r\n    // Calculate next booking date for recurring bookings\r\n    let nextBookingDate: Date | null = null;\r\n    if (isRecurring && bookingDates.length > 0) {\r\n      const lastDate = bookingDates[bookingDates.length - 1];\r\n      nextBookingDate = calculateNextBookingDate(lastDate, formData.cleaningFrequency);\r\n    }\r\n\r\n    // Create bookings for all dates\r\n    const bookingsToCreate: BookingCreateInput[] = [];\r\n\r\n    for (let i = 0; i < bookingDates.length; i++) {\r\n      const bookingDate = bookingDates[i];\r\n      const bookingNumber = generateBookingNumber();\r\n\r\n      // Tip is only applied to the first booking in a recurring series (one-time payment)\r\n      const tipAmount = (i === 0) ? (formData.tipAmount || 0) : 0;\r\n      \r\n      const bookingInput: BookingCreateInput = {\r\n        booking_number: bookingNumber,\r\n        customer_first_name: formData.customerFirstName,\r\n        customer_last_name: formData.customerLastName,\r\n        customer_email: formData.customerEmail,\r\n        customer_phone: formData.customerPhone,\r\n        service_id: formData.serviceId,\r\n        service_type: service.name,\r\n        bedrooms: formData.bedrooms,\r\n        bathrooms: formData.bathrooms,\r\n        additional_services: formData.additionalServices,\r\n        cleaning_equipment: formData.cleaningEquipment,\r\n        preferred_cleaner_ids: isTeamBooking \r\n          ? null // Team bookings don't have preferred cleaners\r\n          : (formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n            ? formData.preferredCleanerIds \r\n            : null),\r\n        preferred_cleaner_id: isTeamBooking\r\n          ? null // Team bookings don't have preferred cleaners\r\n          : (formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n            ? formData.preferredCleanerIds[0] \r\n            : null), // Backward compatibility: set to first cleaner\r\n        team_number: isTeamBooking && formData.teamNumber ? formData.teamNumber : null,\r\n        cleaning_frequency: formData.cleaningFrequency,\r\n        service_date: formatDateForDB(bookingDate),\r\n        service_time: formData.serviceTime,\r\n        service_duration: formData.serviceDuration,\r\n        service_address: formData.serviceAddress,\r\n        service_apt_unit: formData.serviceAptUnit || null,\r\n        service_suburb: formData.serviceSuburb,\r\n        service_city: formData.serviceCity,\r\n        special_instructions: formData.specialInstructions || null,\r\n        tip_amount: tipAmount,\r\n        base_price: finalPriceBreakdown.basePrice,\r\n        additional_services_price: finalPriceBreakdown.additionalServicesPrice,\r\n        equipment_supply_price: finalPriceBreakdown.equipmentSupplyPrice,\r\n        number_of_cleaners: formData.numberOfCleaners || 1,\r\n        additional_cleaners_price: finalPriceBreakdown.additionalCleanersPrice,\r\n        frequency_discount_percent: finalPriceBreakdown.frequencyDiscountPercent,\r\n        frequency_discount_amount: finalPriceBreakdown.frequencyDiscountAmount,\r\n        subtotal: finalPriceBreakdown.subtotal,\r\n        service_fee: finalPriceBreakdown.serviceFee,\r\n        total_amount: finalPriceBreakdown.totalAmount + tipAmount,\r\n        discount_code: formData.discountCode || null,\r\n        discount_amount: discountAmount,\r\n        referral_code: formData.referralCode || null,\r\n        amount_paid: 0,\r\n        payment_status: 'pending',\r\n        status: 'pending',\r\n        user_id: userId,\r\n        parent_booking_id: null, // Will be updated after first booking is created\r\n        is_recurring: isRecurring,\r\n        recurrence_status: isRecurring ? 'active' : undefined,\r\n        next_booking_date: i === 0 && isRecurring && nextBookingDate ? formatDateForDB(nextBookingDate) : null,\r\n        credits_used: 0, // Will be updated when credits are used during payment\r\n      };\r\n\r\n      bookingsToCreate.push(bookingInput);\r\n    }\r\n\r\n    // Insert all bookings\r\n    const { data: insertedBookings, error } = await supabase\r\n      .from('bookings')\r\n      .insert(bookingsToCreate)\r\n      .select('id, total_amount');\r\n\r\n    if (error) {\r\n      console.error('Error creating booking drafts:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!insertedBookings || insertedBookings.length === 0) {\r\n      return { success: false, error: 'Failed to create bookings' };\r\n    }\r\n\r\n    // Update parent_booking_id for subsequent bookings if there are multiple\r\n    if (insertedBookings.length > 1 && isRecurring) {\r\n      const firstBookingId = insertedBookings[0].id;\r\n      const subsequentBookingIds = insertedBookings.slice(1).map(b => b.id);\r\n      \r\n      // Update all subsequent bookings to reference the first one\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({ parent_booking_id: firstBookingId })\r\n        .in('id', subsequentBookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating parent_booking_id:', updateError);\r\n        // Don't fail, but log the error\r\n      }\r\n    }\r\n\r\n    // Calculate total amount\r\n    const totalAmount = insertedBookings.reduce((sum, booking) => sum + Number(booking.total_amount), 0);\r\n    const bookingIds = insertedBookings.map(booking => booking.id);\r\n\r\n    // For backward compatibility, also return single bookingId\r\n    const bookingId = bookingIds[0];\r\n\r\n    // If multiple bookings, return array; otherwise return single ID for backward compatibility\r\n    if (bookingIds.length > 1) {\r\n      return { \r\n        success: true, \r\n        bookingIds,\r\n        totalAmount,\r\n        bookingId // Keep for backward compatibility\r\n      };\r\n    }\r\n\r\n    return { \r\n      success: true, \r\n      bookingId,\r\n      bookingIds,\r\n      totalAmount\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error creating booking draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize payment for booking(s)\r\n * Accepts either a single bookingId or an array of bookingIds\r\n */\r\nexport async function initializePaymentForBooking(\r\n  bookingIdOrIds: string | string[]\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const bookingIds = Array.isArray(bookingIdOrIds) ? bookingIdOrIds : [bookingIdOrIds];\r\n\r\n    // Get all booking details\r\n    const { data: bookings, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (fetchError || !bookings || bookings.length === 0) {\r\n      return { success: false, error: 'Booking(s) not found' };\r\n    }\r\n\r\n    // Check if all bookings are in pending status\r\n    const nonPendingBookings = bookings.filter(b => b.payment_status !== 'pending');\r\n    if (nonPendingBookings.length > 0) {\r\n      return { success: false, error: 'Some bookings are not in pending payment status' };\r\n    }\r\n\r\n    // Calculate total amount from all bookings (including tip)\r\n    // Note: total_amount in database now includes tip for new bookings\r\n    // For backward compatibility with existing bookings that might not have tip in total_amount, \r\n    // we check and add tip_amount if it's missing\r\n    const totalAmount = bookings.reduce((sum, booking) => {\r\n      const bookingTotal = Number(booking.total_amount) || 0;\r\n      const tipAmount = Number(booking.tip_amount) || 0;\r\n      const baseTotal = Number(booking.subtotal || 0) + Number(booking.service_fee || 0);\r\n      \r\n      // Check if tip is already included in total_amount\r\n      // If total_amount equals baseTotal exactly, then tip is not included, so add it\r\n      // Otherwise, total_amount already includes tip\r\n      if (tipAmount > 0 && Math.abs(bookingTotal - baseTotal) < 0.01) {\r\n        // Tip is not included in total_amount (backward compatibility case)\r\n        return sum + bookingTotal + tipAmount;\r\n      }\r\n      // Tip is already included in total_amount (new bookings)\r\n      return sum + bookingTotal;\r\n    }, 0);\r\n\r\n    // Calculate total credits used across all bookings\r\n    const totalCreditsUsed = bookings.reduce((sum, booking) => {\r\n      return sum + (Number(booking.credits_used) || 0);\r\n    }, 0);\r\n\r\n    // Calculate remaining amount after credits\r\n    const remainingAmount = totalAmount - totalCreditsUsed;\r\n\r\n    // Use the first booking's email and details for payment\r\n    const firstBooking = bookings[0];\r\n\r\n    // If credits fully cover the booking, mark as paid and skip Paystack\r\n    if (remainingAmount <= 0) {\r\n      // Update all bookings to mark as paid\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({\r\n          payment_status: 'paid',\r\n          amount_paid: totalAmount, // Fully paid with credits\r\n          status: 'confirmed', // Auto-confirm when fully paid\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .in('id', bookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating bookings payment status:', updateError);\r\n        return { success: false, error: 'Failed to update booking payment status' };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        // No authorizationUrl - payment fully covered by credits\r\n      };\r\n    }\r\n\r\n    // Partial credit coverage or no credits - proceed with Paystack for remaining amount\r\n    const reference = firstBooking.paystack_reference || `${firstBooking.booking_number}${Date.now()}`;\r\n    \r\n    // Initialize Paystack payment with remaining amount (after credits)\r\n    const paymentResponse = await initializePayment(\r\n      firstBooking.customer_email,\r\n      remainingAmount, // Only charge the remaining amount\r\n      reference,\r\n      {\r\n        booking_ids: bookingIds,\r\n        booking_id: firstBooking.id, // Keep for backward compatibility\r\n        booking_number: firstBooking.booking_number,\r\n        customer_email: firstBooking.customer_email,\r\n        credits_used: totalCreditsUsed, // Include in metadata for tracking\r\n      }\r\n    );\r\n\r\n    if (!paymentResponse.status) {\r\n      return { success: false, error: paymentResponse.message || 'Failed to initialize payment' };\r\n    }\r\n\r\n    // Use the reference that Paystack actually returned (may differ from what we sent)\r\n    const paystackReference = paymentResponse.data.reference;\r\n\r\n    // Update all bookings with the Paystack reference and partial payment from credits\r\n    const { error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        paystack_reference: paystackReference,\r\n        amount_paid: totalCreditsUsed, // Partial payment from credits, Paystack will complete it\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .in('id', bookingIds);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating bookings with Paystack reference:', updateError);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentResponse.data.authorization_url,\r\n      reference: paystackReference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing payment:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get booking by ID\r\n */\r\nexport async function getBooking(bookingId: string): Promise<{\r\n  success: boolean;\r\n  booking?: any;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners for selection\r\n * Optionally filter by service area/suburb\r\n */\r\nexport async function getAvailableCleaners(serviceSuburb?: string): Promise<{\r\n  success: boolean;\r\n  cleaners?: any[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Build query - only filter by is_available if the column exists\r\n    // First, try to get all active cleaners\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = data || [];\r\n\r\n    // Filter by is_available if the column exists (client-side filter as fallback)\r\n    cleaners = cleaners.filter((cleaner) => {\r\n      // If is_available column doesn't exist or is null/undefined, include the cleaner\r\n      // Otherwise, only include if is_available is true\r\n      return cleaner.is_available !== false;\r\n    });\r\n\r\n    // Filter by area if suburb is provided\r\n    // Since PostgreSQL array contains is complex in Supabase, we filter client-side\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        // If cleaner has no areas specified, include them (they serve all areas)\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true;\r\n        }\r\n        // Check if any area matches the suburb (case-insensitive partial match)\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    return { success: true, cleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a cleaner is available for a specific day of the week\r\n * dayOfWeek: 0 = Sunday, 1 = Monday, ..., 6 = Saturday\r\n */\r\nexport async function isCleanerAvailableForDay(cleaner: any, dayOfWeek: number): Promise<boolean> {\r\n  const dayMap: Record<number, keyof typeof cleaner> = {\r\n    0: 'available_sunday',\r\n    1: 'available_monday',\r\n    2: 'available_tuesday',\r\n    3: 'available_wednesday',\r\n    4: 'available_thursday',\r\n    5: 'available_friday',\r\n    6: 'available_saturday',\r\n  };\r\n\r\n  const dayField = dayMap[dayOfWeek];\r\n  return cleaner[dayField] !== false && cleaner.is_available !== false;\r\n}\r\n\r\n/**\r\n * Check if a cleaner has a booking conflict for a specific date and time slot\r\n */\r\nexport async function checkCleanerBookingConflict(\r\n  cleanerId: string,\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Query bookings for this cleaner on the specified date\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Cleaners should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration')\r\n      .eq('preferred_cleaner_id', cleanerId)\r\n      .eq('service_date', serviceDate)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (error) {\r\n      console.error('Error checking booking conflicts:', error);\r\n      return false; // Assume no conflict on error\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      return false; // No bookings, no conflict\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n\r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number'\r\n          ? booking.service_duration\r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        return true; // Conflict found\r\n      }\r\n    }\r\n\r\n    return false; // No conflicts\r\n  } catch (error) {\r\n    console.error('Unexpected error checking booking conflict:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate reliability score for a cleaner (server-side wrapper)\r\n * This calls the database function if available, otherwise calculates client-side\r\n */\r\nexport async function calculateCleanerReliabilityScore(cleanerId: string): Promise<number> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Try to call the database function\r\n    const { data, error } = await supabase.rpc('calculate_cleaner_reliability_score', {\r\n      cleaner_id: cleanerId,\r\n    });\r\n\r\n    if (!error && data !== null) {\r\n      return parseFloat(data.toString());\r\n    }\r\n\r\n    // Fallback: fetch cleaner and calculate client-side\r\n    const { data: cleaner, error: fetchError } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('id', cleanerId)\r\n      .single();\r\n\r\n    if (fetchError || !cleaner) {\r\n      return 50.0; // Default score\r\n    }\r\n\r\n    return calculateReliabilityScore(cleaner as Cleaner);\r\n  } catch (error) {\r\n    console.error('Error calculating reliability score:', error);\r\n    return 50.0; // Default score on error\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners with enhanced filtering criteria\r\n * Filters by: Location, Availability, Booking conflicts\r\n * Sorts by: Reliability Score, Rating\r\n */\r\nexport async function getAvailableCleanersWithCriteria(params: {\r\n  serviceSuburb?: string;\r\n  serviceDate?: string;\r\n  serviceTime?: string;\r\n  serviceDuration?: number;\r\n  minRating?: number;\r\n  minReliabilityScore?: number;\r\n}): Promise<{\r\n  success: boolean;\r\n  cleaners?: CleanerWithAvailability[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const {\r\n      serviceSuburb,\r\n      serviceDate,\r\n      serviceTime,\r\n      serviceDuration = 3,\r\n      minRating = 0,\r\n      minReliabilityScore = 0,\r\n    } = params;\r\n\r\n    // Build base query\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query.order('reliability_score', { ascending: false, nullsFirst: false })\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = (data || []) as Cleaner[];\r\n\r\n    // Filter by is_available\r\n    cleaners = cleaners.filter((cleaner) => cleaner.is_available !== false);\r\n\r\n    // Filter by location (suburb)\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true; // Serve all areas\r\n        }\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Filter by day of week availability if date is provided\r\n    if (serviceDate) {\r\n      const date = new Date(serviceDate);\r\n      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        const dayMap: Record<number, keyof Cleaner> = {\r\n          0: 'available_sunday',\r\n          1: 'available_monday',\r\n          2: 'available_tuesday',\r\n          3: 'available_wednesday',\r\n          4: 'available_thursday',\r\n          5: 'available_friday',\r\n          6: 'available_saturday',\r\n        };\r\n        const dayField = dayMap[dayOfWeek];\r\n        return cleaner[dayField] !== false;\r\n      });\r\n    }\r\n\r\n    // Filter by minimum rating\r\n    if (minRating > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.rating || 0) >= minRating);\r\n    }\r\n\r\n    // Filter by minimum reliability score\r\n    if (minReliabilityScore > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.reliability_score || 0) >= minReliabilityScore);\r\n    }\r\n\r\n    // Enrich cleaners with availability and booking conflict information\r\n    const enrichedCleaners: CleanerWithAvailability[] = await Promise.all(\r\n      cleaners.map(async (cleaner) => {\r\n        let isAvailableForSlot = true;\r\n        let bookingConflict = false;\r\n\r\n        // Check booking conflict if date and time are provided\r\n        if (serviceDate && serviceTime && serviceDuration) {\r\n          bookingConflict = await checkCleanerBookingConflict(\r\n            cleaner.id,\r\n            serviceDate,\r\n            serviceTime,\r\n            serviceDuration\r\n          );\r\n          isAvailableForSlot = !bookingConflict;\r\n        }\r\n\r\n        // Calculate reliability score if not present\r\n        const reliabilityScore = cleaner.reliability_score ?? calculateReliabilityScore(cleaner);\r\n\r\n        return {\r\n          ...cleaner,\r\n          reliability_score: reliabilityScore,\r\n          isAvailableForSlot,\r\n          bookingConflict,\r\n          completionRate: calculateCompletionRate(cleaner),\r\n          onTimeRate: calculateOnTimeRate(cleaner),\r\n        };\r\n      })\r\n    );\r\n\r\n    // Sort by reliability score and rating (already sorted by query, but ensure consistency)\r\n    enrichedCleaners.sort((a, b) => {\r\n      const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n      const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n\r\n    return { success: true, cleaners: enrichedCleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners with criteria:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAesB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,mDAAA"}},
    {"offset": {"line": 752, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/book/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { BookingFormData, BookingCreateInput, WorkingHour, TimeSlotAvailability, Cleaner, CleanerWithAvailability } from '@/types/booking';\r\nimport { calculatePrice } from '@/lib/pricing/calculator';\r\nimport { generateBookingNumber } from '@/lib/utils/booking-number';\r\nimport { initializePayment } from '@/lib/paystack/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { calculateReliabilityScore, calculateCompletionRate, calculateOnTimeRate } from '@/lib/utils/cleaner-utils';\r\nimport { calculateBookingDatesForMonth, calculateNextBookingDate, formatDateForDB } from '@/lib/utils/recurring-dates';\r\nimport { isValidFrequencyForService, requiresTeamBooking } from '@/lib/utils/service-validation';\r\n\r\n/**\r\n * Get available working hours (30-minute interval start times)\r\n */\r\nexport async function getWorkingHours(): Promise<WorkingHour[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('working_hours')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as WorkingHour[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get working hours from home_detail_options (backward compatibility)\r\n */\r\nexport async function getWorkingHoursFromOptions(): Promise<Array<{ value: string; label: string }>> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('value, label')\r\n      .eq('option_type', 'working_hours')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours from options:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []).map((item) => ({\r\n      value: item.value,\r\n      label: item.label,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours from options:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check cleaner availability for a specific date and time slot\r\n * Returns availability status and count of available cleaners\r\n */\r\nexport async function checkCleanerAvailabilityForSlot(\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<TimeSlotAvailability> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, check if any active cleaners exist in the system\r\n    const { data: activeCleaners, error: cleanersError } = await supabase\r\n      .from('cleaners')\r\n      .select('id')\r\n      .eq('is_active', true);\r\n\r\n    if (cleanersError) {\r\n      console.error('Error checking active cleaners:', cleanersError);\r\n      // If we can't check cleaners, assume unavailable for safety\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    // If no active cleaners exist, no slots are available\r\n    if (!activeCleaners || activeCleaners.length === 0) {\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    const totalCleaners = activeCleaners.length;\r\n\r\n    // Query bookings for the specified date that might overlap\r\n    // We need to check for bookings where:\r\n    // (booking_start_time < new_end_time) AND (booking_end_time > new_start_time)\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid, cancelled/completed)\r\n    // Cleaners should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration, preferred_cleaner_id, preferred_cleaner_ids, number_of_cleaners')\r\n      .eq('service_date', serviceDate)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking bookings:', bookingsError);\r\n      // If we can't check bookings, assume available (optimistic approach)\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      // No bookings for this date, all cleaners are available\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Track which cleaners are booked (by ID)\r\n    const bookedCleanerIds = new Set<string>();\r\n    \r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n      \r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number' \r\n          ? booking.service_duration \r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        // There's an overlap\r\n        // Check preferred_cleaner_ids first (new multi-cleaner support)\r\n        if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n          // Multiple cleaners are assigned\r\n          booking.preferred_cleaner_ids.forEach((cleanerId: string) => {\r\n            if (cleanerId) bookedCleanerIds.add(cleanerId);\r\n          });\r\n        } else if (booking.preferred_cleaner_id) {\r\n          // Single cleaner assigned (backward compatibility)\r\n          bookedCleanerIds.add(booking.preferred_cleaner_id);\r\n        } else {\r\n          // If no preferred cleaner, use number_of_cleaners to count generic cleaner slots\r\n          // This handles bookings without specific cleaner assignments\r\n          const numCleaners = booking.number_of_cleaners || 1;\r\n          // We don't add specific IDs here, but count them in bookingsWithoutPreferredCleaner\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate available cleaners\r\n    // Count bookings without preferred cleaners (generic assignments)\r\n    // These use number_of_cleaners to determine how many cleaner slots are taken\r\n    const bookingsWithoutPreferredCleaner = bookings.filter(\r\n      (b) => {\r\n        const hasPreferredCleaners = (b.preferred_cleaner_ids && Array.isArray(b.preferred_cleaner_ids) && b.preferred_cleaner_ids.length > 0) || b.preferred_cleaner_id;\r\n        if (hasPreferredCleaners) return false;\r\n        \r\n        // Check for time overlap\r\n        const [hours, mins] = b.service_time.split(':').slice(0, 2).map(Number);\r\n        const start = hours * 60 + mins;\r\n        const duration = Math.round((typeof b.service_duration === 'number' ? b.service_duration : parseFloat(b.service_duration || '0')) * 60);\r\n        const end = start + duration;\r\n        return newStartTimeMinutes < end && newEndTimeMinutes > start;\r\n      }\r\n    ).reduce((sum, b) => {\r\n      // Sum up the number_of_cleaners for bookings without preferred cleaners\r\n      return sum + (b.number_of_cleaners || 1);\r\n    }, 0);\r\n\r\n    const unavailableCleaners = bookedCleanerIds.size + bookingsWithoutPreferredCleaner;\r\n    const availableCleanersCount = Math.max(0, totalCleaners - unavailableCleaners);\r\n\r\n    return {\r\n      available: availableCleanersCount > 0,\r\n      availableCleanersCount,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking cleaner availability:', error);\r\n    // On error, assume unavailable for safety\r\n    return { available: false, availableCleanersCount: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Check team availability for a specific date for team-based services\r\n * Returns which teams (1, 2, or 3) are available and which are booked\r\n */\r\nexport async function checkTeamAvailabilityForDate(\r\n  serviceDate: string,\r\n  serviceType: string\r\n): Promise<{\r\n  availableTeams: number[];\r\n  bookedTeams: number[];\r\n  allTeamsBooked: boolean;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Only check for team-based services (Deep Cleaning and Move In/Out)\r\n    if (!requiresTeamBooking(serviceType)) {\r\n      return {\r\n        availableTeams: [],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Query bookings for the specified date and service type\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Teams should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('team_number')\r\n      .eq('service_date', serviceDate)\r\n      .eq('service_type', serviceType)\r\n      .not('team_number', 'is', null)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking team bookings:', bookingsError);\r\n      // If we can't check bookings, assume all teams available (optimistic approach)\r\n      return {\r\n        availableTeams: [1, 2, 3],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Extract booked team numbers\r\n    const bookedTeams = (bookings || [])\r\n      .map((booking) => booking.team_number)\r\n      .filter((teamNumber): teamNumber is number => teamNumber !== null && teamNumber >= 1 && teamNumber <= 3);\r\n\r\n    // Get unique booked teams (in case of duplicates)\r\n    const bookedTeamsSet = new Set(bookedTeams);\r\n\r\n    // Calculate available teams (1, 2, 3 minus booked teams)\r\n    const allTeams = [1, 2, 3];\r\n    const availableTeams = allTeams.filter((team) => !bookedTeamsSet.has(team));\r\n\r\n    return {\r\n      availableTeams,\r\n      bookedTeams: Array.from(bookedTeamsSet),\r\n      allTeamsBooked: availableTeams.length === 0,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking team availability:', error);\r\n    // On error, assume all teams available for safety (let database constraint catch duplicates)\r\n    return {\r\n      availableTeams: [1, 2, 3],\r\n      bookedTeams: [],\r\n      allTeamsBooked: false,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check availability for all time slots for a given date\r\n */\r\nexport async function checkAvailabilityForAllSlots(\r\n  serviceDate: string,\r\n  workingHours: WorkingHour[],\r\n  serviceDuration: number,\r\n  serviceType?: string\r\n): Promise<Record<string, TimeSlotAvailability>> {\r\n  const availability: Record<string, TimeSlotAvailability> = {};\r\n\r\n  // If service requires team booking, check team availability instead\r\n  if (serviceType && requiresTeamBooking(serviceType)) {\r\n    const teamAvailability = await checkTeamAvailabilityForDate(serviceDate, serviceType);\r\n    \r\n    // For team-based services, availability is day-based, not time-based\r\n    // If all teams are booked, all slots are unavailable\r\n    // Otherwise, slots are available (but we'll show team selection in UI)\r\n    const slotsAvailable = !teamAvailability.allTeamsBooked;\r\n    const availableTeamsCount = teamAvailability.availableTeams.length;\r\n    \r\n    // Set same availability for all time slots\r\n    workingHours.forEach((hour) => {\r\n      availability[hour.start_time] = {\r\n        available: slotsAvailable,\r\n        availableCleanersCount: availableTeamsCount,\r\n      };\r\n    });\r\n\r\n    return availability;\r\n  }\r\n\r\n  // For regular services, check individual cleaner availability per time slot\r\n  const promises = workingHours.map(async (hour) => {\r\n    const slotAvailability = await checkCleanerAvailabilityForSlot(\r\n      serviceDate,\r\n      hour.start_time,\r\n      serviceDuration\r\n    );\r\n    return { time: hour.start_time, availability: slotAvailability };\r\n  });\r\n\r\n  const results = await Promise.all(promises);\r\n  \r\n  results.forEach(({ time, availability: avail }) => {\r\n    availability[time] = avail;\r\n  });\r\n\r\n  return availability;\r\n}\r\n\r\n/**\r\n * Validate discount code\r\n */\r\nexport async function validateDiscountCode(code: string, subtotal: number): Promise<{\r\n  valid: boolean;\r\n  discountAmount: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (!code || !code.trim()) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('discount_codes')\r\n      .select('*')\r\n      .eq('code', code.trim().toUpperCase())\r\n      .eq('is_active', true)\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      return { valid: false, discountAmount: 0, error: 'Invalid discount code' };\r\n    }\r\n\r\n    // Check validity dates\r\n    const now = new Date();\r\n    const validFrom = new Date(data.valid_from);\r\n    const validUntil = new Date(data.valid_until);\r\n\r\n    if (now < validFrom || now > validUntil) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has expired' };\r\n    }\r\n\r\n    // Check max uses\r\n    if (data.max_uses && data.used_count >= data.max_uses) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has reached maximum uses' };\r\n    }\r\n\r\n    // Check min purchase amount\r\n    if (data.min_purchase_amount && subtotal < data.min_purchase_amount) {\r\n      return { \r\n        valid: false, \r\n        discountAmount: 0, \r\n        error: `Minimum purchase amount of R${data.min_purchase_amount} required` \r\n      };\r\n    }\r\n\r\n    // Calculate discount amount\r\n    let discountAmount = 0;\r\n    if (data.discount_type === 'percentage') {\r\n      discountAmount = (subtotal * data.discount_value) / 100;\r\n      if (data.max_discount_amount && discountAmount > data.max_discount_amount) {\r\n        discountAmount = data.max_discount_amount;\r\n      }\r\n    } else {\r\n      discountAmount = data.discount_value;\r\n    }\r\n\r\n    // Ensure discount doesn't exceed subtotal\r\n    discountAmount = Math.min(discountAmount, subtotal);\r\n\r\n    return { valid: true, discountAmount };\r\n  } catch (error) {\r\n    console.error('Error validating discount code:', error);\r\n    return { valid: false, discountAmount: 0, error: 'Error validating discount code' };\r\n  }\r\n}\r\n\r\n/**\r\n * Create booking draft (before payment)\r\n */\r\nexport async function createBookingDraft(formData: BookingFormData): Promise<{\r\n  success: boolean;\r\n  bookingId?: string;\r\n  bookingIds?: string[];\r\n  totalAmount?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current user if logged in\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n    const userId = user?.id || null;\r\n\r\n    // Get service name\r\n    const { data: service } = await supabase\r\n      .from('services')\r\n      .select('name')\r\n      .eq('id', formData.serviceId)\r\n      .single();\r\n\r\n    if (!service) {\r\n      return { success: false, error: 'Service not found' };\r\n    }\r\n\r\n    // Validate that the selected frequency is valid for this service\r\n    if (!isValidFrequencyForService(service.name, formData.cleaningFrequency)) {\r\n      return { \r\n        success: false, \r\n        error: `Recurring bookings are only available for Standard Cleaning and Airbnb Cleaning services. Selected service: ${service.name}` \r\n      };\r\n    }\r\n\r\n    // Check if service requires team booking\r\n    const isTeamBooking = requiresTeamBooking(service.name);\r\n\r\n    // Validate team booking requirements\r\n    if (isTeamBooking) {\r\n      if (!formData.teamNumber || (formData.teamNumber < 1 || formData.teamNumber > 3)) {\r\n        return {\r\n          success: false,\r\n          error: 'Please select a team (1, 2, or 3) for this service',\r\n        };\r\n      }\r\n\r\n      // Check team availability for each booking date\r\n      const startDate = new Date(formData.serviceDate);\r\n      const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n      \r\n      for (const bookingDate of bookingDates) {\r\n        const teamAvailability = await checkTeamAvailabilityForDate(\r\n          formatDateForDB(bookingDate),\r\n          service.name\r\n        );\r\n        \r\n        if (!teamAvailability.availableTeams.includes(formData.teamNumber!)) {\r\n          const dateStr = formatDateForDB(bookingDate);\r\n          return {\r\n            success: false,\r\n            error: `Team ${formData.teamNumber} is already booked for ${dateStr}. Please select a different team or date.`,\r\n          };\r\n        }\r\n      }\r\n    } else {\r\n      // For non-team bookings, ensure teamNumber is not set\r\n      if (formData.teamNumber !== null && formData.teamNumber !== undefined) {\r\n        return {\r\n          success: false,\r\n          error: 'Team selection is only available for Deep Cleaning and Move In/Out services',\r\n        };\r\n      }\r\n    }\r\n\r\n    // Calculate pricing\r\n    const priceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount: 0, // Will calculate discount in next step\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Apply discount code if provided\r\n    let discountAmount = 0;\r\n    if (formData.discountCode) {\r\n      const discountValidation = await validateDiscountCode(\r\n        formData.discountCode,\r\n        priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount\r\n      );\r\n      if (discountValidation.valid) {\r\n        discountAmount = discountValidation.discountAmount;\r\n      }\r\n    }\r\n\r\n    // Recalculate with discount\r\n    const finalPriceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount,\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Determine if this is a recurring booking\r\n    // Note: Team-based services (Deep Cleaning and Move In/Out) don't support recurring bookings\r\n    // but we'll handle it gracefully if somehow a recurring frequency is selected\r\n    const isRecurring = formData.cleaningFrequency !== 'one-time';\r\n\r\n    // Calculate booking dates based on frequency\r\n    const startDate = new Date(formData.serviceDate);\r\n    const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n\r\n    // Calculate next booking date for recurring bookings\r\n    let nextBookingDate: Date | null = null;\r\n    if (isRecurring && bookingDates.length > 0) {\r\n      const lastDate = bookingDates[bookingDates.length - 1];\r\n      nextBookingDate = calculateNextBookingDate(lastDate, formData.cleaningFrequency);\r\n    }\r\n\r\n    // Create bookings for all dates\r\n    const bookingsToCreate: BookingCreateInput[] = [];\r\n\r\n    for (let i = 0; i < bookingDates.length; i++) {\r\n      const bookingDate = bookingDates[i];\r\n      const bookingNumber = generateBookingNumber();\r\n\r\n      // Tip is only applied to the first booking in a recurring series (one-time payment)\r\n      const tipAmount = (i === 0) ? (formData.tipAmount || 0) : 0;\r\n      \r\n      const bookingInput: BookingCreateInput = {\r\n        booking_number: bookingNumber,\r\n        customer_first_name: formData.customerFirstName,\r\n        customer_last_name: formData.customerLastName,\r\n        customer_email: formData.customerEmail,\r\n        customer_phone: formData.customerPhone,\r\n        service_id: formData.serviceId,\r\n        service_type: service.name,\r\n        bedrooms: formData.bedrooms,\r\n        bathrooms: formData.bathrooms,\r\n        additional_services: formData.additionalServices,\r\n        cleaning_equipment: formData.cleaningEquipment,\r\n        preferred_cleaner_ids: isTeamBooking \r\n          ? null // Team bookings don't have preferred cleaners\r\n          : (formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n            ? formData.preferredCleanerIds \r\n            : null),\r\n        preferred_cleaner_id: isTeamBooking\r\n          ? null // Team bookings don't have preferred cleaners\r\n          : (formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n            ? formData.preferredCleanerIds[0] \r\n            : null), // Backward compatibility: set to first cleaner\r\n        team_number: isTeamBooking && formData.teamNumber ? formData.teamNumber : null,\r\n        cleaning_frequency: formData.cleaningFrequency,\r\n        service_date: formatDateForDB(bookingDate),\r\n        service_time: formData.serviceTime,\r\n        service_duration: formData.serviceDuration,\r\n        service_address: formData.serviceAddress,\r\n        service_apt_unit: formData.serviceAptUnit || null,\r\n        service_suburb: formData.serviceSuburb,\r\n        service_city: formData.serviceCity,\r\n        special_instructions: formData.specialInstructions || null,\r\n        tip_amount: tipAmount,\r\n        base_price: finalPriceBreakdown.basePrice,\r\n        additional_services_price: finalPriceBreakdown.additionalServicesPrice,\r\n        equipment_supply_price: finalPriceBreakdown.equipmentSupplyPrice,\r\n        number_of_cleaners: formData.numberOfCleaners || 1,\r\n        additional_cleaners_price: finalPriceBreakdown.additionalCleanersPrice,\r\n        frequency_discount_percent: finalPriceBreakdown.frequencyDiscountPercent,\r\n        frequency_discount_amount: finalPriceBreakdown.frequencyDiscountAmount,\r\n        subtotal: finalPriceBreakdown.subtotal,\r\n        service_fee: finalPriceBreakdown.serviceFee,\r\n        total_amount: finalPriceBreakdown.totalAmount + tipAmount,\r\n        discount_code: formData.discountCode || null,\r\n        discount_amount: discountAmount,\r\n        referral_code: formData.referralCode || null,\r\n        amount_paid: 0,\r\n        payment_status: 'pending',\r\n        status: 'pending',\r\n        user_id: userId,\r\n        parent_booking_id: null, // Will be updated after first booking is created\r\n        is_recurring: isRecurring,\r\n        recurrence_status: isRecurring ? 'active' : undefined,\r\n        next_booking_date: i === 0 && isRecurring && nextBookingDate ? formatDateForDB(nextBookingDate) : null,\r\n        credits_used: 0, // Will be updated when credits are used during payment\r\n      };\r\n\r\n      bookingsToCreate.push(bookingInput);\r\n    }\r\n\r\n    // Insert all bookings\r\n    const { data: insertedBookings, error } = await supabase\r\n      .from('bookings')\r\n      .insert(bookingsToCreate)\r\n      .select('id, total_amount');\r\n\r\n    if (error) {\r\n      console.error('Error creating booking drafts:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!insertedBookings || insertedBookings.length === 0) {\r\n      return { success: false, error: 'Failed to create bookings' };\r\n    }\r\n\r\n    // Update parent_booking_id for subsequent bookings if there are multiple\r\n    if (insertedBookings.length > 1 && isRecurring) {\r\n      const firstBookingId = insertedBookings[0].id;\r\n      const subsequentBookingIds = insertedBookings.slice(1).map(b => b.id);\r\n      \r\n      // Update all subsequent bookings to reference the first one\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({ parent_booking_id: firstBookingId })\r\n        .in('id', subsequentBookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating parent_booking_id:', updateError);\r\n        // Don't fail, but log the error\r\n      }\r\n    }\r\n\r\n    // Calculate total amount\r\n    const totalAmount = insertedBookings.reduce((sum, booking) => sum + Number(booking.total_amount), 0);\r\n    const bookingIds = insertedBookings.map(booking => booking.id);\r\n\r\n    // For backward compatibility, also return single bookingId\r\n    const bookingId = bookingIds[0];\r\n\r\n    // If multiple bookings, return array; otherwise return single ID for backward compatibility\r\n    if (bookingIds.length > 1) {\r\n      return { \r\n        success: true, \r\n        bookingIds,\r\n        totalAmount,\r\n        bookingId // Keep for backward compatibility\r\n      };\r\n    }\r\n\r\n    return { \r\n      success: true, \r\n      bookingId,\r\n      bookingIds,\r\n      totalAmount\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error creating booking draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize payment for booking(s)\r\n * Accepts either a single bookingId or an array of bookingIds\r\n */\r\nexport async function initializePaymentForBooking(\r\n  bookingIdOrIds: string | string[]\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const bookingIds = Array.isArray(bookingIdOrIds) ? bookingIdOrIds : [bookingIdOrIds];\r\n\r\n    // Get all booking details\r\n    const { data: bookings, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (fetchError || !bookings || bookings.length === 0) {\r\n      return { success: false, error: 'Booking(s) not found' };\r\n    }\r\n\r\n    // Check if all bookings are in pending status\r\n    const nonPendingBookings = bookings.filter(b => b.payment_status !== 'pending');\r\n    if (nonPendingBookings.length > 0) {\r\n      return { success: false, error: 'Some bookings are not in pending payment status' };\r\n    }\r\n\r\n    // Calculate total amount from all bookings (including tip)\r\n    // Note: total_amount in database now includes tip for new bookings\r\n    // For backward compatibility with existing bookings that might not have tip in total_amount, \r\n    // we check and add tip_amount if it's missing\r\n    const totalAmount = bookings.reduce((sum, booking) => {\r\n      const bookingTotal = Number(booking.total_amount) || 0;\r\n      const tipAmount = Number(booking.tip_amount) || 0;\r\n      const baseTotal = Number(booking.subtotal || 0) + Number(booking.service_fee || 0);\r\n      \r\n      // Check if tip is already included in total_amount\r\n      // If total_amount equals baseTotal exactly, then tip is not included, so add it\r\n      // Otherwise, total_amount already includes tip\r\n      if (tipAmount > 0 && Math.abs(bookingTotal - baseTotal) < 0.01) {\r\n        // Tip is not included in total_amount (backward compatibility case)\r\n        return sum + bookingTotal + tipAmount;\r\n      }\r\n      // Tip is already included in total_amount (new bookings)\r\n      return sum + bookingTotal;\r\n    }, 0);\r\n\r\n    // Calculate total credits used across all bookings\r\n    const totalCreditsUsed = bookings.reduce((sum, booking) => {\r\n      return sum + (Number(booking.credits_used) || 0);\r\n    }, 0);\r\n\r\n    // Calculate remaining amount after credits\r\n    const remainingAmount = totalAmount - totalCreditsUsed;\r\n\r\n    // Use the first booking's email and details for payment\r\n    const firstBooking = bookings[0];\r\n\r\n    // If credits fully cover the booking, mark as paid and skip Paystack\r\n    if (remainingAmount <= 0) {\r\n      // Update all bookings to mark as paid\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({\r\n          payment_status: 'paid',\r\n          amount_paid: totalAmount, // Fully paid with credits\r\n          status: 'confirmed', // Auto-confirm when fully paid\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .in('id', bookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating bookings payment status:', updateError);\r\n        return { success: false, error: 'Failed to update booking payment status' };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        // No authorizationUrl - payment fully covered by credits\r\n      };\r\n    }\r\n\r\n    // Partial credit coverage or no credits - proceed with Paystack for remaining amount\r\n    const reference = firstBooking.paystack_reference || `${firstBooking.booking_number}${Date.now()}`;\r\n    \r\n    // Initialize Paystack payment with remaining amount (after credits)\r\n    const paymentResponse = await initializePayment(\r\n      firstBooking.customer_email,\r\n      remainingAmount, // Only charge the remaining amount\r\n      reference,\r\n      {\r\n        booking_ids: bookingIds,\r\n        booking_id: firstBooking.id, // Keep for backward compatibility\r\n        booking_number: firstBooking.booking_number,\r\n        customer_email: firstBooking.customer_email,\r\n        credits_used: totalCreditsUsed, // Include in metadata for tracking\r\n      }\r\n    );\r\n\r\n    if (!paymentResponse.status) {\r\n      return { success: false, error: paymentResponse.message || 'Failed to initialize payment' };\r\n    }\r\n\r\n    // Use the reference that Paystack actually returned (may differ from what we sent)\r\n    const paystackReference = paymentResponse.data.reference;\r\n\r\n    // Update all bookings with the Paystack reference and partial payment from credits\r\n    const { error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        paystack_reference: paystackReference,\r\n        amount_paid: totalCreditsUsed, // Partial payment from credits, Paystack will complete it\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .in('id', bookingIds);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating bookings with Paystack reference:', updateError);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentResponse.data.authorization_url,\r\n      reference: paystackReference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing payment:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get booking by ID\r\n */\r\nexport async function getBooking(bookingId: string): Promise<{\r\n  success: boolean;\r\n  booking?: any;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners for selection\r\n * Optionally filter by service area/suburb\r\n */\r\nexport async function getAvailableCleaners(serviceSuburb?: string): Promise<{\r\n  success: boolean;\r\n  cleaners?: any[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Build query - only filter by is_available if the column exists\r\n    // First, try to get all active cleaners\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = data || [];\r\n\r\n    // Filter by is_available if the column exists (client-side filter as fallback)\r\n    cleaners = cleaners.filter((cleaner) => {\r\n      // If is_available column doesn't exist or is null/undefined, include the cleaner\r\n      // Otherwise, only include if is_available is true\r\n      return cleaner.is_available !== false;\r\n    });\r\n\r\n    // Filter by area if suburb is provided\r\n    // Since PostgreSQL array contains is complex in Supabase, we filter client-side\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        // If cleaner has no areas specified, include them (they serve all areas)\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true;\r\n        }\r\n        // Check if any area matches the suburb (case-insensitive partial match)\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    return { success: true, cleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a cleaner is available for a specific day of the week\r\n * dayOfWeek: 0 = Sunday, 1 = Monday, ..., 6 = Saturday\r\n */\r\nexport async function isCleanerAvailableForDay(cleaner: any, dayOfWeek: number): Promise<boolean> {\r\n  const dayMap: Record<number, keyof typeof cleaner> = {\r\n    0: 'available_sunday',\r\n    1: 'available_monday',\r\n    2: 'available_tuesday',\r\n    3: 'available_wednesday',\r\n    4: 'available_thursday',\r\n    5: 'available_friday',\r\n    6: 'available_saturday',\r\n  };\r\n\r\n  const dayField = dayMap[dayOfWeek];\r\n  return cleaner[dayField] !== false && cleaner.is_available !== false;\r\n}\r\n\r\n/**\r\n * Check if a cleaner has a booking conflict for a specific date and time slot\r\n */\r\nexport async function checkCleanerBookingConflict(\r\n  cleanerId: string,\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Query bookings for this cleaner on the specified date\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Cleaners should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration')\r\n      .eq('preferred_cleaner_id', cleanerId)\r\n      .eq('service_date', serviceDate)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (error) {\r\n      console.error('Error checking booking conflicts:', error);\r\n      return false; // Assume no conflict on error\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      return false; // No bookings, no conflict\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n\r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number'\r\n          ? booking.service_duration\r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        return true; // Conflict found\r\n      }\r\n    }\r\n\r\n    return false; // No conflicts\r\n  } catch (error) {\r\n    console.error('Unexpected error checking booking conflict:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate reliability score for a cleaner (server-side wrapper)\r\n * This calls the database function if available, otherwise calculates client-side\r\n */\r\nexport async function calculateCleanerReliabilityScore(cleanerId: string): Promise<number> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Try to call the database function\r\n    const { data, error } = await supabase.rpc('calculate_cleaner_reliability_score', {\r\n      cleaner_id: cleanerId,\r\n    });\r\n\r\n    if (!error && data !== null) {\r\n      return parseFloat(data.toString());\r\n    }\r\n\r\n    // Fallback: fetch cleaner and calculate client-side\r\n    const { data: cleaner, error: fetchError } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('id', cleanerId)\r\n      .single();\r\n\r\n    if (fetchError || !cleaner) {\r\n      return 50.0; // Default score\r\n    }\r\n\r\n    return calculateReliabilityScore(cleaner as Cleaner);\r\n  } catch (error) {\r\n    console.error('Error calculating reliability score:', error);\r\n    return 50.0; // Default score on error\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners with enhanced filtering criteria\r\n * Filters by: Location, Availability, Booking conflicts\r\n * Sorts by: Reliability Score, Rating\r\n */\r\nexport async function getAvailableCleanersWithCriteria(params: {\r\n  serviceSuburb?: string;\r\n  serviceDate?: string;\r\n  serviceTime?: string;\r\n  serviceDuration?: number;\r\n  minRating?: number;\r\n  minReliabilityScore?: number;\r\n}): Promise<{\r\n  success: boolean;\r\n  cleaners?: CleanerWithAvailability[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const {\r\n      serviceSuburb,\r\n      serviceDate,\r\n      serviceTime,\r\n      serviceDuration = 3,\r\n      minRating = 0,\r\n      minReliabilityScore = 0,\r\n    } = params;\r\n\r\n    // Build base query\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query.order('reliability_score', { ascending: false, nullsFirst: false })\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = (data || []) as Cleaner[];\r\n\r\n    // Filter by is_available\r\n    cleaners = cleaners.filter((cleaner) => cleaner.is_available !== false);\r\n\r\n    // Filter by location (suburb)\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true; // Serve all areas\r\n        }\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Filter by day of week availability if date is provided\r\n    if (serviceDate) {\r\n      const date = new Date(serviceDate);\r\n      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        const dayMap: Record<number, keyof Cleaner> = {\r\n          0: 'available_sunday',\r\n          1: 'available_monday',\r\n          2: 'available_tuesday',\r\n          3: 'available_wednesday',\r\n          4: 'available_thursday',\r\n          5: 'available_friday',\r\n          6: 'available_saturday',\r\n        };\r\n        const dayField = dayMap[dayOfWeek];\r\n        return cleaner[dayField] !== false;\r\n      });\r\n    }\r\n\r\n    // Filter by minimum rating\r\n    if (minRating > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.rating || 0) >= minRating);\r\n    }\r\n\r\n    // Filter by minimum reliability score\r\n    if (minReliabilityScore > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.reliability_score || 0) >= minReliabilityScore);\r\n    }\r\n\r\n    // Enrich cleaners with availability and booking conflict information\r\n    const enrichedCleaners: CleanerWithAvailability[] = await Promise.all(\r\n      cleaners.map(async (cleaner) => {\r\n        let isAvailableForSlot = true;\r\n        let bookingConflict = false;\r\n\r\n        // Check booking conflict if date and time are provided\r\n        if (serviceDate && serviceTime && serviceDuration) {\r\n          bookingConflict = await checkCleanerBookingConflict(\r\n            cleaner.id,\r\n            serviceDate,\r\n            serviceTime,\r\n            serviceDuration\r\n          );\r\n          isAvailableForSlot = !bookingConflict;\r\n        }\r\n\r\n        // Calculate reliability score if not present\r\n        const reliabilityScore = cleaner.reliability_score ?? calculateReliabilityScore(cleaner);\r\n\r\n        return {\r\n          ...cleaner,\r\n          reliability_score: reliabilityScore,\r\n          isAvailableForSlot,\r\n          bookingConflict,\r\n          completionRate: calculateCompletionRate(cleaner),\r\n          onTimeRate: calculateOnTimeRate(cleaner),\r\n        };\r\n      })\r\n    );\r\n\r\n    // Sort by reliability score and rating (already sorted by query, but ensure consistency)\r\n    enrichedCleaners.sort((a, b) => {\r\n      const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n      const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n\r\n    return { success: true, cleaners: enrichedCleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners with criteria:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAwCsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,8DAAA"}},
    {"offset": {"line": 766, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/book/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { BookingFormData, BookingCreateInput, WorkingHour, TimeSlotAvailability, Cleaner, CleanerWithAvailability } from '@/types/booking';\r\nimport { calculatePrice } from '@/lib/pricing/calculator';\r\nimport { generateBookingNumber } from '@/lib/utils/booking-number';\r\nimport { initializePayment } from '@/lib/paystack/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { calculateReliabilityScore, calculateCompletionRate, calculateOnTimeRate } from '@/lib/utils/cleaner-utils';\r\nimport { calculateBookingDatesForMonth, calculateNextBookingDate, formatDateForDB } from '@/lib/utils/recurring-dates';\r\nimport { isValidFrequencyForService, requiresTeamBooking } from '@/lib/utils/service-validation';\r\n\r\n/**\r\n * Get available working hours (30-minute interval start times)\r\n */\r\nexport async function getWorkingHours(): Promise<WorkingHour[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('working_hours')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as WorkingHour[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get working hours from home_detail_options (backward compatibility)\r\n */\r\nexport async function getWorkingHoursFromOptions(): Promise<Array<{ value: string; label: string }>> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('value, label')\r\n      .eq('option_type', 'working_hours')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours from options:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []).map((item) => ({\r\n      value: item.value,\r\n      label: item.label,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours from options:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check cleaner availability for a specific date and time slot\r\n * Returns availability status and count of available cleaners\r\n */\r\nexport async function checkCleanerAvailabilityForSlot(\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<TimeSlotAvailability> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, check if any active cleaners exist in the system\r\n    const { data: activeCleaners, error: cleanersError } = await supabase\r\n      .from('cleaners')\r\n      .select('id')\r\n      .eq('is_active', true);\r\n\r\n    if (cleanersError) {\r\n      console.error('Error checking active cleaners:', cleanersError);\r\n      // If we can't check cleaners, assume unavailable for safety\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    // If no active cleaners exist, no slots are available\r\n    if (!activeCleaners || activeCleaners.length === 0) {\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    const totalCleaners = activeCleaners.length;\r\n\r\n    // Query bookings for the specified date that might overlap\r\n    // We need to check for bookings where:\r\n    // (booking_start_time < new_end_time) AND (booking_end_time > new_start_time)\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid, cancelled/completed)\r\n    // Cleaners should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration, preferred_cleaner_id, preferred_cleaner_ids, number_of_cleaners')\r\n      .eq('service_date', serviceDate)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking bookings:', bookingsError);\r\n      // If we can't check bookings, assume available (optimistic approach)\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      // No bookings for this date, all cleaners are available\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Track which cleaners are booked (by ID)\r\n    const bookedCleanerIds = new Set<string>();\r\n    \r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n      \r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number' \r\n          ? booking.service_duration \r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        // There's an overlap\r\n        // Check preferred_cleaner_ids first (new multi-cleaner support)\r\n        if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n          // Multiple cleaners are assigned\r\n          booking.preferred_cleaner_ids.forEach((cleanerId: string) => {\r\n            if (cleanerId) bookedCleanerIds.add(cleanerId);\r\n          });\r\n        } else if (booking.preferred_cleaner_id) {\r\n          // Single cleaner assigned (backward compatibility)\r\n          bookedCleanerIds.add(booking.preferred_cleaner_id);\r\n        } else {\r\n          // If no preferred cleaner, use number_of_cleaners to count generic cleaner slots\r\n          // This handles bookings without specific cleaner assignments\r\n          const numCleaners = booking.number_of_cleaners || 1;\r\n          // We don't add specific IDs here, but count them in bookingsWithoutPreferredCleaner\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate available cleaners\r\n    // Count bookings without preferred cleaners (generic assignments)\r\n    // These use number_of_cleaners to determine how many cleaner slots are taken\r\n    const bookingsWithoutPreferredCleaner = bookings.filter(\r\n      (b) => {\r\n        const hasPreferredCleaners = (b.preferred_cleaner_ids && Array.isArray(b.preferred_cleaner_ids) && b.preferred_cleaner_ids.length > 0) || b.preferred_cleaner_id;\r\n        if (hasPreferredCleaners) return false;\r\n        \r\n        // Check for time overlap\r\n        const [hours, mins] = b.service_time.split(':').slice(0, 2).map(Number);\r\n        const start = hours * 60 + mins;\r\n        const duration = Math.round((typeof b.service_duration === 'number' ? b.service_duration : parseFloat(b.service_duration || '0')) * 60);\r\n        const end = start + duration;\r\n        return newStartTimeMinutes < end && newEndTimeMinutes > start;\r\n      }\r\n    ).reduce((sum, b) => {\r\n      // Sum up the number_of_cleaners for bookings without preferred cleaners\r\n      return sum + (b.number_of_cleaners || 1);\r\n    }, 0);\r\n\r\n    const unavailableCleaners = bookedCleanerIds.size + bookingsWithoutPreferredCleaner;\r\n    const availableCleanersCount = Math.max(0, totalCleaners - unavailableCleaners);\r\n\r\n    return {\r\n      available: availableCleanersCount > 0,\r\n      availableCleanersCount,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking cleaner availability:', error);\r\n    // On error, assume unavailable for safety\r\n    return { available: false, availableCleanersCount: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Check team availability for a specific date for team-based services\r\n * Returns which teams (1, 2, or 3) are available and which are booked\r\n */\r\nexport async function checkTeamAvailabilityForDate(\r\n  serviceDate: string,\r\n  serviceType: string\r\n): Promise<{\r\n  availableTeams: number[];\r\n  bookedTeams: number[];\r\n  allTeamsBooked: boolean;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Only check for team-based services (Deep Cleaning and Move In/Out)\r\n    if (!requiresTeamBooking(serviceType)) {\r\n      return {\r\n        availableTeams: [],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Query bookings for the specified date and service type\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Teams should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('team_number')\r\n      .eq('service_date', serviceDate)\r\n      .eq('service_type', serviceType)\r\n      .not('team_number', 'is', null)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking team bookings:', bookingsError);\r\n      // If we can't check bookings, assume all teams available (optimistic approach)\r\n      return {\r\n        availableTeams: [1, 2, 3],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Extract booked team numbers\r\n    const bookedTeams = (bookings || [])\r\n      .map((booking) => booking.team_number)\r\n      .filter((teamNumber): teamNumber is number => teamNumber !== null && teamNumber >= 1 && teamNumber <= 3);\r\n\r\n    // Get unique booked teams (in case of duplicates)\r\n    const bookedTeamsSet = new Set(bookedTeams);\r\n\r\n    // Calculate available teams (1, 2, 3 minus booked teams)\r\n    const allTeams = [1, 2, 3];\r\n    const availableTeams = allTeams.filter((team) => !bookedTeamsSet.has(team));\r\n\r\n    return {\r\n      availableTeams,\r\n      bookedTeams: Array.from(bookedTeamsSet),\r\n      allTeamsBooked: availableTeams.length === 0,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking team availability:', error);\r\n    // On error, assume all teams available for safety (let database constraint catch duplicates)\r\n    return {\r\n      availableTeams: [1, 2, 3],\r\n      bookedTeams: [],\r\n      allTeamsBooked: false,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check availability for all time slots for a given date\r\n */\r\nexport async function checkAvailabilityForAllSlots(\r\n  serviceDate: string,\r\n  workingHours: WorkingHour[],\r\n  serviceDuration: number,\r\n  serviceType?: string\r\n): Promise<Record<string, TimeSlotAvailability>> {\r\n  const availability: Record<string, TimeSlotAvailability> = {};\r\n\r\n  // If service requires team booking, check team availability instead\r\n  if (serviceType && requiresTeamBooking(serviceType)) {\r\n    const teamAvailability = await checkTeamAvailabilityForDate(serviceDate, serviceType);\r\n    \r\n    // For team-based services, availability is day-based, not time-based\r\n    // If all teams are booked, all slots are unavailable\r\n    // Otherwise, slots are available (but we'll show team selection in UI)\r\n    const slotsAvailable = !teamAvailability.allTeamsBooked;\r\n    const availableTeamsCount = teamAvailability.availableTeams.length;\r\n    \r\n    // Set same availability for all time slots\r\n    workingHours.forEach((hour) => {\r\n      availability[hour.start_time] = {\r\n        available: slotsAvailable,\r\n        availableCleanersCount: availableTeamsCount,\r\n      };\r\n    });\r\n\r\n    return availability;\r\n  }\r\n\r\n  // For regular services, check individual cleaner availability per time slot\r\n  const promises = workingHours.map(async (hour) => {\r\n    const slotAvailability = await checkCleanerAvailabilityForSlot(\r\n      serviceDate,\r\n      hour.start_time,\r\n      serviceDuration\r\n    );\r\n    return { time: hour.start_time, availability: slotAvailability };\r\n  });\r\n\r\n  const results = await Promise.all(promises);\r\n  \r\n  results.forEach(({ time, availability: avail }) => {\r\n    availability[time] = avail;\r\n  });\r\n\r\n  return availability;\r\n}\r\n\r\n/**\r\n * Validate discount code\r\n */\r\nexport async function validateDiscountCode(code: string, subtotal: number): Promise<{\r\n  valid: boolean;\r\n  discountAmount: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (!code || !code.trim()) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('discount_codes')\r\n      .select('*')\r\n      .eq('code', code.trim().toUpperCase())\r\n      .eq('is_active', true)\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      return { valid: false, discountAmount: 0, error: 'Invalid discount code' };\r\n    }\r\n\r\n    // Check validity dates\r\n    const now = new Date();\r\n    const validFrom = new Date(data.valid_from);\r\n    const validUntil = new Date(data.valid_until);\r\n\r\n    if (now < validFrom || now > validUntil) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has expired' };\r\n    }\r\n\r\n    // Check max uses\r\n    if (data.max_uses && data.used_count >= data.max_uses) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has reached maximum uses' };\r\n    }\r\n\r\n    // Check min purchase amount\r\n    if (data.min_purchase_amount && subtotal < data.min_purchase_amount) {\r\n      return { \r\n        valid: false, \r\n        discountAmount: 0, \r\n        error: `Minimum purchase amount of R${data.min_purchase_amount} required` \r\n      };\r\n    }\r\n\r\n    // Calculate discount amount\r\n    let discountAmount = 0;\r\n    if (data.discount_type === 'percentage') {\r\n      discountAmount = (subtotal * data.discount_value) / 100;\r\n      if (data.max_discount_amount && discountAmount > data.max_discount_amount) {\r\n        discountAmount = data.max_discount_amount;\r\n      }\r\n    } else {\r\n      discountAmount = data.discount_value;\r\n    }\r\n\r\n    // Ensure discount doesn't exceed subtotal\r\n    discountAmount = Math.min(discountAmount, subtotal);\r\n\r\n    return { valid: true, discountAmount };\r\n  } catch (error) {\r\n    console.error('Error validating discount code:', error);\r\n    return { valid: false, discountAmount: 0, error: 'Error validating discount code' };\r\n  }\r\n}\r\n\r\n/**\r\n * Create booking draft (before payment)\r\n */\r\nexport async function createBookingDraft(formData: BookingFormData): Promise<{\r\n  success: boolean;\r\n  bookingId?: string;\r\n  bookingIds?: string[];\r\n  totalAmount?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current user if logged in\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n    const userId = user?.id || null;\r\n\r\n    // Get service name\r\n    const { data: service } = await supabase\r\n      .from('services')\r\n      .select('name')\r\n      .eq('id', formData.serviceId)\r\n      .single();\r\n\r\n    if (!service) {\r\n      return { success: false, error: 'Service not found' };\r\n    }\r\n\r\n    // Validate that the selected frequency is valid for this service\r\n    if (!isValidFrequencyForService(service.name, formData.cleaningFrequency)) {\r\n      return { \r\n        success: false, \r\n        error: `Recurring bookings are only available for Standard Cleaning and Airbnb Cleaning services. Selected service: ${service.name}` \r\n      };\r\n    }\r\n\r\n    // Check if service requires team booking\r\n    const isTeamBooking = requiresTeamBooking(service.name);\r\n\r\n    // Validate team booking requirements\r\n    if (isTeamBooking) {\r\n      if (!formData.teamNumber || (formData.teamNumber < 1 || formData.teamNumber > 3)) {\r\n        return {\r\n          success: false,\r\n          error: 'Please select a team (1, 2, or 3) for this service',\r\n        };\r\n      }\r\n\r\n      // Check team availability for each booking date\r\n      const startDate = new Date(formData.serviceDate);\r\n      const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n      \r\n      for (const bookingDate of bookingDates) {\r\n        const teamAvailability = await checkTeamAvailabilityForDate(\r\n          formatDateForDB(bookingDate),\r\n          service.name\r\n        );\r\n        \r\n        if (!teamAvailability.availableTeams.includes(formData.teamNumber!)) {\r\n          const dateStr = formatDateForDB(bookingDate);\r\n          return {\r\n            success: false,\r\n            error: `Team ${formData.teamNumber} is already booked for ${dateStr}. Please select a different team or date.`,\r\n          };\r\n        }\r\n      }\r\n    } else {\r\n      // For non-team bookings, ensure teamNumber is not set\r\n      if (formData.teamNumber !== null && formData.teamNumber !== undefined) {\r\n        return {\r\n          success: false,\r\n          error: 'Team selection is only available for Deep Cleaning and Move In/Out services',\r\n        };\r\n      }\r\n    }\r\n\r\n    // Calculate pricing\r\n    const priceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount: 0, // Will calculate discount in next step\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Apply discount code if provided\r\n    let discountAmount = 0;\r\n    if (formData.discountCode) {\r\n      const discountValidation = await validateDiscountCode(\r\n        formData.discountCode,\r\n        priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount\r\n      );\r\n      if (discountValidation.valid) {\r\n        discountAmount = discountValidation.discountAmount;\r\n      }\r\n    }\r\n\r\n    // Recalculate with discount\r\n    const finalPriceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount,\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Determine if this is a recurring booking\r\n    // Note: Team-based services (Deep Cleaning and Move In/Out) don't support recurring bookings\r\n    // but we'll handle it gracefully if somehow a recurring frequency is selected\r\n    const isRecurring = formData.cleaningFrequency !== 'one-time';\r\n\r\n    // Calculate booking dates based on frequency\r\n    const startDate = new Date(formData.serviceDate);\r\n    const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n\r\n    // Calculate next booking date for recurring bookings\r\n    let nextBookingDate: Date | null = null;\r\n    if (isRecurring && bookingDates.length > 0) {\r\n      const lastDate = bookingDates[bookingDates.length - 1];\r\n      nextBookingDate = calculateNextBookingDate(lastDate, formData.cleaningFrequency);\r\n    }\r\n\r\n    // Create bookings for all dates\r\n    const bookingsToCreate: BookingCreateInput[] = [];\r\n\r\n    for (let i = 0; i < bookingDates.length; i++) {\r\n      const bookingDate = bookingDates[i];\r\n      const bookingNumber = generateBookingNumber();\r\n\r\n      // Tip is only applied to the first booking in a recurring series (one-time payment)\r\n      const tipAmount = (i === 0) ? (formData.tipAmount || 0) : 0;\r\n      \r\n      const bookingInput: BookingCreateInput = {\r\n        booking_number: bookingNumber,\r\n        customer_first_name: formData.customerFirstName,\r\n        customer_last_name: formData.customerLastName,\r\n        customer_email: formData.customerEmail,\r\n        customer_phone: formData.customerPhone,\r\n        service_id: formData.serviceId,\r\n        service_type: service.name,\r\n        bedrooms: formData.bedrooms,\r\n        bathrooms: formData.bathrooms,\r\n        additional_services: formData.additionalServices,\r\n        cleaning_equipment: formData.cleaningEquipment,\r\n        preferred_cleaner_ids: isTeamBooking \r\n          ? null // Team bookings don't have preferred cleaners\r\n          : (formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n            ? formData.preferredCleanerIds \r\n            : null),\r\n        preferred_cleaner_id: isTeamBooking\r\n          ? null // Team bookings don't have preferred cleaners\r\n          : (formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n            ? formData.preferredCleanerIds[0] \r\n            : null), // Backward compatibility: set to first cleaner\r\n        team_number: isTeamBooking && formData.teamNumber ? formData.teamNumber : null,\r\n        cleaning_frequency: formData.cleaningFrequency,\r\n        service_date: formatDateForDB(bookingDate),\r\n        service_time: formData.serviceTime,\r\n        service_duration: formData.serviceDuration,\r\n        service_address: formData.serviceAddress,\r\n        service_apt_unit: formData.serviceAptUnit || null,\r\n        service_suburb: formData.serviceSuburb,\r\n        service_city: formData.serviceCity,\r\n        special_instructions: formData.specialInstructions || null,\r\n        tip_amount: tipAmount,\r\n        base_price: finalPriceBreakdown.basePrice,\r\n        additional_services_price: finalPriceBreakdown.additionalServicesPrice,\r\n        equipment_supply_price: finalPriceBreakdown.equipmentSupplyPrice,\r\n        number_of_cleaners: formData.numberOfCleaners || 1,\r\n        additional_cleaners_price: finalPriceBreakdown.additionalCleanersPrice,\r\n        frequency_discount_percent: finalPriceBreakdown.frequencyDiscountPercent,\r\n        frequency_discount_amount: finalPriceBreakdown.frequencyDiscountAmount,\r\n        subtotal: finalPriceBreakdown.subtotal,\r\n        service_fee: finalPriceBreakdown.serviceFee,\r\n        total_amount: finalPriceBreakdown.totalAmount + tipAmount,\r\n        discount_code: formData.discountCode || null,\r\n        discount_amount: discountAmount,\r\n        referral_code: formData.referralCode || null,\r\n        amount_paid: 0,\r\n        payment_status: 'pending',\r\n        status: 'pending',\r\n        user_id: userId,\r\n        parent_booking_id: null, // Will be updated after first booking is created\r\n        is_recurring: isRecurring,\r\n        recurrence_status: isRecurring ? 'active' : undefined,\r\n        next_booking_date: i === 0 && isRecurring && nextBookingDate ? formatDateForDB(nextBookingDate) : null,\r\n        credits_used: 0, // Will be updated when credits are used during payment\r\n      };\r\n\r\n      bookingsToCreate.push(bookingInput);\r\n    }\r\n\r\n    // Insert all bookings\r\n    const { data: insertedBookings, error } = await supabase\r\n      .from('bookings')\r\n      .insert(bookingsToCreate)\r\n      .select('id, total_amount');\r\n\r\n    if (error) {\r\n      console.error('Error creating booking drafts:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!insertedBookings || insertedBookings.length === 0) {\r\n      return { success: false, error: 'Failed to create bookings' };\r\n    }\r\n\r\n    // Update parent_booking_id for subsequent bookings if there are multiple\r\n    if (insertedBookings.length > 1 && isRecurring) {\r\n      const firstBookingId = insertedBookings[0].id;\r\n      const subsequentBookingIds = insertedBookings.slice(1).map(b => b.id);\r\n      \r\n      // Update all subsequent bookings to reference the first one\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({ parent_booking_id: firstBookingId })\r\n        .in('id', subsequentBookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating parent_booking_id:', updateError);\r\n        // Don't fail, but log the error\r\n      }\r\n    }\r\n\r\n    // Calculate total amount\r\n    const totalAmount = insertedBookings.reduce((sum, booking) => sum + Number(booking.total_amount), 0);\r\n    const bookingIds = insertedBookings.map(booking => booking.id);\r\n\r\n    // For backward compatibility, also return single bookingId\r\n    const bookingId = bookingIds[0];\r\n\r\n    // If multiple bookings, return array; otherwise return single ID for backward compatibility\r\n    if (bookingIds.length > 1) {\r\n      return { \r\n        success: true, \r\n        bookingIds,\r\n        totalAmount,\r\n        bookingId // Keep for backward compatibility\r\n      };\r\n    }\r\n\r\n    return { \r\n      success: true, \r\n      bookingId,\r\n      bookingIds,\r\n      totalAmount\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error creating booking draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize payment for booking(s)\r\n * Accepts either a single bookingId or an array of bookingIds\r\n */\r\nexport async function initializePaymentForBooking(\r\n  bookingIdOrIds: string | string[]\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const bookingIds = Array.isArray(bookingIdOrIds) ? bookingIdOrIds : [bookingIdOrIds];\r\n\r\n    // Get all booking details\r\n    const { data: bookings, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (fetchError || !bookings || bookings.length === 0) {\r\n      return { success: false, error: 'Booking(s) not found' };\r\n    }\r\n\r\n    // Check if all bookings are in pending status\r\n    const nonPendingBookings = bookings.filter(b => b.payment_status !== 'pending');\r\n    if (nonPendingBookings.length > 0) {\r\n      return { success: false, error: 'Some bookings are not in pending payment status' };\r\n    }\r\n\r\n    // Calculate total amount from all bookings (including tip)\r\n    // Note: total_amount in database now includes tip for new bookings\r\n    // For backward compatibility with existing bookings that might not have tip in total_amount, \r\n    // we check and add tip_amount if it's missing\r\n    const totalAmount = bookings.reduce((sum, booking) => {\r\n      const bookingTotal = Number(booking.total_amount) || 0;\r\n      const tipAmount = Number(booking.tip_amount) || 0;\r\n      const baseTotal = Number(booking.subtotal || 0) + Number(booking.service_fee || 0);\r\n      \r\n      // Check if tip is already included in total_amount\r\n      // If total_amount equals baseTotal exactly, then tip is not included, so add it\r\n      // Otherwise, total_amount already includes tip\r\n      if (tipAmount > 0 && Math.abs(bookingTotal - baseTotal) < 0.01) {\r\n        // Tip is not included in total_amount (backward compatibility case)\r\n        return sum + bookingTotal + tipAmount;\r\n      }\r\n      // Tip is already included in total_amount (new bookings)\r\n      return sum + bookingTotal;\r\n    }, 0);\r\n\r\n    // Calculate total credits used across all bookings\r\n    const totalCreditsUsed = bookings.reduce((sum, booking) => {\r\n      return sum + (Number(booking.credits_used) || 0);\r\n    }, 0);\r\n\r\n    // Calculate remaining amount after credits\r\n    const remainingAmount = totalAmount - totalCreditsUsed;\r\n\r\n    // Use the first booking's email and details for payment\r\n    const firstBooking = bookings[0];\r\n\r\n    // If credits fully cover the booking, mark as paid and skip Paystack\r\n    if (remainingAmount <= 0) {\r\n      // Update all bookings to mark as paid\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({\r\n          payment_status: 'paid',\r\n          amount_paid: totalAmount, // Fully paid with credits\r\n          status: 'confirmed', // Auto-confirm when fully paid\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .in('id', bookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating bookings payment status:', updateError);\r\n        return { success: false, error: 'Failed to update booking payment status' };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        // No authorizationUrl - payment fully covered by credits\r\n      };\r\n    }\r\n\r\n    // Partial credit coverage or no credits - proceed with Paystack for remaining amount\r\n    const reference = firstBooking.paystack_reference || `${firstBooking.booking_number}${Date.now()}`;\r\n    \r\n    // Initialize Paystack payment with remaining amount (after credits)\r\n    const paymentResponse = await initializePayment(\r\n      firstBooking.customer_email,\r\n      remainingAmount, // Only charge the remaining amount\r\n      reference,\r\n      {\r\n        booking_ids: bookingIds,\r\n        booking_id: firstBooking.id, // Keep for backward compatibility\r\n        booking_number: firstBooking.booking_number,\r\n        customer_email: firstBooking.customer_email,\r\n        credits_used: totalCreditsUsed, // Include in metadata for tracking\r\n      }\r\n    );\r\n\r\n    if (!paymentResponse.status) {\r\n      return { success: false, error: paymentResponse.message || 'Failed to initialize payment' };\r\n    }\r\n\r\n    // Use the reference that Paystack actually returned (may differ from what we sent)\r\n    const paystackReference = paymentResponse.data.reference;\r\n\r\n    // Update all bookings with the Paystack reference and partial payment from credits\r\n    const { error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        paystack_reference: paystackReference,\r\n        amount_paid: totalCreditsUsed, // Partial payment from credits, Paystack will complete it\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .in('id', bookingIds);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating bookings with Paystack reference:', updateError);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentResponse.data.authorization_url,\r\n      reference: paystackReference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing payment:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get booking by ID\r\n */\r\nexport async function getBooking(bookingId: string): Promise<{\r\n  success: boolean;\r\n  booking?: any;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners for selection\r\n * Optionally filter by service area/suburb\r\n */\r\nexport async function getAvailableCleaners(serviceSuburb?: string): Promise<{\r\n  success: boolean;\r\n  cleaners?: any[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Build query - only filter by is_available if the column exists\r\n    // First, try to get all active cleaners\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = data || [];\r\n\r\n    // Filter by is_available if the column exists (client-side filter as fallback)\r\n    cleaners = cleaners.filter((cleaner) => {\r\n      // If is_available column doesn't exist or is null/undefined, include the cleaner\r\n      // Otherwise, only include if is_available is true\r\n      return cleaner.is_available !== false;\r\n    });\r\n\r\n    // Filter by area if suburb is provided\r\n    // Since PostgreSQL array contains is complex in Supabase, we filter client-side\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        // If cleaner has no areas specified, include them (they serve all areas)\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true;\r\n        }\r\n        // Check if any area matches the suburb (case-insensitive partial match)\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    return { success: true, cleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a cleaner is available for a specific day of the week\r\n * dayOfWeek: 0 = Sunday, 1 = Monday, ..., 6 = Saturday\r\n */\r\nexport async function isCleanerAvailableForDay(cleaner: any, dayOfWeek: number): Promise<boolean> {\r\n  const dayMap: Record<number, keyof typeof cleaner> = {\r\n    0: 'available_sunday',\r\n    1: 'available_monday',\r\n    2: 'available_tuesday',\r\n    3: 'available_wednesday',\r\n    4: 'available_thursday',\r\n    5: 'available_friday',\r\n    6: 'available_saturday',\r\n  };\r\n\r\n  const dayField = dayMap[dayOfWeek];\r\n  return cleaner[dayField] !== false && cleaner.is_available !== false;\r\n}\r\n\r\n/**\r\n * Check if a cleaner has a booking conflict for a specific date and time slot\r\n */\r\nexport async function checkCleanerBookingConflict(\r\n  cleanerId: string,\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Query bookings for this cleaner on the specified date\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Cleaners should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration')\r\n      .eq('preferred_cleaner_id', cleanerId)\r\n      .eq('service_date', serviceDate)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (error) {\r\n      console.error('Error checking booking conflicts:', error);\r\n      return false; // Assume no conflict on error\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      return false; // No bookings, no conflict\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n\r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number'\r\n          ? booking.service_duration\r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        return true; // Conflict found\r\n      }\r\n    }\r\n\r\n    return false; // No conflicts\r\n  } catch (error) {\r\n    console.error('Unexpected error checking booking conflict:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate reliability score for a cleaner (server-side wrapper)\r\n * This calls the database function if available, otherwise calculates client-side\r\n */\r\nexport async function calculateCleanerReliabilityScore(cleanerId: string): Promise<number> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Try to call the database function\r\n    const { data, error } = await supabase.rpc('calculate_cleaner_reliability_score', {\r\n      cleaner_id: cleanerId,\r\n    });\r\n\r\n    if (!error && data !== null) {\r\n      return parseFloat(data.toString());\r\n    }\r\n\r\n    // Fallback: fetch cleaner and calculate client-side\r\n    const { data: cleaner, error: fetchError } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('id', cleanerId)\r\n      .single();\r\n\r\n    if (fetchError || !cleaner) {\r\n      return 50.0; // Default score\r\n    }\r\n\r\n    return calculateReliabilityScore(cleaner as Cleaner);\r\n  } catch (error) {\r\n    console.error('Error calculating reliability score:', error);\r\n    return 50.0; // Default score on error\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners with enhanced filtering criteria\r\n * Filters by: Location, Availability, Booking conflicts\r\n * Sorts by: Reliability Score, Rating\r\n */\r\nexport async function getAvailableCleanersWithCriteria(params: {\r\n  serviceSuburb?: string;\r\n  serviceDate?: string;\r\n  serviceTime?: string;\r\n  serviceDuration?: number;\r\n  minRating?: number;\r\n  minReliabilityScore?: number;\r\n}): Promise<{\r\n  success: boolean;\r\n  cleaners?: CleanerWithAvailability[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const {\r\n      serviceSuburb,\r\n      serviceDate,\r\n      serviceTime,\r\n      serviceDuration = 3,\r\n      minRating = 0,\r\n      minReliabilityScore = 0,\r\n    } = params;\r\n\r\n    // Build base query\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query.order('reliability_score', { ascending: false, nullsFirst: false })\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = (data || []) as Cleaner[];\r\n\r\n    // Filter by is_available\r\n    cleaners = cleaners.filter((cleaner) => cleaner.is_available !== false);\r\n\r\n    // Filter by location (suburb)\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true; // Serve all areas\r\n        }\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Filter by day of week availability if date is provided\r\n    if (serviceDate) {\r\n      const date = new Date(serviceDate);\r\n      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        const dayMap: Record<number, keyof Cleaner> = {\r\n          0: 'available_sunday',\r\n          1: 'available_monday',\r\n          2: 'available_tuesday',\r\n          3: 'available_wednesday',\r\n          4: 'available_thursday',\r\n          5: 'available_friday',\r\n          6: 'available_saturday',\r\n        };\r\n        const dayField = dayMap[dayOfWeek];\r\n        return cleaner[dayField] !== false;\r\n      });\r\n    }\r\n\r\n    // Filter by minimum rating\r\n    if (minRating > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.rating || 0) >= minRating);\r\n    }\r\n\r\n    // Filter by minimum reliability score\r\n    if (minReliabilityScore > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.reliability_score || 0) >= minReliabilityScore);\r\n    }\r\n\r\n    // Enrich cleaners with availability and booking conflict information\r\n    const enrichedCleaners: CleanerWithAvailability[] = await Promise.all(\r\n      cleaners.map(async (cleaner) => {\r\n        let isAvailableForSlot = true;\r\n        let bookingConflict = false;\r\n\r\n        // Check booking conflict if date and time are provided\r\n        if (serviceDate && serviceTime && serviceDuration) {\r\n          bookingConflict = await checkCleanerBookingConflict(\r\n            cleaner.id,\r\n            serviceDate,\r\n            serviceTime,\r\n            serviceDuration\r\n          );\r\n          isAvailableForSlot = !bookingConflict;\r\n        }\r\n\r\n        // Calculate reliability score if not present\r\n        const reliabilityScore = cleaner.reliability_score ?? calculateReliabilityScore(cleaner);\r\n\r\n        return {\r\n          ...cleaner,\r\n          reliability_score: reliabilityScore,\r\n          isAvailableForSlot,\r\n          bookingConflict,\r\n          completionRate: calculateCompletionRate(cleaner),\r\n          onTimeRate: calculateOnTimeRate(cleaner),\r\n        };\r\n      })\r\n    );\r\n\r\n    // Sort by reliability score and rating (already sorted by query, but ensure consistency)\r\n    enrichedCleaners.sort((a, b) => {\r\n      const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n      const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n\r\n    return { success: true, cleaners: enrichedCleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners with criteria:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAwRsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 780, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/icon-mapper.ts"],"sourcesContent":["import {\r\n  Home,\r\n  Star,\r\n  Calendar,\r\n  Building2,\r\n  Armchair,\r\n  Grid3X3,\r\n  Layers,\r\n  LayoutGrid,\r\n  Refrigerator,\r\n  CookingPot,\r\n  Shirt,\r\n  WashingMachine,\r\n  Bed,\r\n  Wind,\r\n  LucideIcon,\r\n} from \"lucide-react\";\r\n\r\n// Map icon name strings to Lucide React icon components\r\nconst iconMap: Record<string, LucideIcon> = {\r\n  Home,\r\n  Star,\r\n  Calendar,\r\n  Building2,\r\n  Armchair,\r\n  Grid3X3,\r\n  Layers,\r\n  LayoutGrid,\r\n  Refrigerator,\r\n  CookingPot,\r\n  Shirt,\r\n  WashingMachine,\r\n  Bed,\r\n  Wind,\r\n};\r\n\r\n/**\r\n * Get a Lucide icon component by its name\r\n * @param iconName - The name of the icon (e.g., \"Home\", \"Star\")\r\n * @returns The icon component or a default icon if not found\r\n */\r\nexport function getIcon(iconName: string): LucideIcon {\r\n  const icon = iconMap[iconName];\r\n  if (!icon) {\r\n    console.warn(`Icon \"${iconName}\" not found in icon map. Using Home as fallback.`);\r\n    return Home; // Default fallback icon\r\n  }\r\n  return icon;\r\n}\r\n\r\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAkBA,wDAAwD;AACxD,MAAM,UAAsC;IAC1C,MAAA,2MAAI;IACJ,MAAA,0MAAI;IACJ,UAAA,sNAAQ;IACR,WAAA,6NAAS;IACT,UAAA,sNAAQ;IACR,SAAA,uNAAO;IACP,QAAA,gNAAM;IACN,YAAA,gOAAU;IACV,cAAA,kOAAY;IACZ,YAAA,gOAAU;IACV,OAAA,6MAAK;IACL,gBAAA,4OAAc;IACd,KAAA,uMAAG;IACH,MAAA,0MAAI;AACN;AAOO,SAAS,QAAQ,QAAgB;IACtC,MAAM,OAAO,OAAO,CAAC,SAAS;IAC9B,IAAI,CAAC,MAAM;QACT,QAAQ,IAAI,CAAC,CAAC,MAAM,EAAE,SAAS,gDAAgD,CAAC;QAChF,OAAO,2MAAI,EAAE,wBAAwB;IACvC;IACA,OAAO;AACT"}},
    {"offset": {"line": 828, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/utils/duration-calculator.ts"],"sourcesContent":["/**\r\n * Calculate service duration based on bedrooms, bathrooms, and additional services\r\n * \r\n * Formula:\r\n * - Base: 3.5 hours\r\n * - Per bedroom: +0.5 hours\r\n * - Per bathroom: +0.5 hours\r\n * - Per extra service: +0.5 hours\r\n * \r\n * Result is clamped between 3.5 (minimum) and 10 (maximum) hours\r\n * \r\n * @param bedrooms - Number of bedrooms as string (e.g., '0', '1', '2')\r\n * @param bathrooms - Number of bathrooms as string (e.g., '1', '2', '3')\r\n * @param additionalServices - Array of additional service IDs\r\n * @returns Calculated duration in hours (clamped between 3.5 and 10)\r\n */\r\nexport function calculateServiceDuration(\r\n  bedrooms: string,\r\n  bathrooms: string,\r\n  additionalServices: string[]\r\n): number {\r\n  // Base hours\r\n  const baseHours = 3.5;\r\n  \r\n  // Convert bedrooms to number (handle empty string as 0)\r\n  const bedroomCount = bedrooms ? parseInt(bedrooms, 10) || 0 : 0;\r\n  \r\n  // Convert bathrooms to number (handle empty string as 0)\r\n  const bathroomCount = bathrooms ? parseInt(bathrooms, 10) || 0 : 0;\r\n  \r\n  // Count additional services\r\n  const extrasCount = additionalServices.length;\r\n  \r\n  // Calculate duration\r\n  const duration = baseHours + \r\n    (bedroomCount * 0.5) + \r\n    (bathroomCount * 0.5) + \r\n    (extrasCount * 0.5);\r\n  \r\n  // Clamp between 3.5 and 10 hours\r\n  return Math.max(3.5, Math.min(10, duration));\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;CAeC;;;;AACM,SAAS,yBACd,QAAgB,EAChB,SAAiB,EACjB,kBAA4B;IAE5B,aAAa;IACb,MAAM,YAAY;IAElB,wDAAwD;IACxD,MAAM,eAAe,WAAW,SAAS,UAAU,OAAO,IAAI;IAE9D,yDAAyD;IACzD,MAAM,gBAAgB,YAAY,SAAS,WAAW,OAAO,IAAI;IAEjE,4BAA4B;IAC5B,MAAM,cAAc,mBAAmB,MAAM;IAE7C,qBAAqB;IACrB,MAAM,WAAW,YACd,eAAe,MACf,gBAAgB,MAChB,cAAc;IAEjB,iCAAiC;IACjC,OAAO,KAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,IAAI;AACpC"}},
    {"offset": {"line": 865, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/book/components/Step1ServiceDetails.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useState, useEffect } from 'react';\r\nimport { useRouter } from 'next/navigation';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\nimport { Checkbox } from '@/components/ui/checkbox';\r\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\r\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\r\nimport { Calendar as CalendarComponent } from '@/components/ui/calendar';\r\nimport { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';\r\nimport { Calendar as CalendarIcon, Loader2, Info } from 'lucide-react';\r\nimport { BookingFormData, PricingRule, TimeSlotAvailability } from '@/types/booking';\r\nimport { getServices, getAdditionalServices, getHomeDetailOptions, getCleaningEquipment } from '../../quote/actions';\r\nimport { getWorkingHours, getWorkingHoursFromOptions, checkAvailabilityForAllSlots } from '../actions';\r\nimport { getIcon } from '@/lib/icon-mapper';\r\nimport { format, parse } from 'date-fns';\r\nimport { calculateServiceDuration } from '@/lib/utils/duration-calculator';\r\nimport { generateSlug } from '@/lib/utils/slug';\r\n\r\ninterface Step1ServiceDetailsProps {\r\n  formData: BookingFormData;\r\n  updateFormData: (updates: Partial<BookingFormData>) => void;\r\n  pricingRules?: PricingRule[];\r\n}\r\n\r\nexport function Step1ServiceDetails({ formData, updateFormData, pricingRules = [] }: Step1ServiceDetailsProps) {\r\n  const router = useRouter();\r\n  const [isMounted, setIsMounted] = useState(false);\r\n  \r\n  // Ensure component is mounted on client to avoid hydration mismatches\r\n  useEffect(() => {\r\n    setIsMounted(true);\r\n  }, []);\r\n  \r\n  // Fetch services\r\n  const { data: services = [], isLoading: isLoadingServices } = useQuery({\r\n    queryKey: ['services'],\r\n    queryFn: getServices,\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Handle service selection with URL update\r\n  const handleServiceSelect = (serviceId: string) => {\r\n    updateFormData({ serviceId });\r\n    // Update URL to include service slug\r\n    const service = services.find(s => s.id === serviceId);\r\n    if (service) {\r\n      const slug = generateSlug(service.name);\r\n      router.push(`/booking/details/${slug}`);\r\n    }\r\n  };\r\n\r\n  // Fetch additional services\r\n  const { data: additionalServices = [], isLoading: isLoadingAdditionalServices } = useQuery({\r\n    queryKey: ['additional-services', formData.serviceId],\r\n    queryFn: () => getAdditionalServices(formData.serviceId || undefined),\r\n    enabled: true,\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Fetch bedrooms\r\n  const { data: bedroomOptions = [] } = useQuery({\r\n    queryKey: ['home-detail-options', 'bedrooms'],\r\n    queryFn: () => getHomeDetailOptions('bedrooms'),\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Fetch bathrooms\r\n  const { data: bathroomOptions = [] } = useQuery({\r\n    queryKey: ['home-detail-options', 'bathrooms'],\r\n    queryFn: () => getHomeDetailOptions('bathrooms'),\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Fetch carpet types (for carpet cleaning service)\r\n  const { data: carpetTypeOptions = [] } = useQuery({\r\n    queryKey: ['home-detail-options', 'carpet_type'],\r\n    queryFn: () => getHomeDetailOptions('carpet_type'),\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Fetch room status (for carpet cleaning service)\r\n  const { data: roomStatusOptions = [] } = useQuery({\r\n    queryKey: ['home-detail-options', 'room_status'],\r\n    queryFn: () => getHomeDetailOptions('room_status'),\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Fetch working hours\r\n  const { data: workingHours = [] } = useQuery({\r\n    queryKey: ['working-hours'],\r\n    queryFn: async () => {\r\n      const hours = await getWorkingHours();\r\n      if (hours.length === 0) {\r\n        // Fallback to home_detail_options\r\n        const options = await getWorkingHoursFromOptions();\r\n        return options.map((opt, idx) => ({\r\n          id: `wh-${idx}`,\r\n          start_time: opt.value,\r\n          end_time: opt.value.split('-')[1] || '',\r\n          duration_hours: 3.5,\r\n          day_of_week: null,\r\n          is_active: true,\r\n          display_order: idx + 1,\r\n          max_bookings_per_slot: null,\r\n          created_at: new Date().toISOString(),\r\n          updated_at: new Date().toISOString(),\r\n        }));\r\n      }\r\n      // Deduplicate by start_time to prevent duplicates\r\n      const uniqueHours = hours.filter((hour, index, self) => \r\n        index === self.findIndex((h) => h.start_time === hour.start_time)\r\n      );\r\n      return uniqueHours;\r\n    },\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Fetch cleaning equipment\r\n  const { data: cleaningEquipment = [] } = useQuery({\r\n    queryKey: ['cleaning-equipment'],\r\n    queryFn: getCleaningEquipment,\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  const minDate = new Date();\r\n  minDate.setHours(0, 0, 0, 0);\r\n  const [calendarOpen, setCalendarOpen] = useState(false);\r\n  const [equipmentInfoOpen, setEquipmentInfoOpen] = useState(false);\r\n  const [showAvailabilityDialog, setShowAvailabilityDialog] = useState(false);\r\n  const [slotAvailability, setSlotAvailability] = useState<Record<string, TimeSlotAvailability>>({});\r\n  const [isCheckingAvailability, setIsCheckingAvailability] = useState(false);\r\n  const [unavailableSlotTime, setUnavailableSlotTime] = useState<string | null>(null);\r\n\r\n  const selectedDate = formData.serviceDate \r\n    ? parse(formData.serviceDate, 'yyyy-MM-dd', new Date())\r\n    : undefined;\r\n\r\n  const handleDateSelect = (date: Date | undefined) => {\r\n    if (date) {\r\n      const dateString = format(date, 'yyyy-MM-dd');\r\n      updateFormData({ serviceDate: dateString });\r\n      setCalendarOpen(false);\r\n      // Reset selected time when date changes\r\n      updateFormData({ serviceTime: '' });\r\n      // Check availability for all slots\r\n      checkSlotAvailability(dateString);\r\n    }\r\n  };\r\n\r\n  // Check availability for all time slots when date is selected\r\n  const checkSlotAvailability = async (date: string) => {\r\n    if (!date || workingHours.length === 0) return;\r\n    \r\n    setIsCheckingAvailability(true);\r\n    try {\r\n      // Use the current service duration, or default to 3.5 hours\r\n      const durationToUse = formData.serviceDuration > 0 ? formData.serviceDuration : 3.5;\r\n      \r\n      // Get service type for team availability checking\r\n      const serviceType = selectedService?.name || undefined;\r\n      \r\n      const availability = await checkAvailabilityForAllSlots(\r\n        date,\r\n        workingHours,\r\n        durationToUse,\r\n        serviceType\r\n      );\r\n      setSlotAvailability(availability);\r\n      \r\n      // Check if all slots are unavailable\r\n      const allUnavailable = Object.values(availability).every(\r\n        (avail) => !avail.available || avail.availableCleanersCount === 0\r\n      );\r\n      \r\n      if (allUnavailable && Object.keys(availability).length > 0) {\r\n        setUnavailableSlotTime(null); // All slots unavailable\r\n        setShowAvailabilityDialog(true);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error checking slot availability:', error);\r\n    } finally {\r\n      setIsCheckingAvailability(false);\r\n    }\r\n  };\r\n\r\n  // Handle time slot selection with availability check\r\n  const handleTimeSlotChange = (value: string) => {\r\n    const availability = slotAvailability[value];\r\n    \r\n    // If slot is unavailable, show dialog instead of selecting\r\n    // This handles cases where the item wasn't properly disabled\r\n    if (availability && (!availability.available || availability.availableCleanersCount === 0)) {\r\n      setUnavailableSlotTime(value);\r\n      setShowAvailabilityDialog(true);\r\n      // Don't update the form data for unavailable slots\r\n      return;\r\n    }\r\n    \r\n    updateFormData({ serviceTime: value });\r\n  };\r\n\r\n  // Helper function to check if selected service is carpet cleaning\r\n  const selectedService = services.find((s) => s.id === formData.serviceId);\r\n  const isCarpetCleaning = selectedService?.name.toLowerCase().includes('carpet') ?? false;\r\n  const isStandardOrAirbnb = (selectedService?.name.toLowerCase().includes('standard') || \r\n                             selectedService?.name.toLowerCase().includes('airbnb')) ?? false;\r\n\r\n  // Auto-calculate duration based on bedrooms, bathrooms, and additional services\r\n  // Only for non-carpet cleaning services\r\n  useEffect(() => {\r\n    if (!isCarpetCleaning && formData.serviceId) {\r\n      const calculatedDuration = calculateServiceDuration(\r\n        formData.bedrooms,\r\n        formData.bathrooms,\r\n        formData.additionalServices\r\n      );\r\n      // Only update if the calculated duration is different from current to avoid infinite loops\r\n      if (Math.abs(calculatedDuration - formData.serviceDuration) > 0.01) {\r\n        updateFormData({ serviceDuration: calculatedDuration });\r\n      }\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [formData.bedrooms, formData.bathrooms, formData.additionalServices.join(','), formData.serviceId, isCarpetCleaning]);\r\n\r\n  // Recheck availability when service duration changes (for carpet cleaning)\r\n  useEffect(() => {\r\n    if (formData.serviceDate && isCarpetCleaning) {\r\n      checkSlotAvailability(formData.serviceDate);\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [formData.serviceDuration, isCarpetCleaning]);\r\n\r\n  // Format duration for display\r\n  const formatDuration = (hours: number): string => {\r\n    if (hours % 1 === 0) {\r\n      return `${hours} hours`;\r\n    }\r\n    return `${hours.toFixed(1)} hours`;\r\n  };\r\n\r\n  // Prevent hydration mismatch by only rendering after mount\r\n  if (!isMounted) {\r\n    return (\r\n      <div className=\"space-y-4 bg-white rounded-xl p-6 max-w-[576px] mx-auto\">\r\n        <div className=\"flex items-center justify-center py-8\">\r\n          <Loader2 className=\"w-6 h-6 animate-spin text-muted-foreground\" />\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <>\r\n      {/* Select Your Service */}\r\n      <div className=\"space-y-4 bg-white rounded-xl p-6 max-w-[576px] mx-auto\">\r\n        <h3 className=\"text-lg font-semibold text-foreground\">Select Your Service</h3>\r\n        <div className=\"space-y-4\">\r\n          {isLoadingServices ? (\r\n            <div className=\"flex items-center justify-center py-8\">\r\n              <Loader2 className=\"w-6 h-6 animate-spin text-muted-foreground\" />\r\n            </div>\r\n          ) : (\r\n            <div className=\"grid grid-cols-3 md:grid-cols-3 lg:grid-cols-5 gap-3\">\r\n              {services.map((service) => {\r\n                const IconComponent = getIcon(service.icon_name);\r\n                const isSelected = formData.serviceId === service.id;\r\n                return (\r\n                  <div key={service.id} className=\"flex flex-col items-center gap-2\">\r\n                    <button\r\n                      type=\"button\"\r\n                      onClick={() => handleServiceSelect(service.id)}\r\n                      className={`flex items-center justify-center p-1.5 rounded-xl border-2 transition-all w-16 h-16 ${\r\n                        isSelected\r\n                          ? 'border-primary bg-primary/5'\r\n                          : 'border-border hover:border-primary/50 bg-background'\r\n                      }`}\r\n                    >\r\n                      <IconComponent className={`w-8 h-8 ${\r\n                        isSelected ? 'text-primary' : 'text-muted-foreground'\r\n                      }`} />\r\n                    </button>\r\n                    <span className=\"font-medium text-sm text-foreground text-center leading-tight\">\r\n                      {service.name.split(' ').map((word, idx, arr) => (\r\n                        <span key={idx}>\r\n                          {word}\r\n                          {idx === 0 && arr.length > 1 && <br />}\r\n                        </span>\r\n                      ))}\r\n                    </span>\r\n                  </div>\r\n                );\r\n              })}\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {/* House Details - Conditional based on service */}\r\n      {isCarpetCleaning ? (\r\n        <div className=\"space-y-6 bg-white rounded-xl p-6 max-w-[576px] mx-auto\">\r\n          <h3 className=\"text-lg font-semibold text-foreground\">Home Details</h3>\r\n          \r\n          {/* Carpet Information */}\r\n          <div className=\"space-y-4\">\r\n            <div className=\"space-y-3\">\r\n              <Label className=\"text-base font-medium\">Carpet Information</Label>\r\n              <div className=\"space-y-2\">\r\n                <Label htmlFor=\"carpet-type\" className=\"text-sm font-normal text-foreground\">\r\n                  What type of carpets do you have?\r\n                </Label>\r\n                {carpetTypeOptions.length === 0 ? (\r\n                  <div className=\"flex items-center justify-center py-4\">\r\n                    <Loader2 className=\"w-5 h-5 animate-spin text-muted-foreground\" />\r\n                  </div>\r\n                ) : (\r\n                  <div className=\"space-y-3\">\r\n                    {carpetTypeOptions.map((option) => (\r\n                      <div key={option.id} className=\"space-y-2\">\r\n                        <div className=\"flex items-center space-x-2\">\r\n                          <Checkbox\r\n                            id={`carpet-${option.value}`}\r\n                            checked={formData.carpetTypes.includes(option.value)}\r\n                            onCheckedChange={(checked) => {\r\n                              const newCarpetTypes = checked\r\n                                ? [...formData.carpetTypes, option.value]\r\n                                : formData.carpetTypes.filter((type) => type !== option.value);\r\n                              \r\n                              updateFormData({\r\n                                carpetTypes: newCarpetTypes,\r\n                                numberOfFittedRooms: option.value === 'fitted' && !checked ? '' : formData.numberOfFittedRooms,\r\n                                numberOfLooseCarpets: option.value === 'loose' && !checked ? '' : formData.numberOfLooseCarpets,\r\n                              });\r\n                            }}\r\n                          />\r\n                          <Label\r\n                            htmlFor={`carpet-${option.value}`}\r\n                            className=\"text-sm font-normal cursor-pointer\"\r\n                          >\r\n                            {option.label}\r\n                          </Label>\r\n                        </div>\r\n                        {formData.carpetTypes.includes(option.value) && (\r\n                          <div className=\"ml-6 space-y-2\">\r\n                            <Label htmlFor={`number-of-${option.value}-rooms`} className=\"text-sm font-normal text-foreground\">\r\n                              {option.value === 'fitted' \r\n                                ? 'Number of rooms with Fitted Carpets'\r\n                                : 'Number of rugs/carpets with Loose Carpets/Rugs'}\r\n                            </Label>\r\n                            <Input\r\n                              id={`number-of-${option.value}-rooms`}\r\n                              type=\"number\"\r\n                              min=\"1\"\r\n                              placeholder={`Enter number of ${option.value === 'fitted' ? 'rooms' : 'rugs/carpets'}`}\r\n                              value={option.value === 'fitted' ? formData.numberOfFittedRooms : formData.numberOfLooseCarpets}\r\n                              onChange={(e) => updateFormData({ \r\n                                [option.value === 'fitted' ? 'numberOfFittedRooms' : 'numberOfLooseCarpets']: e.target.value \r\n                              })}\r\n                              className=\"max-w-[200px]\"\r\n                            />\r\n                          </div>\r\n                        )}\r\n                      </div>\r\n                    ))}\r\n                  </div>\r\n                )}\r\n              </div>\r\n            </div>\r\n\r\n            {/* Room Status */}\r\n            <div className=\"space-y-3\">\r\n              <Label className=\"text-base font-medium\">Room Status</Label>\r\n              {roomStatusOptions.length === 0 ? (\r\n                <div className=\"flex items-center justify-center py-4\">\r\n                  <Loader2 className=\"w-5 h-5 animate-spin text-muted-foreground\" />\r\n                </div>\r\n              ) : (\r\n                <RadioGroup\r\n                  value={formData.roomStatus}\r\n                  onValueChange={(value) => updateFormData({ roomStatus: value })}\r\n                >\r\n                  {roomStatusOptions.map((option) => (\r\n                    <div key={option.id} className=\"flex items-center space-x-2\">\r\n                      <RadioGroupItem value={option.value} id={`room-${option.value}`} />\r\n                      <Label\r\n                        htmlFor={`room-${option.value}`}\r\n                        className=\"text-sm font-normal cursor-pointer\"\r\n                      >\r\n                        {option.label}\r\n                      </Label>\r\n                    </div>\r\n                  ))}\r\n                </RadioGroup>\r\n              )}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      ) : (\r\n        <div className=\"space-y-4 bg-white rounded-xl p-6 max-w-[576px] mx-auto\">\r\n          <h3 className=\"text-lg font-semibold text-foreground\">House details</h3>\r\n          <div className=\"grid md:grid-cols-2 gap-4\">\r\n            <div className=\"space-y-2\">\r\n              <Label>Bedrooms</Label>\r\n              <Select\r\n                value={formData.bedrooms}\r\n                onValueChange={(value) => updateFormData({ bedrooms: value })}\r\n              >\r\n                <SelectTrigger>\r\n                  <SelectValue placeholder=\"Select bedrooms\" />\r\n                </SelectTrigger>\r\n                <SelectContent>\r\n                  {bedroomOptions.map((option) => (\r\n                    <SelectItem key={option.id} value={option.value}>\r\n                      {option.label}\r\n                    </SelectItem>\r\n                  ))}\r\n                </SelectContent>\r\n              </Select>\r\n            </div>\r\n            <div className=\"space-y-2\">\r\n              <Label>Bathrooms</Label>\r\n              <Select\r\n                value={formData.bathrooms}\r\n                onValueChange={(value) => updateFormData({ bathrooms: value })}\r\n              >\r\n                <SelectTrigger>\r\n                  <SelectValue placeholder=\"Select bathrooms\" />\r\n                </SelectTrigger>\r\n                <SelectContent>\r\n                  {bathroomOptions.map((option) => (\r\n                    <SelectItem key={option.id} value={option.value}>\r\n                      {option.label}\r\n                    </SelectItem>\r\n                  ))}\r\n                </SelectContent>\r\n              </Select>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      {/* Additional Services */}\r\n      <div className=\"space-y-4 bg-white rounded-xl p-6 max-w-[576px] mx-auto\">\r\n        <h3 className=\"text-lg font-semibold text-foreground\">Additional Services (Optional)</h3>\r\n        {isLoadingAdditionalServices ? (\r\n          <div className=\"flex items-center justify-center py-8\">\r\n            <Loader2 className=\"w-6 h-6 animate-spin text-muted-foreground\" />\r\n          </div>\r\n        ) : (\r\n          <div className=\"grid grid-cols-3 md:grid-cols-4 lg:grid-cols-7 gap-3\">\r\n            {additionalServices.map((service) => {\r\n              const IconComponent = getIcon(service.icon_name);\r\n              const isSelected = formData.additionalServices.includes(service.id);\r\n              // Get price for this additional service from pricing rules\r\n              const servicePriceRule = pricingRules.find(\r\n                (rule) => rule.rule_type === 'additional_service' && rule.additional_service_id === service.id\r\n              );\r\n              const servicePrice = servicePriceRule?.price || 0;\r\n              \r\n              return (\r\n                <div key={service.id} className=\"flex flex-col items-center gap-2\">\r\n                  <button\r\n                    type=\"button\"\r\n                    onClick={() => {\r\n                      const newServices = isSelected\r\n                        ? formData.additionalServices.filter((id) => id !== service.id)\r\n                        : [...formData.additionalServices, service.id];\r\n                      updateFormData({ additionalServices: newServices });\r\n                    }}\r\n                    className={`flex items-center justify-center p-1.5 rounded-xl border-2 transition-all w-16 h-16 ${\r\n                      isSelected\r\n                        ? 'border-primary bg-primary/5'\r\n                        : 'border-border hover:border-primary/50 bg-background'\r\n                    }`}\r\n                  >\r\n                    <IconComponent className={`w-8 h-8 ${\r\n                      isSelected ? 'text-primary' : 'text-muted-foreground'\r\n                    }`} />\r\n                  </button>\r\n                  <div className=\"flex flex-col items-center gap-0.5\">\r\n                    <span className=\"font-medium text-sm text-foreground text-center leading-tight\">\r\n                      {service.name.split(' ').map((word, idx, arr) => (\r\n                        <span key={idx}>\r\n                          {word}\r\n                          {idx === 0 && arr.length > 1 && <br />}\r\n                        </span>\r\n                      ))}\r\n                    </span>\r\n                    {servicePrice > 0 && (\r\n                      <span className=\"text-xs font-semibold text-primary\">\r\n                        R{servicePrice.toFixed(2)}\r\n                      </span>\r\n                    )}\r\n                  </div>\r\n                </div>\r\n              );\r\n            })}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Cleaning Equipment - Only for Standard and Airbnb */}\r\n      {isStandardOrAirbnb && (\r\n        <div className=\"space-y-4 bg-white rounded-xl p-6 max-w-[576px] mx-auto\">\r\n          <h3 className=\"text-lg font-semibold text-foreground\">Cleaning Equipment & Supplies</h3>\r\n          <p className=\"text-sm text-muted-foreground\">Do you want us to provide cleaning equipment/supplies?</p>\r\n          <RadioGroup\r\n            value={formData.cleaningEquipment}\r\n            onValueChange={(value) => updateFormData({ cleaningEquipment: value as 'yes' | 'no' })}\r\n          >\r\n            <div className=\"flex items-center space-x-2\">\r\n              <RadioGroupItem value=\"yes\" id=\"equipment-yes\" />\r\n              <Label htmlFor=\"equipment-yes\" className=\"cursor-pointer flex items-center gap-1.5\">\r\n                Yes\r\n                <Popover open={equipmentInfoOpen} onOpenChange={setEquipmentInfoOpen}>\r\n                  <PopoverTrigger asChild>\r\n                    <button\r\n                      type=\"button\"\r\n                      onClick={(e) => e.stopPropagation()}\r\n                      className=\"focus:outline-none\"\r\n                    >\r\n                      <Info className=\"w-4 h-4 text-muted-foreground hover:text-primary cursor-pointer\" />\r\n                    </button>\r\n                  </PopoverTrigger>\r\n                  <PopoverContent className=\"w-80\" align=\"start\">\r\n                    <div className=\"space-y-2\">\r\n                      <h4 className=\"font-semibold text-sm\">Equipment & Supplies We Provide:</h4>\r\n                      <ul className=\"text-sm text-muted-foreground space-y-1.5 list-disc list-inside\">\r\n                        {cleaningEquipment.map((item) => (\r\n                          <li key={item.id}>{item.name}</li>\r\n                        ))}\r\n                      </ul>\r\n                    </div>\r\n                  </PopoverContent>\r\n                </Popover>\r\n              </Label>\r\n            </div>\r\n            <div className=\"flex items-center space-x-2\">\r\n              <RadioGroupItem value=\"no\" id=\"equipment-no\" />\r\n              <Label htmlFor=\"equipment-no\" className=\"cursor-pointer\">No</Label>\r\n            </div>\r\n          </RadioGroup>\r\n        </div>\r\n      )}\r\n\r\n      {/* Number of Cleaners - Only for Standard and Airbnb */}\r\n      {isStandardOrAirbnb && (\r\n        <div className=\"space-y-4 bg-white rounded-xl p-6 max-w-[576px] mx-auto\">\r\n          <h3 className=\"text-lg font-semibold text-foreground\">Number of Cleaners</h3>\r\n          <p className=\"text-sm text-muted-foreground\">How many cleaners would you like for this service?</p>\r\n          <RadioGroup\r\n            value={formData.numberOfCleaners === 1 ? \"1\" : \"2+\"}\r\n            onValueChange={(value) => {\r\n              if (value === \"1\") {\r\n                updateFormData({ numberOfCleaners: 1 });\r\n              } else {\r\n                // Default to 2 if switching to 2+\r\n                updateFormData({ numberOfCleaners: Math.max(2, formData.numberOfCleaners) });\r\n              }\r\n            }}\r\n          >\r\n            <div className=\"flex items-center space-x-2\">\r\n              <RadioGroupItem value=\"1\" id=\"cleaners-1\" />\r\n              <Label htmlFor=\"cleaners-1\" className=\"text-sm font-normal cursor-pointer\">\r\n                Only 1 cleaner\r\n              </Label>\r\n            </div>\r\n            <div className=\"flex items-center space-x-2\">\r\n              <RadioGroupItem value=\"2+\" id=\"cleaners-2\" />\r\n              <Label htmlFor=\"cleaners-2\" className=\"text-sm font-normal cursor-pointer\">\r\n                2-5 cleaners\r\n              </Label>\r\n            </div>\r\n          </RadioGroup>\r\n          {formData.numberOfCleaners > 1 && (\r\n            <div className=\"ml-6 space-y-2\">\r\n              <Label htmlFor=\"number-of-cleaners-count\" className=\"text-sm font-normal text-foreground\">\r\n                How many cleaners do you need? (2-5)\r\n              </Label>\r\n              <Input\r\n                id=\"number-of-cleaners-count\"\r\n                type=\"number\"\r\n                min=\"2\"\r\n                max=\"5\"\r\n                placeholder=\"Enter number of cleaners\"\r\n                value={formData.numberOfCleaners > 1 ? formData.numberOfCleaners.toString() : '2'}\r\n                onChange={(e) => {\r\n                  const value = parseInt(e.target.value, 10);\r\n                  if (!isNaN(value) && value >= 2 && value <= 5) {\r\n                    updateFormData({ numberOfCleaners: value });\r\n                  }\r\n                }}\r\n                onBlur={(e) => {\r\n                  const value = parseInt(e.target.value, 10);\r\n                  if (isNaN(value) || value < 2 || value > 5) {\r\n                    // Reset to 2 if invalid\r\n                    updateFormData({ numberOfCleaners: 2 });\r\n                  }\r\n                }}\r\n                className=\"max-w-[200px]\"\r\n              />\r\n              {formData.numberOfCleaners > 1 && (\r\n                <p className=\"text-xs text-muted-foreground\">\r\n                  Additional charge: R{((formData.numberOfCleaners - 1) * 250).toFixed(2)} (R250 per additional cleaner)\r\n                </p>\r\n              )}\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n\r\n      {/* Schedule */}\r\n      <div className=\"space-y-3 bg-white rounded-xl p-6 max-w-[576px] mx-auto\">\r\n        <h3 className=\"text-sm font-medium text-foreground\">Schedule</h3>\r\n        <div className=\"grid md:grid-cols-2 gap-4\">\r\n          <div className=\"space-y-1.5\">\r\n            <Label className=\"text-sm text-muted-foreground\">Which day would you like us to come?</Label>\r\n            <Popover open={calendarOpen} onOpenChange={setCalendarOpen}>\r\n              <PopoverTrigger asChild>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  className=\"w-full justify-start text-left font-normal relative pl-10\"\r\n                >\r\n                  <CalendarIcon className=\"absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground pointer-events-none\" />\r\n                  {selectedDate ? format(selectedDate, 'PPP') : 'Pick a date'}\r\n                </Button>\r\n              </PopoverTrigger>\r\n              <PopoverContent className=\"w-auto min-w-[280px] p-0\" align=\"start\">\r\n                <CalendarComponent\r\n                  mode=\"single\"\r\n                  selected={selectedDate}\r\n                  onSelect={handleDateSelect}\r\n                  disabled={(date) => {\r\n                    const dateToCompare = new Date(date);\r\n                    dateToCompare.setHours(0, 0, 0, 0);\r\n                    return dateToCompare < minDate;\r\n                  }}\r\n                  initialFocus\r\n                />\r\n              </PopoverContent>\r\n            </Popover>\r\n          </div>\r\n          <div className=\"space-y-1.5\">\r\n            <Label className=\"text-sm text-muted-foreground\">What time would you like us to arrive?</Label>\r\n            <Select\r\n              value={formData.serviceTime}\r\n              onValueChange={handleTimeSlotChange}\r\n              disabled={!formData.serviceDate || isCheckingAvailability}\r\n            >\r\n              <SelectTrigger>\r\n                <SelectValue \r\n                  placeholder={\r\n                    isCheckingAvailability \r\n                      ? \"Checking availability...\" \r\n                      : formData.serviceDate \r\n                        ? \"Select a time\" \r\n                        : \"Select date first\"\r\n                  } \r\n                />\r\n              </SelectTrigger>\r\n              <SelectContent className=\"max-h-[200px]\">\r\n                {workingHours.map((hour) => {\r\n                  const availability = slotAvailability[hour.start_time];\r\n                  const isUnavailable = availability && (!availability.available || availability.availableCleanersCount === 0);\r\n                  \r\n                  try {\r\n                    const startTime = hour.start_time.length === 5 \r\n                      ? parse(hour.start_time, 'HH:mm', new Date())\r\n                      : parse(hour.start_time.substring(0, 5), 'HH:mm', new Date());\r\n                    return (\r\n                      <SelectItem \r\n                        key={hour.id} \r\n                        value={hour.start_time}\r\n                        className={isUnavailable ? 'text-muted-foreground' : ''}\r\n                      >\r\n                        {format(startTime, 'HH:mm')}\r\n                        {isUnavailable && (\r\n                          <span className=\"ml-2 text-xs text-muted-foreground\">(Unavailable)</span>\r\n                        )}\r\n                      </SelectItem>\r\n                    );\r\n                  } catch {\r\n                    return (\r\n                      <SelectItem \r\n                        key={hour.id} \r\n                        value={hour.start_time}\r\n                        className={isUnavailable ? 'text-muted-foreground' : ''}\r\n                      >\r\n                        {hour.start_time.length >= 5 ? hour.start_time.substring(0, 5) : hour.start_time}\r\n                        {isUnavailable && (\r\n                          <span className=\"ml-2 text-xs text-muted-foreground\">(Unavailable)</span>\r\n                        )}\r\n                      </SelectItem>\r\n                    );\r\n                  }\r\n                })}\r\n              </SelectContent>\r\n            </Select>\r\n            {isCheckingAvailability && (\r\n              <p className=\"text-xs text-muted-foreground flex items-center gap-2\">\r\n                <Loader2 className=\"w-3 h-3 animate-spin\" />\r\n                Checking cleaner availability...\r\n              </p>\r\n            )}\r\n          </div>\r\n        </div>\r\n        {formData.serviceTime && !isCarpetCleaning && (\r\n          <div className=\"space-y-1.5\">\r\n            <Label className=\"text-sm text-muted-foreground\">How long do you need? (hours)</Label>\r\n            <Input\r\n              type=\"text\"\r\n              value={formatDuration(formData.serviceDuration)}\r\n              readOnly\r\n              className=\"bg-muted cursor-not-allowed\"\r\n              aria-label=\"Service duration (auto-calculated)\"\r\n            />\r\n            <p className=\"text-xs text-muted-foreground\">\r\n              Duration is automatically calculated based on your selections\r\n            </p>\r\n          </div>\r\n        )}\r\n        {formData.serviceTime && isCarpetCleaning && (\r\n          <div className=\"space-y-1.5\">\r\n            <Label className=\"text-sm text-muted-foreground\">How long do you need? (hours)</Label>\r\n            <Select\r\n              value={formData.serviceDuration.toString()}\r\n              onValueChange={(value) => updateFormData({ serviceDuration: parseFloat(value) })}\r\n            >\r\n              <SelectTrigger>\r\n                <SelectValue placeholder=\"Select duration\" />\r\n              </SelectTrigger>\r\n              <SelectContent className=\"max-h-[200px]\">\r\n                {[3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10].map((duration) => (\r\n                  <SelectItem key={duration} value={duration.toString()}>\r\n                    {duration % 1 === 0 ? duration.toString() : duration.toFixed(1)} hours\r\n                  </SelectItem>\r\n                ))}\r\n              </SelectContent>\r\n            </Select>\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Special Instructions */}\r\n      <div className=\"space-y-4 bg-white rounded-xl p-6 max-w-[576px] mx-auto\">\r\n        <h3 className=\"text-lg font-semibold text-foreground\">Special Instructions</h3>\r\n        <Textarea\r\n          placeholder=\"Add your notes here......\"\r\n          className=\"min-h-[100px]\"\r\n          value={formData.specialInstructions}\r\n          onChange={(e) => updateFormData({ specialInstructions: e.target.value })}\r\n        />\r\n      </div>\r\n\r\n      {/* Availability Dialog */}\r\n      <Dialog \r\n        open={showAvailabilityDialog} \r\n        onOpenChange={(open) => {\r\n          setShowAvailabilityDialog(open);\r\n          if (!open) {\r\n            setUnavailableSlotTime(null);\r\n          }\r\n        }}\r\n      >\r\n        <DialogContent className=\"max-w-md\">\r\n          <DialogHeader>\r\n            <DialogTitle>Time Slot Unavailable</DialogTitle>\r\n            <DialogDescription>\r\n              {unavailableSlotTime ? (\r\n                <>\r\n                  The selected time slot ({(() => {\r\n                    try {\r\n                      const time = unavailableSlotTime.length === 5 \r\n                        ? parse(unavailableSlotTime, 'HH:mm', new Date())\r\n                        : parse(unavailableSlotTime.substring(0, 5), 'HH:mm', new Date());\r\n                      return format(time, 'HH:mm');\r\n                    } catch {\r\n                      return unavailableSlotTime.length >= 5 ? unavailableSlotTime.substring(0, 5) : unavailableSlotTime;\r\n                    }\r\n                  })()}) is currently unavailable. Our cleaners are fully booked for this time.\r\n                </>\r\n              ) : (\r\n                'This time slot is currently unavailable. Our cleaners are fully booked for this time.'\r\n              )}\r\n            </DialogDescription>\r\n          </DialogHeader>\r\n          \r\n          {/* Show available time slots for the selected date */}\r\n          {formData.serviceDate && Object.keys(slotAvailability).length > 0 && (() => {\r\n            const availableSlots = workingHours\r\n              .filter((hour) => {\r\n                const availability = slotAvailability[hour.start_time];\r\n                return availability && availability.available && availability.availableCleanersCount > 0;\r\n              })\r\n              .map((hour) => {\r\n                try {\r\n                  const startTime = hour.start_time.length === 5 \r\n                    ? parse(hour.start_time, 'HH:mm', new Date())\r\n                    : parse(hour.start_time.substring(0, 5), 'HH:mm', new Date());\r\n                  return {\r\n                    time: hour.start_time,\r\n                    displayTime: format(startTime, 'HH:mm'),\r\n                    availability: slotAvailability[hour.start_time],\r\n                  };\r\n                } catch {\r\n                  return {\r\n                    time: hour.start_time,\r\n                    displayTime: hour.start_time.length >= 5 ? hour.start_time.substring(0, 5) : hour.start_time,\r\n                    availability: slotAvailability[hour.start_time],\r\n                  };\r\n                }\r\n              });\r\n\r\n            if (availableSlots.length > 0) {\r\n              return (\r\n                <div className=\"space-y-3 py-4\">\r\n                  <p className=\"text-sm font-medium text-foreground\">\r\n                    Available time slots for {formData.serviceDate ? format(parse(formData.serviceDate, 'yyyy-MM-dd', new Date()), 'MMMM d, yyyy') : 'this date'}:\r\n                  </p>\r\n                  <div className=\"grid grid-cols-3 gap-2 max-h-[200px] overflow-y-auto p-1\">\r\n                    {availableSlots.map((slot) => (\r\n                      <button\r\n                        key={slot.time}\r\n                        type=\"button\"\r\n                        onClick={() => {\r\n                          updateFormData({ serviceTime: slot.time });\r\n                          setShowAvailabilityDialog(false);\r\n                          setUnavailableSlotTime(null);\r\n                        }}\r\n                        className=\"px-3 py-2 text-sm font-medium rounded-md border-2 border-primary/20 bg-primary/5 hover:bg-primary hover:text-primary-foreground hover:border-primary transition-all duration-200\"\r\n                      >\r\n                        {slot.displayTime}\r\n                      </button>\r\n                    ))}\r\n                  </div>\r\n                  <p className=\"text-xs text-muted-foreground\">\r\n                    Click on an available time slot to select it, or choose a different date.\r\n                  </p>\r\n                </div>\r\n              );\r\n            } else {\r\n              return (\r\n                <div className=\"space-y-3 py-4\">\r\n                  <p className=\"text-sm text-muted-foreground\">\r\n                    Unfortunately, all time slots are fully booked for {formData.serviceDate ? format(parse(formData.serviceDate, 'yyyy-MM-dd', new Date()), 'MMMM d, yyyy') : 'this date'}.\r\n                  </p>\r\n                  <p className=\"text-sm text-muted-foreground\">\r\n                    Please select a different date to see available time slots.\r\n                  </p>\r\n                </div>\r\n              );\r\n            }\r\n          })()}\r\n\r\n          <DialogFooter>\r\n            <Button \r\n              variant=\"outline\" \r\n              onClick={() => setShowAvailabilityDialog(false)}\r\n            >\r\n              Close\r\n            </Button>\r\n          </DialogFooter>\r\n        </DialogContent>\r\n      </Dialog>\r\n    </>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2589, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/details/%5BserviceSlug%5D/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useParams, useRouter, useSearchParams } from 'next/navigation';\r\nimport { useEffect, Suspense } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { Button } from '@/components/ui/button';\r\nimport { ArrowLeft } from 'lucide-react';\r\nimport { useBookingFormContext } from '../../book/context/BookingFormContext';\r\nimport { Step1ServiceDetails } from '../../book/components/Step1ServiceDetails';\r\nimport { getPricingRulesClient } from '../../book/actions-client';\r\nimport { getServices } from '../../quote/actions';\r\nimport { findServiceBySlug } from '@/lib/utils/slug';\r\nimport { toast } from 'sonner';\r\n\r\nfunction BookingDetailsPageWithSlugContent() {\r\n  const params = useParams();\r\n  const router = useRouter();\r\n  const searchParams = useSearchParams();\r\n  const serviceSlug = params.serviceSlug as string;\r\n  \r\n  const {\r\n    formData,\r\n    updateFormData,\r\n    validateCurrentStep,\r\n    nextStep,\r\n    setServicesForSlug,\r\n  } = useBookingFormContext();\r\n\r\n  // Fetch services to validate slug\r\n  const { data: services = [] } = useQuery({\r\n    queryKey: ['services'],\r\n    queryFn: getServices,\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Set services in hook for slug generation\r\n  useEffect(() => {\r\n    if (services.length > 0) {\r\n      setServicesForSlug(services);\r\n    }\r\n  }, [services, setServicesForSlug]);\r\n\r\n  // Read and store referral code from URL parameter\r\n  useEffect(() => {\r\n    const refCode = searchParams.get('ref');\r\n    if (refCode && !formData.referralCode) {\r\n      // Store referral code in form data\r\n      updateFormData({ referralCode: refCode });\r\n      // Also store in localStorage for persistence\r\n      if (typeof window !== 'undefined') {\r\n        localStorage.setItem('shalean_referral_code', refCode);\r\n      }\r\n    }\r\n  }, [searchParams, formData.referralCode, updateFormData]);\r\n\r\n  // Fetch and cache pricing rules\r\n  const { data: pricingRules = [] } = useQuery({\r\n    queryKey: ['pricing-rules'],\r\n    queryFn: getPricingRulesClient,\r\n    staleTime: 10 * 60 * 1000,\r\n  });\r\n\r\n  // Validate service slug and set service if valid\r\n  useEffect(() => {\r\n    if (services.length > 0 && serviceSlug) {\r\n      const service = findServiceBySlug(services, serviceSlug);\r\n      if (service) {\r\n        // Set service if not already set or if different\r\n        if (!formData.serviceId || formData.serviceId !== service.id) {\r\n          updateFormData({ serviceId: service.id });\r\n        }\r\n      } else {\r\n        // Invalid slug, redirect to details page\r\n        toast.error('Invalid service selected');\r\n        router.replace('/booking/details');\r\n      }\r\n    }\r\n    // Only run when services are loaded and slug changes, not on every formData change\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [serviceSlug, services.length]);\r\n\r\n  const handleNext = (e?: React.MouseEvent) => {\r\n    e?.preventDefault();\r\n    e?.stopPropagation();\r\n    \r\n    const validation = validateCurrentStep();\r\n    console.log('handleNext - Validation:', validation, 'FormData:', formData, 'serviceSlug:', serviceSlug);\r\n    \r\n    if (!validation.valid) {\r\n      validation.errors.forEach((error) => toast.error(error));\r\n      return;\r\n    }\r\n    \r\n    // Navigate directly using the service slug from params\r\n    if (serviceSlug) {\r\n      const refCode = formData.referralCode || searchParams.get('ref');\r\n      const nextUrl = refCode \r\n        ? `/booking/worker/${serviceSlug}?ref=${refCode}`\r\n        : `/booking/worker/${serviceSlug}`;\r\n      console.log('Navigating to:', nextUrl, 'Current path:', window.location.pathname);\r\n      // Use router.replace to avoid adding to history and potential redirect loops\r\n      router.replace(nextUrl);\r\n    } else {\r\n      console.log('No serviceSlug, using nextStep');\r\n      // Fallback to hook's nextStep if no slug\r\n      nextStep();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <Step1ServiceDetails\r\n        formData={formData}\r\n        updateFormData={updateFormData}\r\n        pricingRules={pricingRules}\r\n      />\r\n\r\n      {/* Navigation Buttons */}\r\n      <div className=\"flex justify-between max-w-[576px] mx-auto mt-6\">\r\n        <div></div>\r\n        <div className=\"ml-auto\">\r\n          <Button \r\n            onClick={(e) => {\r\n              e.preventDefault();\r\n              e.stopPropagation();\r\n              handleNext(e);\r\n            }} \r\n            type=\"button\"\r\n          >\r\n            Continue\r\n            <ArrowLeft className=\"w-4 h-4 ml-2 rotate-180\" />\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default function BookingDetailsPageWithSlug() {\r\n  return (\r\n    <Suspense fallback={\r\n      <div className=\"flex items-center justify-center py-8\">\r\n        <div className=\"text-center\">\r\n          <p className=\"text-muted-foreground\">Loading...</p>\r\n        </div>\r\n      </div>\r\n    }>\r\n      <BookingDetailsPageWithSlugContent />\r\n    </Suspense>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":"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"}}]
}