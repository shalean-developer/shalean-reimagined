{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (\r\n  <div ref={ref} className={cn(\"rounded-lg border bg-card text-card-foreground shadow-sm\", className)} {...props} />\r\n));\r\nCard.displayName = \"Card\";\r\n\r\nconst CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex flex-col space-y-1.5 p-6\", className)} {...props} />\r\n  ),\r\n);\r\nCardHeader.displayName = \"CardHeader\";\r\n\r\nconst CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <h3 ref={ref} className={cn(\"text-2xl font-semibold leading-none tracking-tight\", className)} {...props} />\r\n  ),\r\n);\r\nCardTitle.displayName = \"CardTitle\";\r\n\r\nconst CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <p ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\r\n  ),\r\n);\r\nCardDescription.displayName = \"CardDescription\";\r\n\r\nconst CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />,\r\n);\r\nCardContent.displayName = \"CardContent\";\r\n\r\nconst CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex items-center p-6 pt-0\", className)} {...props} />\r\n  ),\r\n);\r\nCardFooter.displayName = \"CardFooter\";\r\n\r\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,mNAAgB,CAAuD,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC5G,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,4DAA4D;QAAa,GAAG,KAAK;;;;;;AAEhH,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,mNAAgB,CACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;AAGvF,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,mNAAgB,CAChC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAG,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,sDAAsD;QAAa,GAAG,KAAK;;;;;;AAG3G,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,mNAAgB,CACtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAE,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;AAGrF,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,mNAAgB,CAClC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAAQ,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,YAAY;QAAa,GAAG,KAAK;;;;;;AAElG,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,mNAAgB,CACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,8BAA8B;QAAa,GAAG,KAAK;;;;;;AAGpF,WAAW,WAAW,GAAG"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function uploadProfilePicture(\r\n  email: string,\r\n  fileData: string, // base64 encoded string\r\n  fileName: string,\r\n  fileType: string\r\n): Promise<{\r\n  success: boolean;\r\n  url?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate file type\r\n    const validImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\r\n    if (!validImageTypes.includes(fileType)) {\r\n      return { success: false, error: 'Invalid file type. Please upload a JPEG, PNG, or WebP image.' };\r\n    }\r\n\r\n    // Decode base64 data\r\n    const base64Data = fileData.replace(/^data:image\\/\\w+;base64,/, '');\r\n    const buffer = Buffer.from(base64Data, 'base64');\r\n\r\n    // Validate file size (max 5MB)\r\n    const maxSize = 5 * 1024 * 1024; // 5MB in bytes\r\n    if (buffer.length > maxSize) {\r\n      return { success: false, error: 'File size too large. Please upload an image smaller than 5MB.' };\r\n    }\r\n\r\n    // Generate unique filename using email and timestamp\r\n    const fileExt = fileName.split('.').pop() || 'jpg';\r\n    const sanitizedEmail = email.replace(/[^a-zA-Z0-9]/g, '_');\r\n    const uniqueFileName = `${sanitizedEmail}_${Date.now()}.${fileExt}`;\r\n    const filePath = `avatars/${uniqueFileName}`;\r\n\r\n    // Upload to Supabase Storage\r\n    const { data: uploadData, error: uploadError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .upload(filePath, buffer, {\r\n        contentType: fileType,\r\n        upsert: false,\r\n      });\r\n\r\n    if (uploadError) {\r\n      console.error('Error uploading file:', uploadError);\r\n      // If bucket doesn't exist, return helpful error\r\n      if (uploadError.message.includes('not found') || uploadError.message.includes('Bucket')) {\r\n        return { \r\n          success: false, \r\n          error: 'Storage bucket not configured. Please create a \"profile-pictures\" bucket in Supabase Storage.' \r\n        };\r\n      }\r\n      return { success: false, error: uploadError.message };\r\n    }\r\n\r\n    // Get public URL\r\n    const { data: urlData } = supabase.storage\r\n      .from('profile-pictures')\r\n      .getPublicUrl(filePath);\r\n\r\n    return { success: true, url: urlData.publicUrl };\r\n  } catch (error) {\r\n    console.error('Error in uploadProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to upload profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteProfilePicture(email: string, avatarUrl: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Extract file path from URL\r\n    // URL format: https://[project].supabase.co/storage/v1/object/public/profile-pictures/avatars/filename.jpg\r\n    const urlPattern = /\\/profile-pictures\\/(.+)$/;\r\n    const match = avatarUrl.match(urlPattern);\r\n    \r\n    if (!match || !match[1]) {\r\n      // If URL doesn't match expected pattern, try alternative parsing\r\n      const urlParts = avatarUrl.split('/avatars/');\r\n      if (urlParts.length < 2) {\r\n        // If we can't parse the URL, just return success (the file might already be deleted)\r\n        console.warn('Could not parse avatar URL for deletion:', avatarUrl);\r\n        return { success: true };\r\n      }\r\n      const filePath = `avatars/${urlParts[1].split('?')[0]}`;\r\n      const { error: deleteError } = await supabase.storage\r\n        .from('profile-pictures')\r\n        .remove([filePath]);\r\n\r\n      if (deleteError && !deleteError.message.includes('not found')) {\r\n        console.error('Error deleting file:', deleteError);\r\n        return { success: false, error: deleteError.message };\r\n      }\r\n      return { success: true };\r\n    }\r\n\r\n    const filePath = match[1].split('?')[0]; // Remove query parameters if any\r\n\r\n    // Delete from storage\r\n    const { error: deleteError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .remove([filePath]);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting file:', deleteError);\r\n      // Don't fail if file doesn't exist\r\n      if (deleteError.message.includes('not found') || deleteError.message.includes('No such file')) {\r\n        return { success: true };\r\n      }\r\n      return { success: false, error: deleteError.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteProfilePicture:', error);\r\n    // Don't fail completely - the URL in database will be removed anyway\r\n    return { success: true };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    // If avatar_url is being removed, delete the old file\r\n    if (existingProfile?.avatar_url && data.avatar_url === null) {\r\n      await deleteProfilePicture(email, existingProfile.avatar_url);\r\n    }\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const updateData: any = {\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      // Only update avatar_url if it's provided\r\n      if (data.avatar_url !== undefined) {\r\n        updateData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update(updateData)\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const insertData: any = {\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n      };\r\n\r\n      // Only set avatar_url if it's provided\r\n      if (data.avatar_url) {\r\n        insertData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert(insertData)\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MA6esB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function uploadProfilePicture(\r\n  email: string,\r\n  fileData: string, // base64 encoded string\r\n  fileName: string,\r\n  fileType: string\r\n): Promise<{\r\n  success: boolean;\r\n  url?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate file type\r\n    const validImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\r\n    if (!validImageTypes.includes(fileType)) {\r\n      return { success: false, error: 'Invalid file type. Please upload a JPEG, PNG, or WebP image.' };\r\n    }\r\n\r\n    // Decode base64 data\r\n    const base64Data = fileData.replace(/^data:image\\/\\w+;base64,/, '');\r\n    const buffer = Buffer.from(base64Data, 'base64');\r\n\r\n    // Validate file size (max 5MB)\r\n    const maxSize = 5 * 1024 * 1024; // 5MB in bytes\r\n    if (buffer.length > maxSize) {\r\n      return { success: false, error: 'File size too large. Please upload an image smaller than 5MB.' };\r\n    }\r\n\r\n    // Generate unique filename using email and timestamp\r\n    const fileExt = fileName.split('.').pop() || 'jpg';\r\n    const sanitizedEmail = email.replace(/[^a-zA-Z0-9]/g, '_');\r\n    const uniqueFileName = `${sanitizedEmail}_${Date.now()}.${fileExt}`;\r\n    const filePath = `avatars/${uniqueFileName}`;\r\n\r\n    // Upload to Supabase Storage\r\n    const { data: uploadData, error: uploadError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .upload(filePath, buffer, {\r\n        contentType: fileType,\r\n        upsert: false,\r\n      });\r\n\r\n    if (uploadError) {\r\n      console.error('Error uploading file:', uploadError);\r\n      // If bucket doesn't exist, return helpful error\r\n      if (uploadError.message.includes('not found') || uploadError.message.includes('Bucket')) {\r\n        return { \r\n          success: false, \r\n          error: 'Storage bucket not configured. Please create a \"profile-pictures\" bucket in Supabase Storage.' \r\n        };\r\n      }\r\n      return { success: false, error: uploadError.message };\r\n    }\r\n\r\n    // Get public URL\r\n    const { data: urlData } = supabase.storage\r\n      .from('profile-pictures')\r\n      .getPublicUrl(filePath);\r\n\r\n    return { success: true, url: urlData.publicUrl };\r\n  } catch (error) {\r\n    console.error('Error in uploadProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to upload profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteProfilePicture(email: string, avatarUrl: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Extract file path from URL\r\n    // URL format: https://[project].supabase.co/storage/v1/object/public/profile-pictures/avatars/filename.jpg\r\n    const urlPattern = /\\/profile-pictures\\/(.+)$/;\r\n    const match = avatarUrl.match(urlPattern);\r\n    \r\n    if (!match || !match[1]) {\r\n      // If URL doesn't match expected pattern, try alternative parsing\r\n      const urlParts = avatarUrl.split('/avatars/');\r\n      if (urlParts.length < 2) {\r\n        // If we can't parse the URL, just return success (the file might already be deleted)\r\n        console.warn('Could not parse avatar URL for deletion:', avatarUrl);\r\n        return { success: true };\r\n      }\r\n      const filePath = `avatars/${urlParts[1].split('?')[0]}`;\r\n      const { error: deleteError } = await supabase.storage\r\n        .from('profile-pictures')\r\n        .remove([filePath]);\r\n\r\n      if (deleteError && !deleteError.message.includes('not found')) {\r\n        console.error('Error deleting file:', deleteError);\r\n        return { success: false, error: deleteError.message };\r\n      }\r\n      return { success: true };\r\n    }\r\n\r\n    const filePath = match[1].split('?')[0]; // Remove query parameters if any\r\n\r\n    // Delete from storage\r\n    const { error: deleteError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .remove([filePath]);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting file:', deleteError);\r\n      // Don't fail if file doesn't exist\r\n      if (deleteError.message.includes('not found') || deleteError.message.includes('No such file')) {\r\n        return { success: true };\r\n      }\r\n      return { success: false, error: deleteError.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteProfilePicture:', error);\r\n    // Don't fail completely - the URL in database will be removed anyway\r\n    return { success: true };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    // If avatar_url is being removed, delete the old file\r\n    if (existingProfile?.avatar_url && data.avatar_url === null) {\r\n      await deleteProfilePicture(email, existingProfile.avatar_url);\r\n    }\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const updateData: any = {\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      // Only update avatar_url if it's provided\r\n      if (data.avatar_url !== undefined) {\r\n        updateData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update(updateData)\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const insertData: any = {\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n      };\r\n\r\n      // Only set avatar_url if it's provided\r\n      if (data.avatar_url) {\r\n        insertData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert(insertData)\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MA0hBsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,kDAAA"}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function uploadProfilePicture(\r\n  email: string,\r\n  fileData: string, // base64 encoded string\r\n  fileName: string,\r\n  fileType: string\r\n): Promise<{\r\n  success: boolean;\r\n  url?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate file type\r\n    const validImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\r\n    if (!validImageTypes.includes(fileType)) {\r\n      return { success: false, error: 'Invalid file type. Please upload a JPEG, PNG, or WebP image.' };\r\n    }\r\n\r\n    // Decode base64 data\r\n    const base64Data = fileData.replace(/^data:image\\/\\w+;base64,/, '');\r\n    const buffer = Buffer.from(base64Data, 'base64');\r\n\r\n    // Validate file size (max 5MB)\r\n    const maxSize = 5 * 1024 * 1024; // 5MB in bytes\r\n    if (buffer.length > maxSize) {\r\n      return { success: false, error: 'File size too large. Please upload an image smaller than 5MB.' };\r\n    }\r\n\r\n    // Generate unique filename using email and timestamp\r\n    const fileExt = fileName.split('.').pop() || 'jpg';\r\n    const sanitizedEmail = email.replace(/[^a-zA-Z0-9]/g, '_');\r\n    const uniqueFileName = `${sanitizedEmail}_${Date.now()}.${fileExt}`;\r\n    const filePath = `avatars/${uniqueFileName}`;\r\n\r\n    // Upload to Supabase Storage\r\n    const { data: uploadData, error: uploadError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .upload(filePath, buffer, {\r\n        contentType: fileType,\r\n        upsert: false,\r\n      });\r\n\r\n    if (uploadError) {\r\n      console.error('Error uploading file:', uploadError);\r\n      // If bucket doesn't exist, return helpful error\r\n      if (uploadError.message.includes('not found') || uploadError.message.includes('Bucket')) {\r\n        return { \r\n          success: false, \r\n          error: 'Storage bucket not configured. Please create a \"profile-pictures\" bucket in Supabase Storage.' \r\n        };\r\n      }\r\n      return { success: false, error: uploadError.message };\r\n    }\r\n\r\n    // Get public URL\r\n    const { data: urlData } = supabase.storage\r\n      .from('profile-pictures')\r\n      .getPublicUrl(filePath);\r\n\r\n    return { success: true, url: urlData.publicUrl };\r\n  } catch (error) {\r\n    console.error('Error in uploadProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to upload profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteProfilePicture(email: string, avatarUrl: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Extract file path from URL\r\n    // URL format: https://[project].supabase.co/storage/v1/object/public/profile-pictures/avatars/filename.jpg\r\n    const urlPattern = /\\/profile-pictures\\/(.+)$/;\r\n    const match = avatarUrl.match(urlPattern);\r\n    \r\n    if (!match || !match[1]) {\r\n      // If URL doesn't match expected pattern, try alternative parsing\r\n      const urlParts = avatarUrl.split('/avatars/');\r\n      if (urlParts.length < 2) {\r\n        // If we can't parse the URL, just return success (the file might already be deleted)\r\n        console.warn('Could not parse avatar URL for deletion:', avatarUrl);\r\n        return { success: true };\r\n      }\r\n      const filePath = `avatars/${urlParts[1].split('?')[0]}`;\r\n      const { error: deleteError } = await supabase.storage\r\n        .from('profile-pictures')\r\n        .remove([filePath]);\r\n\r\n      if (deleteError && !deleteError.message.includes('not found')) {\r\n        console.error('Error deleting file:', deleteError);\r\n        return { success: false, error: deleteError.message };\r\n      }\r\n      return { success: true };\r\n    }\r\n\r\n    const filePath = match[1].split('?')[0]; // Remove query parameters if any\r\n\r\n    // Delete from storage\r\n    const { error: deleteError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .remove([filePath]);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting file:', deleteError);\r\n      // Don't fail if file doesn't exist\r\n      if (deleteError.message.includes('not found') || deleteError.message.includes('No such file')) {\r\n        return { success: true };\r\n      }\r\n      return { success: false, error: deleteError.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteProfilePicture:', error);\r\n    // Don't fail completely - the URL in database will be removed anyway\r\n    return { success: true };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    // If avatar_url is being removed, delete the old file\r\n    if (existingProfile?.avatar_url && data.avatar_url === null) {\r\n      await deleteProfilePicture(email, existingProfile.avatar_url);\r\n    }\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const updateData: any = {\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      // Only update avatar_url if it's provided\r\n      if (data.avatar_url !== undefined) {\r\n        updateData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update(updateData)\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const insertData: any = {\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n      };\r\n\r\n      // Only set avatar_url if it's provided\r\n      if (data.avatar_url) {\r\n        insertData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert(insertData)\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAomBsB,yBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,mDAAA"}},
    {"offset": {"line": 131, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function uploadProfilePicture(\r\n  email: string,\r\n  fileData: string, // base64 encoded string\r\n  fileName: string,\r\n  fileType: string\r\n): Promise<{\r\n  success: boolean;\r\n  url?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate file type\r\n    const validImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\r\n    if (!validImageTypes.includes(fileType)) {\r\n      return { success: false, error: 'Invalid file type. Please upload a JPEG, PNG, or WebP image.' };\r\n    }\r\n\r\n    // Decode base64 data\r\n    const base64Data = fileData.replace(/^data:image\\/\\w+;base64,/, '');\r\n    const buffer = Buffer.from(base64Data, 'base64');\r\n\r\n    // Validate file size (max 5MB)\r\n    const maxSize = 5 * 1024 * 1024; // 5MB in bytes\r\n    if (buffer.length > maxSize) {\r\n      return { success: false, error: 'File size too large. Please upload an image smaller than 5MB.' };\r\n    }\r\n\r\n    // Generate unique filename using email and timestamp\r\n    const fileExt = fileName.split('.').pop() || 'jpg';\r\n    const sanitizedEmail = email.replace(/[^a-zA-Z0-9]/g, '_');\r\n    const uniqueFileName = `${sanitizedEmail}_${Date.now()}.${fileExt}`;\r\n    const filePath = `avatars/${uniqueFileName}`;\r\n\r\n    // Upload to Supabase Storage\r\n    const { data: uploadData, error: uploadError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .upload(filePath, buffer, {\r\n        contentType: fileType,\r\n        upsert: false,\r\n      });\r\n\r\n    if (uploadError) {\r\n      console.error('Error uploading file:', uploadError);\r\n      // If bucket doesn't exist, return helpful error\r\n      if (uploadError.message.includes('not found') || uploadError.message.includes('Bucket')) {\r\n        return { \r\n          success: false, \r\n          error: 'Storage bucket not configured. Please create a \"profile-pictures\" bucket in Supabase Storage.' \r\n        };\r\n      }\r\n      return { success: false, error: uploadError.message };\r\n    }\r\n\r\n    // Get public URL\r\n    const { data: urlData } = supabase.storage\r\n      .from('profile-pictures')\r\n      .getPublicUrl(filePath);\r\n\r\n    return { success: true, url: urlData.publicUrl };\r\n  } catch (error) {\r\n    console.error('Error in uploadProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to upload profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteProfilePicture(email: string, avatarUrl: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Extract file path from URL\r\n    // URL format: https://[project].supabase.co/storage/v1/object/public/profile-pictures/avatars/filename.jpg\r\n    const urlPattern = /\\/profile-pictures\\/(.+)$/;\r\n    const match = avatarUrl.match(urlPattern);\r\n    \r\n    if (!match || !match[1]) {\r\n      // If URL doesn't match expected pattern, try alternative parsing\r\n      const urlParts = avatarUrl.split('/avatars/');\r\n      if (urlParts.length < 2) {\r\n        // If we can't parse the URL, just return success (the file might already be deleted)\r\n        console.warn('Could not parse avatar URL for deletion:', avatarUrl);\r\n        return { success: true };\r\n      }\r\n      const filePath = `avatars/${urlParts[1].split('?')[0]}`;\r\n      const { error: deleteError } = await supabase.storage\r\n        .from('profile-pictures')\r\n        .remove([filePath]);\r\n\r\n      if (deleteError && !deleteError.message.includes('not found')) {\r\n        console.error('Error deleting file:', deleteError);\r\n        return { success: false, error: deleteError.message };\r\n      }\r\n      return { success: true };\r\n    }\r\n\r\n    const filePath = match[1].split('?')[0]; // Remove query parameters if any\r\n\r\n    // Delete from storage\r\n    const { error: deleteError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .remove([filePath]);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting file:', deleteError);\r\n      // Don't fail if file doesn't exist\r\n      if (deleteError.message.includes('not found') || deleteError.message.includes('No such file')) {\r\n        return { success: true };\r\n      }\r\n      return { success: false, error: deleteError.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteProfilePicture:', error);\r\n    // Don't fail completely - the URL in database will be removed anyway\r\n    return { success: true };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    // If avatar_url is being removed, delete the old file\r\n    if (existingProfile?.avatar_url && data.avatar_url === null) {\r\n      await deleteProfilePicture(email, existingProfile.avatar_url);\r\n    }\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const updateData: any = {\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      // Only update avatar_url if it's provided\r\n      if (data.avatar_url !== undefined) {\r\n        updateData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update(updateData)\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const insertData: any = {\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n      };\r\n\r\n      // Only set avatar_url if it's provided\r\n      if (data.avatar_url) {\r\n        insertData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert(insertData)\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MA6sBsB,yBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,mDAAA"}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function uploadProfilePicture(\r\n  email: string,\r\n  fileData: string, // base64 encoded string\r\n  fileName: string,\r\n  fileType: string\r\n): Promise<{\r\n  success: boolean;\r\n  url?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate file type\r\n    const validImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\r\n    if (!validImageTypes.includes(fileType)) {\r\n      return { success: false, error: 'Invalid file type. Please upload a JPEG, PNG, or WebP image.' };\r\n    }\r\n\r\n    // Decode base64 data\r\n    const base64Data = fileData.replace(/^data:image\\/\\w+;base64,/, '');\r\n    const buffer = Buffer.from(base64Data, 'base64');\r\n\r\n    // Validate file size (max 5MB)\r\n    const maxSize = 5 * 1024 * 1024; // 5MB in bytes\r\n    if (buffer.length > maxSize) {\r\n      return { success: false, error: 'File size too large. Please upload an image smaller than 5MB.' };\r\n    }\r\n\r\n    // Generate unique filename using email and timestamp\r\n    const fileExt = fileName.split('.').pop() || 'jpg';\r\n    const sanitizedEmail = email.replace(/[^a-zA-Z0-9]/g, '_');\r\n    const uniqueFileName = `${sanitizedEmail}_${Date.now()}.${fileExt}`;\r\n    const filePath = `avatars/${uniqueFileName}`;\r\n\r\n    // Upload to Supabase Storage\r\n    const { data: uploadData, error: uploadError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .upload(filePath, buffer, {\r\n        contentType: fileType,\r\n        upsert: false,\r\n      });\r\n\r\n    if (uploadError) {\r\n      console.error('Error uploading file:', uploadError);\r\n      // If bucket doesn't exist, return helpful error\r\n      if (uploadError.message.includes('not found') || uploadError.message.includes('Bucket')) {\r\n        return { \r\n          success: false, \r\n          error: 'Storage bucket not configured. Please create a \"profile-pictures\" bucket in Supabase Storage.' \r\n        };\r\n      }\r\n      return { success: false, error: uploadError.message };\r\n    }\r\n\r\n    // Get public URL\r\n    const { data: urlData } = supabase.storage\r\n      .from('profile-pictures')\r\n      .getPublicUrl(filePath);\r\n\r\n    return { success: true, url: urlData.publicUrl };\r\n  } catch (error) {\r\n    console.error('Error in uploadProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to upload profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteProfilePicture(email: string, avatarUrl: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Extract file path from URL\r\n    // URL format: https://[project].supabase.co/storage/v1/object/public/profile-pictures/avatars/filename.jpg\r\n    const urlPattern = /\\/profile-pictures\\/(.+)$/;\r\n    const match = avatarUrl.match(urlPattern);\r\n    \r\n    if (!match || !match[1]) {\r\n      // If URL doesn't match expected pattern, try alternative parsing\r\n      const urlParts = avatarUrl.split('/avatars/');\r\n      if (urlParts.length < 2) {\r\n        // If we can't parse the URL, just return success (the file might already be deleted)\r\n        console.warn('Could not parse avatar URL for deletion:', avatarUrl);\r\n        return { success: true };\r\n      }\r\n      const filePath = `avatars/${urlParts[1].split('?')[0]}`;\r\n      const { error: deleteError } = await supabase.storage\r\n        .from('profile-pictures')\r\n        .remove([filePath]);\r\n\r\n      if (deleteError && !deleteError.message.includes('not found')) {\r\n        console.error('Error deleting file:', deleteError);\r\n        return { success: false, error: deleteError.message };\r\n      }\r\n      return { success: true };\r\n    }\r\n\r\n    const filePath = match[1].split('?')[0]; // Remove query parameters if any\r\n\r\n    // Delete from storage\r\n    const { error: deleteError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .remove([filePath]);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting file:', deleteError);\r\n      // Don't fail if file doesn't exist\r\n      if (deleteError.message.includes('not found') || deleteError.message.includes('No such file')) {\r\n        return { success: true };\r\n      }\r\n      return { success: false, error: deleteError.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteProfilePicture:', error);\r\n    // Don't fail completely - the URL in database will be removed anyway\r\n    return { success: true };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    // If avatar_url is being removed, delete the old file\r\n    if (existingProfile?.avatar_url && data.avatar_url === null) {\r\n      await deleteProfilePicture(email, existingProfile.avatar_url);\r\n    }\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const updateData: any = {\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      // Only update avatar_url if it's provided\r\n      if (data.avatar_url !== undefined) {\r\n        updateData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update(updateData)\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const insertData: any = {\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n      };\r\n\r\n      // Only set avatar_url if it's provided\r\n      if (data.avatar_url) {\r\n        insertData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert(insertData)\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAwuBsB,yBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function uploadProfilePicture(\r\n  email: string,\r\n  fileData: string, // base64 encoded string\r\n  fileName: string,\r\n  fileType: string\r\n): Promise<{\r\n  success: boolean;\r\n  url?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate file type\r\n    const validImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\r\n    if (!validImageTypes.includes(fileType)) {\r\n      return { success: false, error: 'Invalid file type. Please upload a JPEG, PNG, or WebP image.' };\r\n    }\r\n\r\n    // Decode base64 data\r\n    const base64Data = fileData.replace(/^data:image\\/\\w+;base64,/, '');\r\n    const buffer = Buffer.from(base64Data, 'base64');\r\n\r\n    // Validate file size (max 5MB)\r\n    const maxSize = 5 * 1024 * 1024; // 5MB in bytes\r\n    if (buffer.length > maxSize) {\r\n      return { success: false, error: 'File size too large. Please upload an image smaller than 5MB.' };\r\n    }\r\n\r\n    // Generate unique filename using email and timestamp\r\n    const fileExt = fileName.split('.').pop() || 'jpg';\r\n    const sanitizedEmail = email.replace(/[^a-zA-Z0-9]/g, '_');\r\n    const uniqueFileName = `${sanitizedEmail}_${Date.now()}.${fileExt}`;\r\n    const filePath = `avatars/${uniqueFileName}`;\r\n\r\n    // Upload to Supabase Storage\r\n    const { data: uploadData, error: uploadError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .upload(filePath, buffer, {\r\n        contentType: fileType,\r\n        upsert: false,\r\n      });\r\n\r\n    if (uploadError) {\r\n      console.error('Error uploading file:', uploadError);\r\n      // If bucket doesn't exist, return helpful error\r\n      if (uploadError.message.includes('not found') || uploadError.message.includes('Bucket')) {\r\n        return { \r\n          success: false, \r\n          error: 'Storage bucket not configured. Please create a \"profile-pictures\" bucket in Supabase Storage.' \r\n        };\r\n      }\r\n      return { success: false, error: uploadError.message };\r\n    }\r\n\r\n    // Get public URL\r\n    const { data: urlData } = supabase.storage\r\n      .from('profile-pictures')\r\n      .getPublicUrl(filePath);\r\n\r\n    return { success: true, url: urlData.publicUrl };\r\n  } catch (error) {\r\n    console.error('Error in uploadProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to upload profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteProfilePicture(email: string, avatarUrl: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Extract file path from URL\r\n    // URL format: https://[project].supabase.co/storage/v1/object/public/profile-pictures/avatars/filename.jpg\r\n    const urlPattern = /\\/profile-pictures\\/(.+)$/;\r\n    const match = avatarUrl.match(urlPattern);\r\n    \r\n    if (!match || !match[1]) {\r\n      // If URL doesn't match expected pattern, try alternative parsing\r\n      const urlParts = avatarUrl.split('/avatars/');\r\n      if (urlParts.length < 2) {\r\n        // If we can't parse the URL, just return success (the file might already be deleted)\r\n        console.warn('Could not parse avatar URL for deletion:', avatarUrl);\r\n        return { success: true };\r\n      }\r\n      const filePath = `avatars/${urlParts[1].split('?')[0]}`;\r\n      const { error: deleteError } = await supabase.storage\r\n        .from('profile-pictures')\r\n        .remove([filePath]);\r\n\r\n      if (deleteError && !deleteError.message.includes('not found')) {\r\n        console.error('Error deleting file:', deleteError);\r\n        return { success: false, error: deleteError.message };\r\n      }\r\n      return { success: true };\r\n    }\r\n\r\n    const filePath = match[1].split('?')[0]; // Remove query parameters if any\r\n\r\n    // Delete from storage\r\n    const { error: deleteError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .remove([filePath]);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting file:', deleteError);\r\n      // Don't fail if file doesn't exist\r\n      if (deleteError.message.includes('not found') || deleteError.message.includes('No such file')) {\r\n        return { success: true };\r\n      }\r\n      return { success: false, error: deleteError.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteProfilePicture:', error);\r\n    // Don't fail completely - the URL in database will be removed anyway\r\n    return { success: true };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    // If avatar_url is being removed, delete the old file\r\n    if (existingProfile?.avatar_url && data.avatar_url === null) {\r\n      await deleteProfilePicture(email, existingProfile.avatar_url);\r\n    }\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const updateData: any = {\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      // Only update avatar_url if it's provided\r\n      if (data.avatar_url !== undefined) {\r\n        updateData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update(updateData)\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const insertData: any = {\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n      };\r\n\r\n      // Only set avatar_url if it's provided\r\n      if (data.avatar_url) {\r\n        insertData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert(insertData)\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAOsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/badge.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst badgeVariants = cva(\r\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\r\n        secondary: \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        destructive: \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\r\n        outline: \"text-foreground\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n    },\r\n  },\r\n);\r\n\r\nexport interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}\r\n\r\nfunction Badge({ className, variant, ...props }: BadgeProps) {\r\n  return <div className={cn(badgeVariants({ variant }), className)} {...props} />;\r\n}\r\n\r\nexport { Badge, badgeVariants };\r\n"],"names":[],"mappings":";;;;;;;AACA;AAEA;;;;AAEA,MAAM,gBAAgB,IAAA,uKAAG,EACvB,0KACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,WAAW;YACX,aAAa;YACb,SAAS;QACX;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAKF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBAAO,8OAAC;QAAI,WAAW,IAAA,yHAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAC7E"}},
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/locations/components/LocationCard.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { Location } from '@/types/location';\r\nimport { Card, CardContent, CardHeader } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Button } from '@/components/ui/button';\r\nimport { MapPin, Edit, Trash2, Star } from 'lucide-react';\r\n\r\ninterface LocationCardProps {\r\n  location: Location;\r\n  onEdit: (location: Location) => void;\r\n  onDelete: (locationId: string) => void;\r\n  onSetDefault: (locationId: string) => void;\r\n  isDeleting?: boolean;\r\n}\r\n\r\nexport function LocationCard({\r\n  location,\r\n  onEdit,\r\n  onDelete,\r\n  onSetDefault,\r\n  isDeleting = false,\r\n}: LocationCardProps) {\r\n  const fullAddress = [\r\n    location.address,\r\n    location.apt_unit,\r\n    location.suburb,\r\n    location.city,\r\n    location.postal_code,\r\n  ]\r\n    .filter(Boolean)\r\n    .join(', ');\r\n\r\n  return (\r\n    <Card className=\"hover:shadow-md transition-shadow border-border w-full max-w-full overflow-hidden\">\r\n      <CardHeader className=\"pb-2 px-3 py-3 sm:px-4 sm:py-4 md:px-6 md:py-6\">\r\n        <div className=\"flex items-start justify-between gap-2\">\r\n          <div className=\"flex-1 min-w-0\">\r\n            <div className=\"flex items-center gap-2\">\r\n              <h3 className=\"font-semibold text-base sm:text-lg md:text-xl truncate\">\r\n                {location.nickname}\r\n              </h3>\r\n              {location.is_default && (\r\n                <Badge className=\"bg-primary text-primary-foreground text-xs sm:text-sm px-2 sm:px-3 py-0.5\">\r\n                  <Star className=\"w-3 h-3 mr-1\" />\r\n                  Default\r\n                </Badge>\r\n              )}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </CardHeader>\r\n      <CardContent className=\"px-3 pb-3 sm:px-4 sm:pb-4 md:px-6 md:pb-6 pt-0\">\r\n        <div className=\"space-y-3\">\r\n          {/* Address */}\r\n          <div className=\"flex items-start gap-1.5 sm:gap-2 text-sm sm:text-base\">\r\n            <MapPin className=\"w-4 h-4 sm:w-5 sm:h-5 text-muted-foreground mt-0.5 flex-shrink-0\" />\r\n            <span className=\"text-muted-foreground break-words leading-relaxed\">\r\n              {fullAddress}\r\n            </span>\r\n          </div>\r\n\r\n          {/* Actions */}\r\n          <div className=\"flex flex-wrap gap-2 pt-2 border-t border-border\">\r\n            {!location.is_default && (\r\n              <Button\r\n                variant=\"outline\"\r\n                size=\"sm\"\r\n                onClick={() => onSetDefault(location.id)}\r\n                className=\"text-xs sm:text-sm h-8 sm:h-9\"\r\n                disabled={isDeleting}\r\n              >\r\n                <Star className=\"w-3 h-3 sm:w-4 sm:h-4 mr-1.5\" />\r\n                Set Default\r\n              </Button>\r\n            )}\r\n            <Button\r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              onClick={() => onEdit(location)}\r\n              className=\"text-xs sm:text-sm h-8 sm:h-9\"\r\n              disabled={isDeleting}\r\n            >\r\n              <Edit className=\"w-3 h-3 sm:w-4 sm:h-4 mr-1.5\" />\r\n              Edit\r\n            </Button>\r\n            <Button\r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              onClick={() => onDelete(location.id)}\r\n              className=\"text-xs sm:text-sm h-8 sm:h-9 text-destructive hover:text-destructive\"\r\n              disabled={isDeleting}\r\n            >\r\n              <Trash2 className=\"w-3 h-3 sm:w-4 sm:h-4 mr-1.5\" />\r\n              Delete\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AANA;;;;;;AAgBO,SAAS,aAAa,EAC3B,QAAQ,EACR,MAAM,EACN,QAAQ,EACR,YAAY,EACZ,aAAa,KAAK,EACA;IAClB,MAAM,cAAc;QAClB,SAAS,OAAO;QAChB,SAAS,QAAQ;QACjB,SAAS,MAAM;QACf,SAAS,IAAI;QACb,SAAS,WAAW;KACrB,CACE,MAAM,CAAC,SACP,IAAI,CAAC;IAER,qBACE,8OAAC,wIAAI;QAAC,WAAU;;0BACd,8OAAC,8IAAU;gBAAC,WAAU;0BACpB,cAAA,8OAAC;oBAAI,WAAU;8BACb,cAAA,8OAAC;wBAAI,WAAU;kCACb,cAAA,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAG,WAAU;8CACX,SAAS,QAAQ;;;;;;gCAEnB,SAAS,UAAU,kBAClB,8OAAC,0IAAK;oCAAC,WAAU;;sDACf,8OAAC,0MAAI;4CAAC,WAAU;;;;;;wCAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAQ7C,8OAAC,+IAAW;gBAAC,WAAU;0BACrB,cAAA,8OAAC;oBAAI,WAAU;;sCAEb,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,oNAAM;oCAAC,WAAU;;;;;;8CAClB,8OAAC;oCAAK,WAAU;8CACb;;;;;;;;;;;;sCAKL,8OAAC;4BAAI,WAAU;;gCACZ,CAAC,SAAS,UAAU,kBACnB,8OAAC,4IAAM;oCACL,SAAQ;oCACR,MAAK;oCACL,SAAS,IAAM,aAAa,SAAS,EAAE;oCACvC,WAAU;oCACV,UAAU;;sDAEV,8OAAC,0MAAI;4CAAC,WAAU;;;;;;wCAAiC;;;;;;;8CAIrD,8OAAC,4IAAM;oCACL,SAAQ;oCACR,MAAK;oCACL,SAAS,IAAM,OAAO;oCACtB,WAAU;oCACV,UAAU;;sDAEV,8OAAC,mNAAI;4CAAC,WAAU;;;;;;wCAAiC;;;;;;;8CAGnD,8OAAC,4IAAM;oCACL,SAAQ;oCACR,MAAK;oCACL,SAAS,IAAM,SAAS,SAAS,EAAE;oCACnC,WAAU;oCACV,UAAU;;sDAEV,8OAAC,oNAAM;4CAAC,WAAU;;;;;;wCAAiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQjE"}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/label.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as LabelPrimitive from \"@radix-ui/react-label\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst labelVariants = cva(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\");\r\n\r\nconst Label = React.forwardRef<\r\n  React.ElementRef<typeof LabelPrimitive.Root>,\r\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>\r\n>(({ className, ...props }, ref) => (\r\n  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />\r\n));\r\nLabel.displayName = LabelPrimitive.Root.displayName;\r\n\r\nexport { Label };\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,gBAAgB,IAAA,uKAAG,EAAC;AAE1B,MAAM,sBAAQ,mNAAgB,CAG5B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,yKAAmB;QAAC,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,iBAAiB;QAAa,GAAG,KAAK;;;;;;AAErF,MAAM,WAAW,GAAG,yKAAmB,CAAC,WAAW"}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/checkbox.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\";\r\nimport { Check } from \"lucide-react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Checkbox = React.forwardRef<\r\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\r\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\r\n>(({ className, ...props }, ref) => (\r\n  <CheckboxPrimitive.Root\r\n    ref={ref}\r\n    className={cn(\r\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n      className,\r\n    )}\r\n    {...props}\r\n  >\r\n    <CheckboxPrimitive.Indicator className={cn(\"flex items-center justify-center text-current\")}>\r\n      <Check className=\"h-4 w-4\" />\r\n    </CheckboxPrimitive.Indicator>\r\n  </CheckboxPrimitive.Root>\r\n));\r\nCheckbox.displayName = CheckboxPrimitive.Root.displayName;\r\n\r\nexport { Checkbox };\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,yBAAW,mNAAgB,CAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,4KAAsB;QACrB,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,kTACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,iLAA2B;YAAC,WAAW,IAAA,yHAAE,EAAC;sBACzC,cAAA,8OAAC,6MAAK;gBAAC,WAAU;;;;;;;;;;;;;;;;AAIvB,SAAS,WAAW,GAAG,4KAAsB,CAAC,WAAW"}},
    {"offset": {"line": 495, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/locations/components/LocationForm.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useState } from 'react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Checkbox } from '@/components/ui/checkbox';\r\nimport { Loader2, MapPin } from 'lucide-react';\r\nimport { LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\ninterface LocationFormProps {\r\n  initialData?: {\r\n    id: string;\r\n    nickname: string;\r\n    address: string;\r\n    apt_unit: string | null;\r\n    suburb: string;\r\n    city: string;\r\n    postal_code: string | null;\r\n    is_default: boolean;\r\n  };\r\n  onSubmit: (data: LocationCreateInput | LocationUpdateInput) => Promise<void>;\r\n  onCancel?: () => void;\r\n  isLoading?: boolean;\r\n}\r\n\r\nexport function LocationForm({ initialData, onSubmit, onCancel, isLoading = false }: LocationFormProps) {\r\n  const [formData, setFormData] = useState({\r\n    nickname: initialData?.nickname || '',\r\n    address: initialData?.address || '',\r\n    apt_unit: initialData?.apt_unit || '',\r\n    suburb: initialData?.suburb || '',\r\n    city: initialData?.city || '',\r\n    postal_code: initialData?.postal_code || '',\r\n    is_default: initialData?.is_default || false,\r\n  });\r\n\r\n  const handleSubmit = async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n\r\n    // Validation\r\n    if (!formData.nickname.trim()) {\r\n      return;\r\n    }\r\n    if (!formData.address.trim()) {\r\n      return;\r\n    }\r\n    if (!formData.suburb.trim()) {\r\n      return;\r\n    }\r\n    if (!formData.city.trim()) {\r\n      return;\r\n    }\r\n\r\n    const submitData: LocationCreateInput | LocationUpdateInput = {\r\n      nickname: formData.nickname.trim(),\r\n      address: formData.address.trim(),\r\n      apt_unit: formData.apt_unit.trim() || null,\r\n      suburb: formData.suburb.trim(),\r\n      city: formData.city.trim(),\r\n      postal_code: formData.postal_code.trim() || null,\r\n      is_default: formData.is_default,\r\n    };\r\n\r\n    await onSubmit(submitData);\r\n  };\r\n\r\n  const handleInputChange = (field: keyof typeof formData, value: string | boolean) => {\r\n    setFormData((prev) => ({ ...prev, [field]: value }));\r\n  };\r\n\r\n  return (\r\n    <Card>\r\n      <CardHeader>\r\n        <CardTitle className=\"flex items-center gap-2\">\r\n          <MapPin className=\"w-5 h-5\" />\r\n          {initialData ? 'Edit Location' : 'Add New Location'}\r\n        </CardTitle>\r\n        <CardDescription>\r\n          {initialData\r\n            ? 'Update your location details below.'\r\n            : 'Save a location for quick access when booking services.'}\r\n        </CardDescription>\r\n      </CardHeader>\r\n      <CardContent>\r\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\r\n          {/* Nickname */}\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"nickname\">Nickname *</Label>\r\n            <Input\r\n              id=\"nickname\"\r\n              placeholder=\"e.g., Home, Office, Apartment\"\r\n              value={formData.nickname}\r\n              onChange={(e) => handleInputChange('nickname', e.target.value)}\r\n              required\r\n              disabled={isLoading}\r\n            />\r\n          </div>\r\n\r\n          {/* Address */}\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"address\">Street Address *</Label>\r\n            <Input\r\n              id=\"address\"\r\n              placeholder=\"123 Main Street\"\r\n              value={formData.address}\r\n              onChange={(e) => handleInputChange('address', e.target.value)}\r\n              required\r\n              disabled={isLoading}\r\n            />\r\n          </div>\r\n\r\n          {/* Apartment/Unit */}\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"apt_unit\">Apartment/Unit</Label>\r\n            <Input\r\n              id=\"apt_unit\"\r\n              placeholder=\"Apt 4B, Unit 12, etc.\"\r\n              value={formData.apt_unit}\r\n              onChange={(e) => handleInputChange('apt_unit', e.target.value)}\r\n              disabled={isLoading}\r\n            />\r\n          </div>\r\n\r\n          {/* Suburb and City */}\r\n          <div className=\"grid md:grid-cols-2 gap-4\">\r\n            <div className=\"space-y-2\">\r\n              <Label htmlFor=\"suburb\">Suburb *</Label>\r\n              <Input\r\n                id=\"suburb\"\r\n                placeholder=\"Sandton\"\r\n                value={formData.suburb}\r\n                onChange={(e) => handleInputChange('suburb', e.target.value)}\r\n                required\r\n                disabled={isLoading}\r\n              />\r\n            </div>\r\n            <div className=\"space-y-2\">\r\n              <Label htmlFor=\"city\">City *</Label>\r\n              <Input\r\n                id=\"city\"\r\n                placeholder=\"Johannesburg\"\r\n                value={formData.city}\r\n                onChange={(e) => handleInputChange('city', e.target.value)}\r\n                required\r\n                disabled={isLoading}\r\n              />\r\n            </div>\r\n          </div>\r\n\r\n          {/* Postal Code */}\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"postal_code\">Postal Code</Label>\r\n            <Input\r\n              id=\"postal_code\"\r\n              placeholder=\"2196\"\r\n              value={formData.postal_code}\r\n              onChange={(e) => handleInputChange('postal_code', e.target.value)}\r\n              disabled={isLoading}\r\n            />\r\n          </div>\r\n\r\n          {/* Default Location */}\r\n          <div className=\"flex items-center space-x-2 pt-2\">\r\n            <Checkbox\r\n              id=\"is_default\"\r\n              checked={formData.is_default}\r\n              onCheckedChange={(checked) => handleInputChange('is_default', checked === true)}\r\n              disabled={isLoading}\r\n            />\r\n            <Label\r\n              htmlFor=\"is_default\"\r\n              className=\"text-sm font-normal cursor-pointer\"\r\n            >\r\n              Set as default location\r\n            </Label>\r\n          </div>\r\n\r\n          {/* Form Actions */}\r\n          <div className=\"flex justify-end gap-3 pt-4\">\r\n            {onCancel && (\r\n              <Button\r\n                type=\"button\"\r\n                variant=\"outline\"\r\n                onClick={onCancel}\r\n                disabled={isLoading}\r\n              >\r\n                Cancel\r\n              </Button>\r\n            )}\r\n            <Button type=\"submit\" disabled={isLoading}>\r\n              {isLoading ? (\r\n                <>\r\n                  <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" />\r\n                  {initialData ? 'Updating...' : 'Creating...'}\r\n                </>\r\n              ) : (\r\n                initialData ? 'Update Location' : 'Create Location'\r\n              )}\r\n            </Button>\r\n          </div>\r\n        </form>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AARA;;;;;;;;;AA2BO,SAAS,aAAa,EAAE,WAAW,EAAE,QAAQ,EAAE,QAAQ,EAAE,YAAY,KAAK,EAAqB;IACpG,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,iNAAQ,EAAC;QACvC,UAAU,aAAa,YAAY;QACnC,SAAS,aAAa,WAAW;QACjC,UAAU,aAAa,YAAY;QACnC,QAAQ,aAAa,UAAU;QAC/B,MAAM,aAAa,QAAQ;QAC3B,aAAa,aAAa,eAAe;QACzC,YAAY,aAAa,cAAc;IACzC;IAEA,MAAM,eAAe,OAAO;QAC1B,EAAE,cAAc;QAEhB,aAAa;QACb,IAAI,CAAC,SAAS,QAAQ,CAAC,IAAI,IAAI;YAC7B;QACF;QACA,IAAI,CAAC,SAAS,OAAO,CAAC,IAAI,IAAI;YAC5B;QACF;QACA,IAAI,CAAC,SAAS,MAAM,CAAC,IAAI,IAAI;YAC3B;QACF;QACA,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,IAAI;YACzB;QACF;QAEA,MAAM,aAAwD;YAC5D,UAAU,SAAS,QAAQ,CAAC,IAAI;YAChC,SAAS,SAAS,OAAO,CAAC,IAAI;YAC9B,UAAU,SAAS,QAAQ,CAAC,IAAI,MAAM;YACtC,QAAQ,SAAS,MAAM,CAAC,IAAI;YAC5B,MAAM,SAAS,IAAI,CAAC,IAAI;YACxB,aAAa,SAAS,WAAW,CAAC,IAAI,MAAM;YAC5C,YAAY,SAAS,UAAU;QACjC;QAEA,MAAM,SAAS;IACjB;IAEA,MAAM,oBAAoB,CAAC,OAA8B;QACvD,YAAY,CAAC,OAAS,CAAC;gBAAE,GAAG,IAAI;gBAAE,CAAC,MAAM,EAAE;YAAM,CAAC;IACpD;IAEA,qBACE,8OAAC,wIAAI;;0BACH,8OAAC,8IAAU;;kCACT,8OAAC,6IAAS;wBAAC,WAAU;;0CACnB,8OAAC,oNAAM;gCAAC,WAAU;;;;;;4BACjB,cAAc,kBAAkB;;;;;;;kCAEnC,8OAAC,mJAAe;kCACb,cACG,wCACA;;;;;;;;;;;;0BAGR,8OAAC,+IAAW;0BACV,cAAA,8OAAC;oBAAK,UAAU;oBAAc,WAAU;;sCAEtC,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,0IAAK;oCAAC,SAAQ;8CAAW;;;;;;8CAC1B,8OAAC,0IAAK;oCACJ,IAAG;oCACH,aAAY;oCACZ,OAAO,SAAS,QAAQ;oCACxB,UAAU,CAAC,IAAM,kBAAkB,YAAY,EAAE,MAAM,CAAC,KAAK;oCAC7D,QAAQ;oCACR,UAAU;;;;;;;;;;;;sCAKd,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,0IAAK;oCAAC,SAAQ;8CAAU;;;;;;8CACzB,8OAAC,0IAAK;oCACJ,IAAG;oCACH,aAAY;oCACZ,OAAO,SAAS,OAAO;oCACvB,UAAU,CAAC,IAAM,kBAAkB,WAAW,EAAE,MAAM,CAAC,KAAK;oCAC5D,QAAQ;oCACR,UAAU;;;;;;;;;;;;sCAKd,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,0IAAK;oCAAC,SAAQ;8CAAW;;;;;;8CAC1B,8OAAC,0IAAK;oCACJ,IAAG;oCACH,aAAY;oCACZ,OAAO,SAAS,QAAQ;oCACxB,UAAU,CAAC,IAAM,kBAAkB,YAAY,EAAE,MAAM,CAAC,KAAK;oCAC7D,UAAU;;;;;;;;;;;;sCAKd,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAI,WAAU;;sDACb,8OAAC,0IAAK;4CAAC,SAAQ;sDAAS;;;;;;sDACxB,8OAAC,0IAAK;4CACJ,IAAG;4CACH,aAAY;4CACZ,OAAO,SAAS,MAAM;4CACtB,UAAU,CAAC,IAAM,kBAAkB,UAAU,EAAE,MAAM,CAAC,KAAK;4CAC3D,QAAQ;4CACR,UAAU;;;;;;;;;;;;8CAGd,8OAAC;oCAAI,WAAU;;sDACb,8OAAC,0IAAK;4CAAC,SAAQ;sDAAO;;;;;;sDACtB,8OAAC,0IAAK;4CACJ,IAAG;4CACH,aAAY;4CACZ,OAAO,SAAS,IAAI;4CACpB,UAAU,CAAC,IAAM,kBAAkB,QAAQ,EAAE,MAAM,CAAC,KAAK;4CACzD,QAAQ;4CACR,UAAU;;;;;;;;;;;;;;;;;;sCAMhB,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,0IAAK;oCAAC,SAAQ;8CAAc;;;;;;8CAC7B,8OAAC,0IAAK;oCACJ,IAAG;oCACH,aAAY;oCACZ,OAAO,SAAS,WAAW;oCAC3B,UAAU,CAAC,IAAM,kBAAkB,eAAe,EAAE,MAAM,CAAC,KAAK;oCAChE,UAAU;;;;;;;;;;;;sCAKd,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,gJAAQ;oCACP,IAAG;oCACH,SAAS,SAAS,UAAU;oCAC5B,iBAAiB,CAAC,UAAY,kBAAkB,cAAc,YAAY;oCAC1E,UAAU;;;;;;8CAEZ,8OAAC,0IAAK;oCACJ,SAAQ;oCACR,WAAU;8CACX;;;;;;;;;;;;sCAMH,8OAAC;4BAAI,WAAU;;gCACZ,0BACC,8OAAC,4IAAM;oCACL,MAAK;oCACL,SAAQ;oCACR,SAAS;oCACT,UAAU;8CACX;;;;;;8CAIH,8OAAC,4IAAM;oCAAC,MAAK;oCAAS,UAAU;8CAC7B,0BACC;;0DACE,8OAAC,4NAAO;gDAAC,WAAU;;;;;;4CAClB,cAAc,gBAAgB;;uDAGjC,cAAc,oBAAoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQlD"}},
    {"offset": {"line": 869, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/locations/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useEffect, useState } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { Card, CardContent } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { MapPin, Loader2, Plus } from 'lucide-react';\r\nimport { toast } from 'sonner';\r\nimport {\r\n  getCustomerLocations,\r\n  createLocation,\r\n  updateLocation,\r\n  deleteLocation,\r\n  setDefaultLocation,\r\n  getAuthenticatedUser,\r\n} from '../actions';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\nimport { LocationCard } from './components/LocationCard';\r\nimport { LocationForm } from './components/LocationForm';\r\n\r\nexport default function LocationsPage() {\r\n  const [loading, setLoading] = useState(true);\r\n  const [saving, setSaving] = useState(false);\r\n  const [deleting, setDeleting] = useState<string | null>(null);\r\n  const [locations, setLocations] = useState<Location[]>([]);\r\n  const [editingLocation, setEditingLocation] = useState<Location | null>(null);\r\n  const [showForm, setShowForm] = useState(false);\r\n  const [userEmail, setUserEmail] = useState<string | null>(null);\r\n\r\n  // Get authenticated user's email\r\n  useQuery({\r\n    queryKey: ['authenticated-user'],\r\n    queryFn: async () => {\r\n      const result = await getAuthenticatedUser();\r\n      if (result.success && result.email) {\r\n        setUserEmail(result.email);\r\n        return result.email;\r\n      }\r\n      return null;\r\n    },\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Load locations data when user email is available\r\n  useEffect(() => {\r\n    const loadLocations = async () => {\r\n      if (!userEmail) {\r\n        setLoading(true);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        setLoading(true);\r\n        const result = await getCustomerLocations(userEmail);\r\n\r\n        if (result.success && result.locations) {\r\n          setLocations(result.locations);\r\n        } else {\r\n          toast.error(result.error || 'Failed to load locations');\r\n        }\r\n      } catch (error) {\r\n        console.error('Error loading locations:', error);\r\n        toast.error('An unexpected error occurred');\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    loadLocations();\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [userEmail]);\r\n\r\n  const handleCreateLocation = async (data: LocationCreateInput) => {\r\n    if (!userEmail) {\r\n      toast.error('Please wait for authentication');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setSaving(true);\r\n      const result = await createLocation(userEmail, undefined, data);\r\n\r\n      if (result.success && result.location) {\r\n        setLocations((prev) => [result.location!, ...prev]);\r\n        setShowForm(false);\r\n        setEditingLocation(null);\r\n        toast.success('Location created successfully!');\r\n      } else {\r\n        toast.error(result.error || 'Failed to create location');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error creating location:', error);\r\n      toast.error('An unexpected error occurred');\r\n    } finally {\r\n      setSaving(false);\r\n    }\r\n  };\r\n\r\n  const handleUpdateLocation = async (data: LocationUpdateInput) => {\r\n    if (!editingLocation) return;\r\n\r\n    try {\r\n      setSaving(true);\r\n      const result = await updateLocation(editingLocation.id, data);\r\n\r\n      if (result.success && result.location) {\r\n        setLocations((prev) =>\r\n          prev.map((loc) => (loc.id === editingLocation.id ? result.location! : loc))\r\n        );\r\n        setShowForm(false);\r\n        setEditingLocation(null);\r\n        toast.success('Location updated successfully!');\r\n      } else {\r\n        toast.error(result.error || 'Failed to update location');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error updating location:', error);\r\n      toast.error('An unexpected error occurred');\r\n    } finally {\r\n      setSaving(false);\r\n    }\r\n  };\r\n\r\n  const handleDeleteLocation = async (locationId: string) => {\r\n    if (!confirm('Are you sure you want to delete this location?')) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setDeleting(locationId);\r\n      const result = await deleteLocation(locationId);\r\n\r\n      if (result.success) {\r\n        setLocations((prev) => prev.filter((loc) => loc.id !== locationId));\r\n        toast.success('Location deleted successfully!');\r\n      } else {\r\n        toast.error(result.error || 'Failed to delete location');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error deleting location:', error);\r\n      toast.error('An unexpected error occurred');\r\n    } finally {\r\n      setDeleting(null);\r\n    }\r\n  };\r\n\r\n  const handleSetDefault = async (locationId: string) => {\r\n    if (!userEmail) {\r\n      toast.error('Please wait for authentication');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const result = await setDefaultLocation(locationId, userEmail);\r\n\r\n      if (result.success && result.location) {\r\n        setLocations((prev) =>\r\n          prev.map((loc) => ({\r\n            ...loc,\r\n            is_default: loc.id === locationId,\r\n          }))\r\n        );\r\n        toast.success('Default location updated!');\r\n      } else {\r\n        toast.error(result.error || 'Failed to set default location');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error setting default location:', error);\r\n      toast.error('An unexpected error occurred');\r\n    }\r\n  };\r\n\r\n  const handleEdit = (location: Location) => {\r\n    setEditingLocation(location);\r\n    setShowForm(true);\r\n  };\r\n\r\n  const handleCancelForm = () => {\r\n    setShowForm(false);\r\n    setEditingLocation(null);\r\n  };\r\n\r\n  const handleNewLocation = () => {\r\n    setEditingLocation(null);\r\n    setShowForm(true);\r\n  };\r\n\r\n  if (loading || !userEmail) {\r\n    return (\r\n      <div className=\"space-y-6\">\r\n        <div>\r\n          <h1 className=\"text-3xl font-bold\">Locations</h1>\r\n          <p className=\"text-muted-foreground\">Manage your saved locations</p>\r\n        </div>\r\n        <Card>\r\n          <CardContent className=\"flex items-center justify-center py-12\">\r\n            <Loader2 className=\"w-8 h-8 animate-spin text-muted-foreground\" />\r\n          </CardContent>\r\n        </Card>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      <div className=\"flex items-center justify-between\">\r\n        <div>\r\n          <h1 className=\"text-3xl font-bold\">Locations</h1>\r\n          <p className=\"text-muted-foreground\">Manage your saved locations</p>\r\n        </div>\r\n        {!showForm && (\r\n          <Button onClick={handleNewLocation} className=\"flex items-center gap-2\">\r\n            <Plus className=\"w-4 h-4\" />\r\n            Add Location\r\n          </Button>\r\n        )}\r\n      </div>\r\n\r\n      <div className=\"grid lg:grid-cols-2 gap-6\">\r\n        {/* Locations List */}\r\n        <div className=\"space-y-4\">\r\n          <h2 className=\"text-xl font-semibold\">Saved Locations</h2>\r\n          {locations.length === 0 ? (\r\n            <Card>\r\n              <CardContent className=\"flex flex-col items-center justify-center py-12\">\r\n                <MapPin className=\"w-12 h-12 text-muted-foreground mb-4\" />\r\n                <p className=\"text-muted-foreground text-center mb-4\">\r\n                  You don't have any saved locations yet.\r\n                </p>\r\n                <Button onClick={handleNewLocation} variant=\"outline\">\r\n                  <Plus className=\"w-4 h-4 mr-2\" />\r\n                  Add Your First Location\r\n                </Button>\r\n              </CardContent>\r\n            </Card>\r\n          ) : (\r\n            <div className=\"space-y-3\">\r\n              {locations.map((location) => (\r\n                <LocationCard\r\n                  key={location.id}\r\n                  location={location}\r\n                  onEdit={handleEdit}\r\n                  onDelete={handleDeleteLocation}\r\n                  onSetDefault={handleSetDefault}\r\n                  isDeleting={deleting === location.id}\r\n                />\r\n              ))}\r\n            </div>\r\n          )}\r\n        </div>\r\n\r\n        {/* Form Section */}\r\n        <div className=\"space-y-4\">\r\n          {showForm ? (\r\n            <LocationForm\r\n              initialData={editingLocation || undefined}\r\n              onSubmit={editingLocation ? handleUpdateLocation : handleCreateLocation}\r\n              onCancel={handleCancelForm}\r\n              isLoading={saving}\r\n            />\r\n          ) : (\r\n            <Card>\r\n              <CardContent className=\"flex flex-col items-center justify-center py-12\">\r\n                <MapPin className=\"w-12 h-12 text-muted-foreground mb-4\" />\r\n                <p className=\"text-muted-foreground text-center\">\r\n                  {locations.length === 0\r\n                    ? 'Create a new location to get started'\r\n                    : 'Click \"Add Location\" to create a new location'}\r\n                </p>\r\n              </CardContent>\r\n            </Card>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AAlBA;;;;;;;;;;;AAoBe,SAAS;IACtB,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,iNAAQ,EAAC;IACvC,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,iNAAQ,EAAC;IACrC,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,iNAAQ,EAAgB;IACxD,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,iNAAQ,EAAa,EAAE;IACzD,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,IAAA,iNAAQ,EAAkB;IACxE,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,iNAAQ,EAAC;IACzC,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,iNAAQ,EAAgB;IAE1D,iCAAiC;IACjC,IAAA,uLAAQ,EAAC;QACP,UAAU;YAAC;SAAqB;QAChC,SAAS;YACP,MAAM,SAAS,MAAM,IAAA,gLAAoB;YACzC,IAAI,OAAO,OAAO,IAAI,OAAO,KAAK,EAAE;gBAClC,aAAa,OAAO,KAAK;gBACzB,OAAO,OAAO,KAAK;YACrB;YACA,OAAO;QACT;QACA,WAAW,IAAI,KAAK;IACtB;IAEA,mDAAmD;IACnD,IAAA,kNAAS,EAAC;QACR,MAAM,gBAAgB;YACpB,IAAI,CAAC,WAAW;gBACd,WAAW;gBACX;YACF;YAEA,IAAI;gBACF,WAAW;gBACX,MAAM,SAAS,MAAM,IAAA,gLAAoB,EAAC;gBAE1C,IAAI,OAAO,OAAO,IAAI,OAAO,SAAS,EAAE;oBACtC,aAAa,OAAO,SAAS;gBAC/B,OAAO;oBACL,iJAAK,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;gBAC9B;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,4BAA4B;gBAC1C,iJAAK,CAAC,KAAK,CAAC;YACd,SAAU;gBACR,WAAW;YACb;QACF;QAEA;IACA,uDAAuD;IACzD,GAAG;QAAC;KAAU;IAEd,MAAM,uBAAuB,OAAO;QAClC,IAAI,CAAC,WAAW;YACd,iJAAK,CAAC,KAAK,CAAC;YACZ;QACF;QAEA,IAAI;YACF,UAAU;YACV,MAAM,SAAS,MAAM,IAAA,0KAAc,EAAC,WAAW,WAAW;YAE1D,IAAI,OAAO,OAAO,IAAI,OAAO,QAAQ,EAAE;gBACrC,aAAa,CAAC,OAAS;wBAAC,OAAO,QAAQ;2BAAM;qBAAK;gBAClD,YAAY;gBACZ,mBAAmB;gBACnB,iJAAK,CAAC,OAAO,CAAC;YAChB,OAAO;gBACL,iJAAK,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;YAC9B;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,4BAA4B;YAC1C,iJAAK,CAAC,KAAK,CAAC;QACd,SAAU;YACR,UAAU;QACZ;IACF;IAEA,MAAM,uBAAuB,OAAO;QAClC,IAAI,CAAC,iBAAiB;QAEtB,IAAI;YACF,UAAU;YACV,MAAM,SAAS,MAAM,IAAA,0KAAc,EAAC,gBAAgB,EAAE,EAAE;YAExD,IAAI,OAAO,OAAO,IAAI,OAAO,QAAQ,EAAE;gBACrC,aAAa,CAAC,OACZ,KAAK,GAAG,CAAC,CAAC,MAAS,IAAI,EAAE,KAAK,gBAAgB,EAAE,GAAG,OAAO,QAAQ,GAAI;gBAExE,YAAY;gBACZ,mBAAmB;gBACnB,iJAAK,CAAC,OAAO,CAAC;YAChB,OAAO;gBACL,iJAAK,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;YAC9B;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,4BAA4B;YAC1C,iJAAK,CAAC,KAAK,CAAC;QACd,SAAU;YACR,UAAU;QACZ;IACF;IAEA,MAAM,uBAAuB,OAAO;QAClC,IAAI,CAAC,QAAQ,mDAAmD;YAC9D;QACF;QAEA,IAAI;YACF,YAAY;YACZ,MAAM,SAAS,MAAM,IAAA,0KAAc,EAAC;YAEpC,IAAI,OAAO,OAAO,EAAE;gBAClB,aAAa,CAAC,OAAS,KAAK,MAAM,CAAC,CAAC,MAAQ,IAAI,EAAE,KAAK;gBACvD,iJAAK,CAAC,OAAO,CAAC;YAChB,OAAO;gBACL,iJAAK,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;YAC9B;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,4BAA4B;YAC1C,iJAAK,CAAC,KAAK,CAAC;QACd,SAAU;YACR,YAAY;QACd;IACF;IAEA,MAAM,mBAAmB,OAAO;QAC9B,IAAI,CAAC,WAAW;YACd,iJAAK,CAAC,KAAK,CAAC;YACZ;QACF;QAEA,IAAI;YACF,MAAM,SAAS,MAAM,IAAA,8KAAkB,EAAC,YAAY;YAEpD,IAAI,OAAO,OAAO,IAAI,OAAO,QAAQ,EAAE;gBACrC,aAAa,CAAC,OACZ,KAAK,GAAG,CAAC,CAAC,MAAQ,CAAC;4BACjB,GAAG,GAAG;4BACN,YAAY,IAAI,EAAE,KAAK;wBACzB,CAAC;gBAEH,iJAAK,CAAC,OAAO,CAAC;YAChB,OAAO;gBACL,iJAAK,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;YAC9B;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,mCAAmC;YACjD,iJAAK,CAAC,KAAK,CAAC;QACd;IACF;IAEA,MAAM,aAAa,CAAC;QAClB,mBAAmB;QACnB,YAAY;IACd;IAEA,MAAM,mBAAmB;QACvB,YAAY;QACZ,mBAAmB;IACrB;IAEA,MAAM,oBAAoB;QACxB,mBAAmB;QACnB,YAAY;IACd;IAEA,IAAI,WAAW,CAAC,WAAW;QACzB,qBACE,8OAAC;YAAI,WAAU;;8BACb,8OAAC;;sCACC,8OAAC;4BAAG,WAAU;sCAAqB;;;;;;sCACnC,8OAAC;4BAAE,WAAU;sCAAwB;;;;;;;;;;;;8BAEvC,8OAAC,wIAAI;8BACH,cAAA,8OAAC,+IAAW;wBAAC,WAAU;kCACrB,cAAA,8OAAC,4NAAO;4BAAC,WAAU;;;;;;;;;;;;;;;;;;;;;;IAK7B;IAEA,qBACE,8OAAC;QAAI,WAAU;;0BACb,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;;0CACC,8OAAC;gCAAG,WAAU;0CAAqB;;;;;;0CACnC,8OAAC;gCAAE,WAAU;0CAAwB;;;;;;;;;;;;oBAEtC,CAAC,0BACA,8OAAC,4IAAM;wBAAC,SAAS;wBAAmB,WAAU;;0CAC5C,8OAAC,0MAAI;gCAAC,WAAU;;;;;;4BAAY;;;;;;;;;;;;;0BAMlC,8OAAC;gBAAI,WAAU;;kCAEb,8OAAC;wBAAI,WAAU;;0CACb,8OAAC;gCAAG,WAAU;0CAAwB;;;;;;4BACrC,UAAU,MAAM,KAAK,kBACpB,8OAAC,wIAAI;0CACH,cAAA,8OAAC,+IAAW;oCAAC,WAAU;;sDACrB,8OAAC,oNAAM;4CAAC,WAAU;;;;;;sDAClB,8OAAC;4CAAE,WAAU;sDAAyC;;;;;;sDAGtD,8OAAC,4IAAM;4CAAC,SAAS;4CAAmB,SAAQ;;8DAC1C,8OAAC,0MAAI;oDAAC,WAAU;;;;;;gDAAiB;;;;;;;;;;;;;;;;;qDAMvC,8OAAC;gCAAI,WAAU;0CACZ,UAAU,GAAG,CAAC,CAAC,yBACd,8OAAC,4KAAY;wCAEX,UAAU;wCACV,QAAQ;wCACR,UAAU;wCACV,cAAc;wCACd,YAAY,aAAa,SAAS,EAAE;uCAL/B,SAAS,EAAE;;;;;;;;;;;;;;;;kCAa1B,8OAAC;wBAAI,WAAU;kCACZ,yBACC,8OAAC,4KAAY;4BACX,aAAa,mBAAmB;4BAChC,UAAU,kBAAkB,uBAAuB;4BACnD,UAAU;4BACV,WAAW;;;;;iDAGb,8OAAC,wIAAI;sCACH,cAAA,8OAAC,+IAAW;gCAAC,WAAU;;kDACrB,8OAAC,oNAAM;wCAAC,WAAU;;;;;;kDAClB,8OAAC;wCAAE,WAAU;kDACV,UAAU,MAAM,KAAK,IAClB,yCACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAStB"}}]
}