{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { createAdminClient } from '@/lib/supabase/server-admin';\r\nimport { Booking } from '@/types/booking';\r\nimport { Cleaner } from '@/types/booking';\r\nimport {\r\n  calculateCleanerTenure,\r\n  calculateTotalHours,\r\n  getEarningsPercentage,\r\n  calculateTotalEarningsFromBooking,\r\n  calculateCleanerEarnings,\r\n  calculateTipPerCleaner,\r\n} from '@/lib/utils/cleaner-earnings';\r\n\r\n/**\r\n * Get cleaner by phone number\r\n */\r\nexport async function getCleanerByPhone(phone: string): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    \r\n    // Normalize phone number (remove spaces, dashes, etc.)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    \r\n    const { data, error } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .or(`phone.eq.${normalizedPhone},phone.eq.+${normalizedPhone}`)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaner by phone:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!data) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: data as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerByPhone:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Authenticate cleaner with phone and password\r\n * Uses Supabase Auth - expects email format: {phone}@cleaners.shalean.local\r\n * Admin should create auth accounts with this email format when creating cleaner accounts\r\n */\r\nexport async function authenticateCleaner(\r\n  phone: string,\r\n  password: string\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // First, find the cleaner by phone to verify they exist\r\n    const cleanerResult = await getCleanerByPhone(phone);\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    const cleaner = cleanerResult.cleaner;\r\n\r\n    // Use phone-based email format for login\r\n    // Format: {phone}@cleaners.shalean.local\r\n    // Normalize phone (remove spaces, keep + if present)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    const authEmail = `${normalizedPhone}@cleaners.shalean.local`;\r\n\r\n    // Authenticate with Supabase Auth using client-side (this should be called from client)\r\n    // Note: This function should ideally be called from a client component\r\n    // For server-side, we'll return the cleaner info and let client handle auth\r\n    const supabase = await createClient();\r\n    \r\n    // Try to authenticate\r\n    const { data, error } = await supabase.auth.signInWithPassword({\r\n      email: authEmail,\r\n      password,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Authentication error:', error);\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Authentication failed' };\r\n    }\r\n\r\n    // Update cleaner's auth_user_id if not set\r\n    if (!cleaner.auth_user_id) {\r\n      try {\r\n        const adminSupabase = createAdminClient();\r\n        await adminSupabase\r\n          .from('cleaners')\r\n          .update({ auth_user_id: data.user.id })\r\n          .eq('id', cleaner.id);\r\n      } catch (updateError) {\r\n        // Log but don't fail - auth_user_id update is optional\r\n        console.warn('Could not update auth_user_id:', updateError);\r\n      }\r\n    }\r\n\r\n    return { success: true, cleaner };\r\n  } catch (error) {\r\n    console.error('Error in authenticateCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Authentication failed',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get current authenticated cleaner\r\n */\r\nexport async function getCurrentCleaner(): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    // Try to find cleaner by auth_user_id first\r\n    let cleanerQuery = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('auth_user_id', user.id)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    let { data: cleaner, error: cleanerError } = await cleanerQuery;\r\n\r\n    // If not found by auth_user_id, try to match by phone from email\r\n    if (!cleaner && !cleanerError && user.email) {\r\n      // Extract phone from email format: {phone}@cleaners.shalean.local\r\n      const phoneMatch = user.email.match(/^(.+)@cleaners\\.shalean\\.local$/);\r\n      if (phoneMatch) {\r\n        const phone = phoneMatch[1];\r\n        const phoneResult = await getCleanerByPhone(phone);\r\n        if (phoneResult.success && phoneResult.cleaner) {\r\n          cleaner = phoneResult.cleaner;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner profile not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: cleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCurrentCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get bookings assigned to the authenticated cleaner\r\n */\r\nexport async function getCleanerBookings(\r\n  filter?: 'all' | 'today' | 'upcoming' | 'past' | 'on_my_way' | 'started'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n    \r\n    // Fetch bookings where cleaner is assigned via preferred_cleaner_id (single)\r\n    let singleQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter\r\n    let arrayQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Apply filters to both queries\r\n    if (filter && filter !== 'all') {\r\n      const today = new Date().toISOString().split('T')[0];\r\n      \r\n      switch (filter) {\r\n        case 'today':\r\n          singleQuery = singleQuery.eq('service_date', today);\r\n          arrayQuery = arrayQuery.eq('service_date', today);\r\n          break;\r\n        case 'upcoming':\r\n          singleQuery = singleQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          arrayQuery = arrayQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          break;\r\n        case 'past':\r\n          singleQuery = singleQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          arrayQuery = arrayQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          break;\r\n        case 'on_my_way':\r\n          singleQuery = singleQuery.eq('status', 'on_my_way');\r\n          arrayQuery = arrayQuery.eq('status', 'on_my_way');\r\n          break;\r\n        case 'started':\r\n          singleQuery = singleQuery.eq('status', 'started');\r\n          arrayQuery = arrayQuery.eq('status', 'started');\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Execute both queries\r\n    const [singleResult, arrayResult] = await Promise.all([\r\n      singleQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true }),\r\n      arrayQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true })\r\n    ]);\r\n\r\n    if (singleResult.error) {\r\n      console.error('Error fetching cleaner bookings (single):', singleResult.error);\r\n      return { success: false, error: singleResult.error.message };\r\n    }\r\n\r\n    if (arrayResult.error) {\r\n      console.error('Error fetching cleaner bookings (array):', arrayResult.error);\r\n      return { success: false, error: arrayResult.error.message };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerBookings] Fetched bookings:', {\r\n      cleanerId,\r\n      filter,\r\n      singleBookingsCount: singleResult.data?.length || 0,\r\n      arrayBookingsCount: arrayResult.data?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const filteredArrayBookings = (arrayResult.data || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine results and remove duplicates\r\n    const allBookings = [\r\n      ...(singleResult.data || []),\r\n      ...filteredArrayBookings\r\n    ];\r\n\r\n    // Remove duplicates by booking ID\r\n    const uniqueBookingsMap = new Map<string, Booking>();\r\n    allBookings.forEach((booking: any) => {\r\n      if (booking.id && !uniqueBookingsMap.has(booking.id)) {\r\n        uniqueBookingsMap.set(booking.id, booking as Booking);\r\n      }\r\n    });\r\n\r\n    const bookings = Array.from(uniqueBookingsMap.values());\r\n\r\n    // Sort by service_date and service_time\r\n    bookings.sort((a, b) => {\r\n      const dateCompare = a.service_date.localeCompare(b.service_date);\r\n      if (dateCompare !== 0) return dateCompare;\r\n      return a.service_time.localeCompare(b.service_time);\r\n    });\r\n\r\n    return { success: true, bookings };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate cleaner earnings for a specific booking\r\n * This helper function is used to display earnings on booking details page\r\n */\r\nexport async function calculateBookingEarnings(bookingId: string): Promise<{\r\n  success: boolean;\r\n  earnings?: {\r\n    baseEarnings: number;\r\n    tipAmount: number;\r\n    totalEarnings: number;\r\n    earningsPercentage: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get the booking\r\n    const { data: booking, error: bookingError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (bookingError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Calculate tenure and total hours to determine percentage\r\n    // For single booking display, we need all paid completed bookings to calculate hours\r\n    // Use the same approach as getCleanerStats\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate base earnings\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const baseEarnings = calculateCleanerEarnings(\r\n      {\r\n        service_type: booking.service_type || '',\r\n        total_amount: Number(booking.total_amount) || 0,\r\n        service_fee: Number(booking.service_fee) || 0,\r\n        equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n        additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n        preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n        preferred_cleaner_id: booking.preferred_cleaner_id,\r\n      },\r\n      cleanerId,\r\n      earningsPercentage,\r\n      booking.preferred_cleaner_ids\r\n    );\r\n\r\n    // Calculate tip per cleaner\r\n    const tipAmount = calculateTipPerCleaner(\r\n      Number(booking.tip_amount) || 0,\r\n      booking.preferred_cleaner_ids,\r\n      booking.preferred_cleaner_id\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      earnings: {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n        earningsPercentage,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error calculating booking earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get a specific booking by ID (only if assigned to authenticated cleaner)\r\n */\r\nexport async function getCleanerBookingById(\r\n  bookingId: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Fetch the booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError) {\r\n      console.error('Error fetching booking:', fetchError);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    if (!booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Verify the cleaner is assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    // Check single cleaner assignment\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    // Check multiple cleaner assignment\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    if (!isAssignedSingle && !isAssignedMultiple) {\r\n      return { \r\n        success: false, \r\n        error: 'Unauthorized: You are not assigned to this booking' \r\n      };\r\n    }\r\n\r\n    return { success: true, booking: booking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookingById:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch booking',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update booking status (with authorization check for authenticated cleaner)\r\n */\r\nexport async function updateBookingStatus(\r\n  bookingId: string,\r\n  status: Booking['status']\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // First, verify the cleaner is assigned to this booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Validate status transition\r\n    const validTransitions: Record<string, string[]> = {\r\n      'pending': ['confirmed', 'cancelled'],\r\n      'confirmed': ['on_my_way', 'cancelled'],\r\n      'on_my_way': ['started', 'cancelled'],\r\n      'started': ['completed', 'cancelled'],\r\n      'completed': [],\r\n      'cancelled': [],\r\n    };\r\n\r\n    const currentStatus = booking.status;\r\n    const allowedStatuses = validTransitions[currentStatus] || [];\r\n    \r\n    if (!allowedStatuses.includes(status) && status !== currentStatus) {\r\n      return { \r\n        success: false, \r\n        error: `Invalid status transition: cannot change from ${currentStatus} to ${status}` \r\n      };\r\n    }\r\n\r\n    // Update booking status\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({ \r\n        status,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating booking status:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in updateBookingStatus:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update booking status',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Report lateness for a booking (with authorization check for authenticated cleaner)\r\n */\r\nexport async function reportLateness(\r\n  bookingId: string,\r\n  expectedArrivalTime: string, // ISO timestamp\r\n  reason: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Verify authorization\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Update booking with lateness information\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        expected_arrival_time: expectedArrivalTime,\r\n        lateness_reason: reason,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error reporting lateness:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in reportLateness:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to report lateness',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate earnings for multiple bookings at once\r\n * This is more efficient than calculating earnings one booking at a time\r\n */\r\nexport async function calculateBookingsEarnings(bookingIds: string[]): Promise<{\r\n  success: boolean;\r\n  earnings?: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }>;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    if (bookingIds.length === 0) {\r\n      return { success: true, earnings: {} };\r\n    }\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (bookingsError || !bookings) {\r\n      return { success: false, error: 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Get all cleaner bookings to calculate hours\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    // Calculate tenure and hours\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings for each booking\r\n    const earningsRecord: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }> = {};\r\n\r\n    for (const booking of bookings) {\r\n      const baseEarnings = calculateCleanerEarnings(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage,\r\n        booking.preferred_cleaner_ids\r\n      );\r\n\r\n      const tipAmount = calculateTipPerCleaner(\r\n        Number(booking.tip_amount) || 0,\r\n        booking.preferred_cleaner_ids,\r\n        booking.preferred_cleaner_id\r\n      );\r\n\r\n      earningsRecord[booking.id] = {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n      };\r\n    }\r\n\r\n    return { success: true, earnings: earningsRecord };\r\n  } catch (error) {\r\n    console.error('Error calculating bookings earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get cleaner statistics for the authenticated cleaner\r\n */\r\nexport async function getCleanerStats(): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalBookings: number;\r\n    completedBookings: number;\r\n    upcomingBookings: number;\r\n    todayBookings: number;\r\n    totalEarnings: number;\r\n    monthlyEarnings: number;\r\n    averageRating: number;\r\n    reliabilityScore: number;\r\n    completionRate: number;\r\n    onTimeRate: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info including created_at for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('rating, reliability_score, total_bookings, completed_bookings, on_time_bookings, created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings assigned to this cleaner\r\n    // Fetch bookings with preferred_cleaner_id (single) - include all fields needed for earnings calculation\r\n    const { data: singleBookings, error: singleError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter in JS\r\n    const { data: allMultiBookings, error: multiError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_ids, preferred_cleaner_id')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    if (singleError || multiError) {\r\n      console.error('Error fetching bookings for stats:', singleError || multiError);\r\n      return { success: false, error: (singleError || multiError)?.message || 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerStats] Fetched bookings:', {\r\n      cleanerId,\r\n      singleBookingsCount: singleBookings?.length || 0,\r\n      allMultiBookingsCount: allMultiBookings?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const arrayBookings = (allMultiBookings || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates by ID\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((booking: any) => {\r\n      if (booking.id) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    arrayBookings.forEach((booking: any) => {\r\n      if (booking.id && !allBookingsMap.has(booking.id)) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    \r\n    const allBookings = Array.from(allBookingsMap.values());\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n    const now = new Date();\r\n    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];\r\n    const completedBookings = allBookings.filter(b => b.status === 'completed');\r\n    const upcomingBookings = allBookings.filter(b => \r\n      ['pending', 'confirmed', 'on_my_way', 'started'].includes(b.status) &&\r\n      b.service_date >= today\r\n    );\r\n    const todayBookings = allBookings.filter(b => b.service_date === today);\r\n    const paidBookings = allBookings.filter(b => b.payment_status === 'paid');\r\n    const monthlyPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid' && \r\n      b.service_date >= firstDayOfMonth\r\n    );\r\n    const completedPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid'\r\n    );\r\n\r\n    // Calculate cleaner tenure and total hours for eligibility determination\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(allBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings using the new system\r\n    // Only calculate earnings for paid bookings (earnings are only paid when customer has paid)\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const totalEarnings = completedPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const monthlyEarnings = monthlyPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const completionRate = cleaner.total_bookings \r\n      ? (cleaner.completed_bookings || 0) / cleaner.total_bookings * 100 \r\n      : 0;\r\n    \r\n    const onTimeRate = cleaner.completed_bookings\r\n      ? (cleaner.on_time_bookings || 0) / cleaner.completed_bookings * 100\r\n      : 0;\r\n\r\n    return {\r\n      success: true,\r\n      stats: {\r\n        totalBookings: completedBookings.length,\r\n        completedBookings: completedBookings.length,\r\n        upcomingBookings: upcomingBookings.length,\r\n        todayBookings: todayBookings.length,\r\n        totalEarnings,\r\n        monthlyEarnings,\r\n        averageRating: Number(cleaner.rating) || 0,\r\n        reliabilityScore: Number(cleaner.reliability_score) || 0,\r\n        completionRate,\r\n        onTimeRate,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update cleaner availability\r\n */\r\nexport async function updateCleanerAvailability(\r\n  cleanerId: string,\r\n  updates: {\r\n    isAvailable?: boolean;\r\n    availableMonday?: boolean;\r\n    availableTuesday?: boolean;\r\n    availableWednesday?: boolean;\r\n    availableThursday?: boolean;\r\n    availableFriday?: boolean;\r\n    availableSaturday?: boolean;\r\n    availableSunday?: boolean;\r\n  }\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (updates.isAvailable !== undefined) {\r\n      updateData.is_available = updates.isAvailable;\r\n    }\r\n    if (updates.availableMonday !== undefined) {\r\n      updateData.available_monday = updates.availableMonday;\r\n    }\r\n    if (updates.availableTuesday !== undefined) {\r\n      updateData.available_tuesday = updates.availableTuesday;\r\n    }\r\n    if (updates.availableWednesday !== undefined) {\r\n      updateData.available_wednesday = updates.availableWednesday;\r\n    }\r\n    if (updates.availableThursday !== undefined) {\r\n      updateData.available_thursday = updates.availableThursday;\r\n    }\r\n    if (updates.availableFriday !== undefined) {\r\n      updateData.available_friday = updates.availableFriday;\r\n    }\r\n    if (updates.availableSaturday !== undefined) {\r\n      updateData.available_saturday = updates.availableSaturday;\r\n    }\r\n    if (updates.availableSunday !== undefined) {\r\n      updateData.available_sunday = updates.availableSunday;\r\n    }\r\n\r\n    const { data: updatedCleaner, error } = await supabase\r\n      .from('cleaners')\r\n      .update(updateData)\r\n      .eq('id', cleanerId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error updating cleaner availability:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, cleaner: updatedCleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in updateCleanerAvailability:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update availability',\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAm1BsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,mDAAA"}},
    {"offset": {"line": 18, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (\r\n  <div ref={ref} className={cn(\"rounded-lg border bg-card text-card-foreground shadow-sm\", className)} {...props} />\r\n));\r\nCard.displayName = \"Card\";\r\n\r\nconst CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex flex-col space-y-1.5 p-6\", className)} {...props} />\r\n  ),\r\n);\r\nCardHeader.displayName = \"CardHeader\";\r\n\r\nconst CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <h3 ref={ref} className={cn(\"text-2xl font-semibold leading-none tracking-tight\", className)} {...props} />\r\n  ),\r\n);\r\nCardTitle.displayName = \"CardTitle\";\r\n\r\nconst CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <p ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\r\n  ),\r\n);\r\nCardDescription.displayName = \"CardDescription\";\r\n\r\nconst CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />,\r\n);\r\nCardContent.displayName = \"CardContent\";\r\n\r\nconst CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex items-center p-6 pt-0\", className)} {...props} />\r\n  ),\r\n);\r\nCardFooter.displayName = \"CardFooter\";\r\n\r\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,mNAAgB,CAAuD,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC5G,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,4DAA4D;QAAa,GAAG,KAAK;;;;;;AAEhH,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,mNAAgB,CACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;AAGvF,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,mNAAgB,CAChC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAG,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,sDAAsD;QAAa,GAAG,KAAK;;;;;;AAG3G,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,mNAAgB,CACtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAE,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;AAGrF,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,mNAAgB,CAClC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAAQ,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,YAAY;QAAa,GAAG,KAAK;;;;;;AAElG,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,mNAAgB,CACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,yHAAE,EAAC,8BAA8B;QAAa,GAAG,KAAK;;;;;;AAGpF,WAAW,WAAW,GAAG"}},
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/%28dashboard%29/earnings/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useEffect, useState } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { getCurrentCleaner, getCleanerStats } from '../../actions';\r\nimport { Cleaner } from '@/types/booking';\r\nimport { Loader2, DollarSign, Calendar, CheckCircle2, TrendingUp, Star, Clock } from 'lucide-react';\r\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\r\n\r\nexport default function CleanerEarningsPage() {\r\n  const [cleaner, setCleaner] = useState<Cleaner | null>(null);\r\n  const [stats, setStats] = useState<any>(null);\r\n\r\n  // Get current cleaner\r\n  useQuery({\r\n    queryKey: ['current-cleaner'],\r\n    queryFn: async () => {\r\n      const result = await getCurrentCleaner();\r\n      if (result.success && result.cleaner) {\r\n        setCleaner(result.cleaner);\r\n        return result.cleaner;\r\n      }\r\n      return null;\r\n    },\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Get cleaner stats\r\n  const { data: statsData, isLoading: statsLoading } = useQuery({\r\n    queryKey: ['cleaner-stats', cleaner?.id],\r\n    queryFn: async () => {\r\n      if (!cleaner?.id) return null;\r\n      const result = await getCleanerStats(cleaner.id);\r\n      if (result.success && result.stats) {\r\n        setStats(result.stats);\r\n        return result.stats;\r\n      }\r\n      return null;\r\n    },\r\n    enabled: !!cleaner?.id,\r\n    staleTime: 2 * 60 * 1000,\r\n  });\r\n\r\n  if (!cleaner) {\r\n    return (\r\n      <div className=\"flex items-center justify-center py-12\">\r\n        <Loader2 className=\"w-6 h-6 animate-spin text-primary\" />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-4 sm:space-y-6 w-full max-w-full overflow-x-hidden\">\r\n      <div>\r\n        <h1 className=\"text-2xl sm:text-3xl md:text-4xl font-bold\">Earnings & Stats</h1>\r\n        <p className=\"text-base sm:text-lg text-muted-foreground mt-1\">\r\n          Track your performance and earnings\r\n        </p>\r\n      </div>\r\n\r\n      {statsLoading ? (\r\n        <div className=\"flex items-center justify-center py-12\">\r\n          <Loader2 className=\"w-6 h-6 animate-spin text-primary\" />\r\n        </div>\r\n      ) : stats ? (\r\n        <>\r\n          {/* Earnings Cards */}\r\n          <div className=\"grid gap-4 md:grid-cols-2\">\r\n            <Card>\r\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\r\n                <CardTitle className=\"text-sm font-medium\">Monthly Earnings</CardTitle>\r\n                <DollarSign className=\"h-4 w-4 text-muted-foreground\" />\r\n              </CardHeader>\r\n              <CardContent>\r\n                <div className=\"text-2xl font-bold\">R{stats.monthlyEarnings?.toFixed(2) || '0.00'}</div>\r\n                <p className=\"text-xs text-muted-foreground mt-1\">\r\n                  Current month\r\n                </p>\r\n              </CardContent>\r\n            </Card>\r\n\r\n            <Card>\r\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\r\n                <CardTitle className=\"text-sm font-medium\">Total Earnings</CardTitle>\r\n                <TrendingUp className=\"h-4 w-4 text-muted-foreground\" />\r\n              </CardHeader>\r\n              <CardContent>\r\n                <div className=\"text-2xl font-bold\">R{stats.totalEarnings?.toFixed(2) || '0.00'}</div>\r\n                <p className=\"text-xs text-muted-foreground mt-1\">\r\n                  All time\r\n                </p>\r\n              </CardContent>\r\n            </Card>\r\n          </div>\r\n\r\n          {/* Stats Cards */}\r\n          <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-4\">\r\n            <Card>\r\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\r\n                <CardTitle className=\"text-sm font-medium\">Total Bookings</CardTitle>\r\n                <Calendar className=\"h-4 w-4 text-muted-foreground\" />\r\n              </CardHeader>\r\n              <CardContent>\r\n                <div className=\"text-2xl font-bold\">{stats.totalBookings || 0}</div>\r\n                <p className=\"text-xs text-muted-foreground mt-1\">\r\n                  All bookings\r\n                </p>\r\n              </CardContent>\r\n            </Card>\r\n\r\n            <Card>\r\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\r\n                <CardTitle className=\"text-sm font-medium\">Completed</CardTitle>\r\n                <CheckCircle2 className=\"h-4 w-4 text-muted-foreground\" />\r\n              </CardHeader>\r\n              <CardContent>\r\n                <div className=\"text-2xl font-bold\">{stats.completedBookings || 0}</div>\r\n                <p className=\"text-xs text-muted-foreground mt-1\">\r\n                  {stats.totalBookings ? `${((stats.completedBookings / stats.totalBookings) * 100).toFixed(1)}% completion rate` : 'No bookings yet'}\r\n                </p>\r\n              </CardContent>\r\n            </Card>\r\n\r\n            <Card>\r\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\r\n                <CardTitle className=\"text-sm font-medium\">Average Rating</CardTitle>\r\n                <Star className=\"h-4 w-4 text-muted-foreground fill-yellow-400 text-yellow-400\" />\r\n              </CardHeader>\r\n              <CardContent>\r\n                <div className=\"text-2xl font-bold\">{stats.averageRating?.toFixed(1) || '0.0'}</div>\r\n                <p className=\"text-xs text-muted-foreground mt-1\">\r\n                  Customer ratings\r\n                </p>\r\n              </CardContent>\r\n            </Card>\r\n\r\n            <Card>\r\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\r\n                <CardTitle className=\"text-sm font-medium\">Reliability Score</CardTitle>\r\n                <TrendingUp className=\"h-4 w-4 text-muted-foreground\" />\r\n              </CardHeader>\r\n              <CardContent>\r\n                <div className=\"text-2xl font-bold\">{stats.reliabilityScore?.toFixed(1) || '0.0'}%</div>\r\n                <p className=\"text-xs text-muted-foreground mt-1\">\r\n                  Performance metric\r\n                </p>\r\n              </CardContent>\r\n            </Card>\r\n          </div>\r\n\r\n          {/* Additional Stats */}\r\n          <div className=\"grid gap-4 md:grid-cols-2\">\r\n            <Card>\r\n              <CardHeader>\r\n                <CardTitle>Completion Rate</CardTitle>\r\n                <CardDescription>Percentage of bookings completed</CardDescription>\r\n              </CardHeader>\r\n              <CardContent>\r\n                <div className=\"text-3xl font-bold\">{stats.completionRate?.toFixed(1) || '0.0'}%</div>\r\n                <div className=\"mt-4 w-full bg-muted rounded-full h-2\">\r\n                  <div\r\n                    className=\"bg-primary h-2 rounded-full transition-all\"\r\n                    style={{ width: `${stats.completionRate || 0}%` }}\r\n                  />\r\n                </div>\r\n              </CardContent>\r\n            </Card>\r\n\r\n            <Card>\r\n              <CardHeader>\r\n                <CardTitle>On-Time Rate</CardTitle>\r\n                <CardDescription>Percentage of bookings completed on time</CardDescription>\r\n              </CardHeader>\r\n              <CardContent>\r\n                <div className=\"text-3xl font-bold\">{stats.onTimeRate?.toFixed(1) || '0.0'}%</div>\r\n                <div className=\"mt-4 w-full bg-muted rounded-full h-2\">\r\n                  <div\r\n                    className=\"bg-green-500 h-2 rounded-full transition-all\"\r\n                    style={{ width: `${stats.onTimeRate || 0}%` }}\r\n                  />\r\n                </div>\r\n              </CardContent>\r\n            </Card>\r\n          </div>\r\n\r\n          {/* Upcoming Bookings */}\r\n          <Card>\r\n            <CardHeader>\r\n              <CardTitle>Upcoming Bookings</CardTitle>\r\n              <CardDescription>Bookings scheduled for the future</CardDescription>\r\n            </CardHeader>\r\n            <CardContent>\r\n              <div className=\"text-2xl font-bold\">{stats.upcomingBookings || 0}</div>\r\n              <p className=\"text-sm text-muted-foreground mt-1\">\r\n                Bookings waiting to be completed\r\n              </p>\r\n            </CardContent>\r\n          </Card>\r\n        </>\r\n      ) : (\r\n        <Card>\r\n          <CardContent className=\"flex flex-col items-center justify-center py-12\">\r\n            <p className=\"text-muted-foreground\">No stats available yet</p>\r\n          </CardContent>\r\n        </Card>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n"],"names":[],"mappings":"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"}}]
}