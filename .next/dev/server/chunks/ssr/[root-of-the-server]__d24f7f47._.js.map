{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function createClient() {\r\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\r\n  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\r\n\r\n  if (!supabaseUrl || !supabaseAnonKey) {\r\n    console.error('Missing Supabase environment variables: NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY')\r\n    throw new Error('Supabase configuration is missing. Please check your environment variables.')\r\n  }\r\n\r\n  try {\r\n    const cookieStore = await cookies()\r\n\r\n    return createServerClient(\r\n      supabaseUrl,\r\n      supabaseAnonKey,\r\n      {\r\n        cookies: {\r\n          getAll() {\r\n            return cookieStore.getAll()\r\n          },\r\n          setAll(cookiesToSet) {\r\n            try {\r\n              cookiesToSet.forEach(({ name, value, options }) =>\r\n                cookieStore.set(name, value, options)\r\n              )\r\n            } catch {\r\n              // The `setAll` method was called from a Server Component.\r\n              // This can be ignored if you have middleware refreshing\r\n              // user sessions.\r\n            }\r\n          },\r\n        },\r\n      }\r\n    )\r\n  } catch (error) {\r\n    console.error('Error creating Supabase client:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM;IACN,MAAM;IAEN;;IAKA,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,0IAAO;QAEjC,OAAO,IAAA,+LAAkB,EACvB,aACA,iBACA;YACE,SAAS;gBACP;oBACE,OAAO,YAAY,MAAM;gBAC3B;gBACA,QAAO,YAAY;oBACjB,IAAI;wBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;oBAEjC,EAAE,OAAM;oBACN,0DAA0D;oBAC1D,wDAAwD;oBACxD,iBAAiB;oBACnB;gBACF;YACF;QACF;IAEJ,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,mCAAmC;QACjD,MAAM;IACR;AACF"}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/quote/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { QuoteFormData, QuoteStatus, Quote, Service, AdditionalService, HomeDetailOption, CleaningEquipment } from '@/types/quote';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport interface SaveQuoteResult {\r\n  success: boolean;\r\n  data?: Quote;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Save or update a quote draft\r\n */\r\nexport async function saveQuoteDraft(\r\n  email: string,\r\n  formData: QuoteFormData\r\n): Promise<SaveQuoteResult> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    // Check if a draft already exists for this email\r\n    const { data: existingDraft } = await supabase\r\n      .from('quotes')\r\n      .select('id')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (existingDraft) {\r\n      // Update existing draft\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .update({\r\n          form_data: formData,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('id', existingDraft.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error updating quote draft:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      return { success: true, data: data as Quote };\r\n    } else {\r\n      // Create new draft\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .insert({\r\n          email: email.trim().toLowerCase(),\r\n          status: 'draft',\r\n          form_data: formData,\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error creating quote draft:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      return { success: true, data: data as Quote };\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error saving quote draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get the latest draft quote for an email\r\n */\r\nexport async function getQuoteDraft(email: string): Promise<Quote | null> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return null;\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('quotes')\r\n      .select('*')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (error) {\r\n      // If no draft exists, that's okay - return null\r\n      if (error.code === 'PGRST116') {\r\n        return null;\r\n      }\r\n      console.error('Error fetching quote draft:', error);\r\n      return null;\r\n    }\r\n\r\n    return data as Quote;\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching quote draft:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all quotes (drafts and submitted) for an email\r\n */\r\nexport async function getQuotesByEmail(email: string): Promise<Quote[]> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return [];\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('quotes')\r\n      .select('*')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .order('updated_at', { ascending: false });\r\n\r\n    if (error) {\r\n      console.error('Error fetching quotes:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as Quote[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching quotes:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Submit a quote (change status from draft to submitted)\r\n */\r\nexport async function submitQuote(\r\n  email: string,\r\n  formData: QuoteFormData\r\n): Promise<SaveQuoteResult> {\r\n  try {\r\n    if (!email || !email.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    // Check if a draft exists for this email\r\n    const { data: existingDraft } = await supabase\r\n      .from('quotes')\r\n      .select('id')\r\n      .eq('email', email.trim().toLowerCase())\r\n      .eq('status', 'draft')\r\n      .order('updated_at', { ascending: false })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (existingDraft) {\r\n      // Update existing draft to submitted\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .update({\r\n          status: 'submitted',\r\n          form_data: formData,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('id', existingDraft.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error submitting quote:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      revalidatePath('/booking/quote');\r\n      return { success: true, data: data as Quote };\r\n    } else {\r\n      // Create new submitted quote\r\n      const { data, error } = await supabase\r\n        .from('quotes')\r\n        .insert({\r\n          email: email.trim().toLowerCase(),\r\n          status: 'submitted',\r\n          form_data: formData,\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error creating submitted quote:', error);\r\n        return { success: false, error: error.message };\r\n      }\r\n\r\n      revalidatePath('/booking/quote');\r\n      return { success: true, data: data as Quote };\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error submitting quote:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get all active services ordered by display_order\r\n */\r\nexport async function getServices(): Promise<Service[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('services')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching services:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as Service[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching services:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get additional services, optionally filtered by main service\r\n */\r\nexport async function getAdditionalServices(serviceId?: string): Promise<AdditionalService[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    if (serviceId) {\r\n      // Get additional services filtered by service rules\r\n      const { data, error } = await supabase\r\n        .from('service_additional_service_rules')\r\n        .select(`\r\n          additional_service_id,\r\n          additional_services:additional_service_id(*)\r\n        `)\r\n        .eq('service_id', serviceId);\r\n\r\n      if (error) {\r\n        console.error('Error fetching additional services by service:', error);\r\n        return [];\r\n      }\r\n\r\n      // Extract and format the additional services\r\n      const additionalServices = (data || [])\r\n        .map((rule: any) => rule.additional_services)\r\n        .filter((service: AdditionalService) => service && service.is_active)\r\n        .sort((a: AdditionalService, b: AdditionalService) => a.display_order - b.display_order);\r\n\r\n      return additionalServices as AdditionalService[];\r\n    } else {\r\n      // Get all active additional services\r\n      const { data, error } = await supabase\r\n        .from('additional_services')\r\n        .select('*')\r\n        .eq('is_active', true)\r\n        .order('display_order', { ascending: true });\r\n\r\n      if (error) {\r\n        console.error('Error fetching all additional services:', error);\r\n        return [];\r\n      }\r\n\r\n      return (data || []) as AdditionalService[];\r\n    }\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching additional services:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get home detail options for a specific type (bedrooms, bathrooms, carpet_type, room_status)\r\n */\r\nexport async function getHomeDetailOptions(optionType: string): Promise<HomeDetailOption[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('*')\r\n      .eq('option_type', optionType)\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error(`Error fetching home detail options for ${optionType}:`, error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as HomeDetailOption[];\r\n  } catch (error) {\r\n    console.error(`Unexpected error fetching home detail options for ${optionType}:`, error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get all active cleaning equipment ordered by display_order\r\n */\r\nexport async function getCleaningEquipment(): Promise<CleaningEquipment[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('cleaning_equipment')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaning equipment:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as CleaningEquipment[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaning equipment:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 332, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/pricing/rules.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { PricingRule } from '@/types/booking';\r\n\r\n/**\r\n * Fetch all active pricing rules\r\n */\r\nexport async function getPricingRules(): Promise<PricingRule[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('pricing_rules')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching pricing rules:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as PricingRule[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching pricing rules:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get base price for a service\r\n */\r\nexport async function getBasePrice(serviceId: string): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const basePriceRule = rules.find(\r\n    (rule) => rule.rule_type === 'base_price' && rule.service_id === serviceId\r\n  );\r\n  return basePriceRule?.price || 0;\r\n}\r\n\r\n/**\r\n * Get bedroom pricing\r\n */\r\nexport async function getBedroomPrice(bedroomCount: string): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const bedroomRule = rules.find(\r\n    (rule) => rule.rule_type === 'bedroom' && rule.rule_value === bedroomCount\r\n  );\r\n  return bedroomRule?.price || 0;\r\n}\r\n\r\n/**\r\n * Get bathroom pricing\r\n */\r\nexport async function getBathroomPrice(bathroomCount: string): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const bathroomRule = rules.find(\r\n    (rule) => rule.rule_type === 'bathroom' && rule.rule_value === bathroomCount\r\n  );\r\n  return bathroomRule?.price || 0;\r\n}\r\n\r\n/**\r\n * Get additional service pricing\r\n */\r\nexport async function getAdditionalServicePrice(serviceId: string): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const serviceRule = rules.find(\r\n    (rule) => rule.rule_type === 'additional_service' && rule.additional_service_id === serviceId\r\n  );\r\n  return serviceRule?.price || 0;\r\n}\r\n\r\n/**\r\n * Get service fee percentage\r\n */\r\nexport async function getServiceFeePercentage(): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const feeRule = rules.find(\r\n    (rule) => rule.rule_type === 'service_fee'\r\n  );\r\n  return feeRule?.percentage || 0;\r\n}\r\n\r\n/**\r\n * Get frequency discount percentage\r\n */\r\nexport async function getFrequencyDiscount(frequency: 'weekly' | 'bi-weekly' | 'monthly'): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const discountRule = rules.find(\r\n    (rule) => rule.rule_type === 'frequency_discount' && rule.rule_value === frequency\r\n  );\r\n  return discountRule?.percentage || 0;\r\n}\r\n\r\n/**\r\n * Get fitted room price (per room)\r\n */\r\nexport async function getFittedRoomPrice(): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const fittedRoomRule = rules.find(\r\n    (rule) => rule.rule_type === 'fitted_room' && rule.rule_key === 'per_room'\r\n  );\r\n  return fittedRoomRule?.price || 0;\r\n}\r\n\r\n/**\r\n * Get loose carpet/rug price (per carpet/rug)\r\n */\r\nexport async function getLooseCarpetPrice(): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const looseCarpetRule = rules.find(\r\n    (rule) => rule.rule_type === 'loose_carpet' && rule.rule_key === 'per_carpet'\r\n  );\r\n  return looseCarpetRule?.price || 0;\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAEA;;;;AAMO,eAAe;IACpB,IAAI;QACF,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAC3B,IAAI,CAAC,iBACL,MAAM,CAAC,KACP,EAAE,CAAC,aAAa,MAChB,KAAK,CAAC,iBAAiB;YAAE,WAAW;QAAK;QAE5C,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,OAAO,EAAE;QACX;QAEA,OAAQ,QAAQ,EAAE;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4CAA4C;QAC1D,OAAO,EAAE;IACX;AACF;AAKO,eAAe,aAAa,SAAiB;IAClD,MAAM,QAAQ,MAAM;IACpB,MAAM,gBAAgB,MAAM,IAAI,CAC9B,CAAC,OAAS,KAAK,SAAS,KAAK,gBAAgB,KAAK,UAAU,KAAK;IAEnE,OAAO,eAAe,SAAS;AACjC;AAKO,eAAe,gBAAgB,YAAoB;IACxD,MAAM,QAAQ,MAAM;IACpB,MAAM,cAAc,MAAM,IAAI,CAC5B,CAAC,OAAS,KAAK,SAAS,KAAK,aAAa,KAAK,UAAU,KAAK;IAEhE,OAAO,aAAa,SAAS;AAC/B;AAKO,eAAe,iBAAiB,aAAqB;IAC1D,MAAM,QAAQ,MAAM;IACpB,MAAM,eAAe,MAAM,IAAI,CAC7B,CAAC,OAAS,KAAK,SAAS,KAAK,cAAc,KAAK,UAAU,KAAK;IAEjE,OAAO,cAAc,SAAS;AAChC;AAKO,eAAe,0BAA0B,SAAiB;IAC/D,MAAM,QAAQ,MAAM;IACpB,MAAM,cAAc,MAAM,IAAI,CAC5B,CAAC,OAAS,KAAK,SAAS,KAAK,wBAAwB,KAAK,qBAAqB,KAAK;IAEtF,OAAO,aAAa,SAAS;AAC/B;AAKO,eAAe;IACpB,MAAM,QAAQ,MAAM;IACpB,MAAM,UAAU,MAAM,IAAI,CACxB,CAAC,OAAS,KAAK,SAAS,KAAK;IAE/B,OAAO,SAAS,cAAc;AAChC;AAKO,eAAe,qBAAqB,SAA6C;IACtF,MAAM,QAAQ,MAAM;IACpB,MAAM,eAAe,MAAM,IAAI,CAC7B,CAAC,OAAS,KAAK,SAAS,KAAK,wBAAwB,KAAK,UAAU,KAAK;IAE3E,OAAO,cAAc,cAAc;AACrC;AAKO,eAAe;IACpB,MAAM,QAAQ,MAAM;IACpB,MAAM,iBAAiB,MAAM,IAAI,CAC/B,CAAC,OAAS,KAAK,SAAS,KAAK,iBAAiB,KAAK,QAAQ,KAAK;IAElE,OAAO,gBAAgB,SAAS;AAClC;AAKO,eAAe;IACpB,MAAM,QAAQ,MAAM;IACpB,MAAM,kBAAkB,MAAM,IAAI,CAChC,CAAC,OAAS,KAAK,SAAS,KAAK,kBAAkB,KAAK,QAAQ,KAAK;IAEnE,OAAO,iBAAiB,SAAS;AACnC;;;IA5GsB;IAyBA;IAWA;IAWA;IAWA;IAWA;IAWA;IAWA;IAWA;;AAtGA,+OAAA;AAyBA,+OAAA;AAWA,+OAAA;AAWA,+OAAA;AAWA,+OAAA;AAWA,+OAAA;AAWA,+OAAA;AAWA,+OAAA;AAWA,+OAAA"}},
    {"offset": {"line": 438, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/utils/service-validation.ts"],"sourcesContent":["/**\r\n * Service validation utilities for recurring bookings\r\n * \r\n * Only Standard Cleaning and Airbnb Cleaning support recurring bookings.\r\n * All other services (Deep Cleaning, Move In/Out, Carpet Cleaning) are One-Time only.\r\n */\r\n\r\n/**\r\n * Check if a service supports recurring bookings\r\n * @param serviceName - The name of the service (case-insensitive)\r\n * @returns true if the service supports recurring bookings, false otherwise\r\n */\r\nexport function supportsRecurringBookings(serviceName: string): boolean {\r\n  if (!serviceName) return false;\r\n  \r\n  const normalizedName = serviceName.toLowerCase().trim();\r\n  \r\n  // Standard Cleaning supports recurring\r\n  if (normalizedName.includes('standard')) {\r\n    return true;\r\n  }\r\n  \r\n  // Airbnb Cleaning supports recurring\r\n  if (normalizedName.includes('airbnb')) {\r\n    return true;\r\n  }\r\n  \r\n  // All other services are One-Time only\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get available frequencies for a service\r\n * @param serviceName - The name of the service (case-insensitive)\r\n * @returns Array of available frequency options\r\n */\r\nexport function getAvailableFrequencies(\r\n  serviceName: string\r\n): ('one-time' | 'weekly' | 'bi-weekly' | 'monthly')[] {\r\n  if (supportsRecurringBookings(serviceName)) {\r\n    return ['one-time', 'weekly', 'bi-weekly', 'monthly'];\r\n  }\r\n  \r\n  // Non-supported services only allow One-Time\r\n  return ['one-time'];\r\n}\r\n\r\n/**\r\n * Check if a frequency is valid for a service\r\n * @param serviceName - The name of the service\r\n * @param frequency - The frequency to check\r\n * @returns true if the frequency is valid for the service\r\n */\r\nexport function isValidFrequencyForService(\r\n  serviceName: string,\r\n  frequency: 'one-time' | 'weekly' | 'bi-weekly' | 'monthly'\r\n): boolean {\r\n  const availableFrequencies = getAvailableFrequencies(serviceName);\r\n  return availableFrequencies.includes(frequency);\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED;;;;CAIC;;;;;;;;AACM,SAAS,0BAA0B,WAAmB;IAC3D,IAAI,CAAC,aAAa,OAAO;IAEzB,MAAM,iBAAiB,YAAY,WAAW,GAAG,IAAI;IAErD,uCAAuC;IACvC,IAAI,eAAe,QAAQ,CAAC,aAAa;QACvC,OAAO;IACT;IAEA,qCAAqC;IACrC,IAAI,eAAe,QAAQ,CAAC,WAAW;QACrC,OAAO;IACT;IAEA,uCAAuC;IACvC,OAAO;AACT;AAOO,SAAS,wBACd,WAAmB;IAEnB,IAAI,0BAA0B,cAAc;QAC1C,OAAO;YAAC;YAAY;YAAU;YAAa;SAAU;IACvD;IAEA,6CAA6C;IAC7C,OAAO;QAAC;KAAW;AACrB;AAQO,SAAS,2BACd,WAAmB,EACnB,SAA0D;IAE1D,MAAM,uBAAuB,wBAAwB;IACrD,OAAO,qBAAqB,QAAQ,CAAC;AACvC"}},
    {"offset": {"line": 491, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/pricing/calculator.ts"],"sourcesContent":["'use server';\r\n\r\nimport { \r\n  getBasePrice, \r\n  getBedroomPrice, \r\n  getBathroomPrice, \r\n  getAdditionalServicePrice,\r\n  getServiceFeePercentage,\r\n  getFrequencyDiscount,\r\n  getFittedRoomPrice,\r\n  getLooseCarpetPrice\r\n} from './rules';\r\nimport { PriceBreakdown } from '@/types/booking';\r\nimport { AdditionalService } from '@/types/quote';\r\nimport { supportsRecurringBookings } from '@/lib/utils/service-validation';\r\n\r\ninterface CalculatePriceParams {\r\n  serviceId: string;\r\n  serviceName?: string; // Service name to check if recurring bookings are supported\r\n  bedrooms: string;\r\n  bathrooms: string;\r\n  additionalServiceIds: string[];\r\n  additionalServices?: AdditionalService[]; // For quantity-based pricing\r\n  cleaningFrequency: 'one-time' | 'weekly' | 'bi-weekly' | 'monthly';\r\n  discountAmount?: number;\r\n  numberOfFittedRooms?: string;\r\n  numberOfLooseCarpets?: string;\r\n  isCarpetCleaning?: boolean;\r\n  cleaningEquipment?: 'yes' | 'no' | '';\r\n  numberOfCleaners?: number; // Number of cleaners (1-5, only for Standard and Airbnb)\r\n}\r\n\r\n/**\r\n * Calculate complete price breakdown for a booking\r\n */\r\nexport async function calculatePrice(params: CalculatePriceParams): Promise<PriceBreakdown> {\r\n  const {\r\n    serviceId,\r\n    serviceName,\r\n    bedrooms,\r\n    bathrooms,\r\n    additionalServiceIds,\r\n    additionalServices = [],\r\n    cleaningFrequency,\r\n    discountAmount = 0,\r\n    numberOfFittedRooms = '',\r\n    numberOfLooseCarpets = '',\r\n    isCarpetCleaning = false,\r\n    cleaningEquipment = '',\r\n    numberOfCleaners = 1\r\n  } = params;\r\n\r\n  // Equipment supply charge constant\r\n  const EQUIPMENT_SUPPLY_CHARGE = 500;\r\n  \r\n  // Additional cleaner charge constant (R250 per additional cleaner)\r\n  const ADDITIONAL_CLEANER_CHARGE = 250;\r\n\r\n  // Base price\r\n  const basePrice = await getBasePrice(serviceId);\r\n\r\n  // Bedroom price (only for non-carpet services)\r\n  const bedroomsPrice = isCarpetCleaning ? 0 : await getBedroomPrice(bedrooms);\r\n\r\n  // Bathroom price (only for non-carpet services)\r\n  const bathroomsPrice = isCarpetCleaning ? 0 : await getBathroomPrice(bathrooms);\r\n\r\n  // Carpet pricing (for carpet cleaning service)\r\n  const fittedRoomPricePerUnit = await getFittedRoomPrice();\r\n  const fittedRoomsPrice = fittedRoomPricePerUnit * (parseFloat(numberOfFittedRooms) || 0);\r\n\r\n  const looseCarpetPricePerUnit = await getLooseCarpetPrice();\r\n  const looseCarpetsPrice = looseCarpetPricePerUnit * (parseFloat(numberOfLooseCarpets) || 0);\r\n\r\n  // Additional services price\r\n  let additionalServicesPrice = 0;\r\n  for (const serviceId of additionalServiceIds) {\r\n    const price = await getAdditionalServicePrice(serviceId);\r\n    \r\n    // Check if service requires quantity and has quantity specified\r\n    const service = additionalServices.find(s => s.id === serviceId);\r\n    if (service?.requires_quantity) {\r\n      // For quantity-based services, multiply by quantity if available\r\n      // This would need to be passed in the params if we track quantities\r\n      additionalServicesPrice += price; // For now, single unit price\r\n    } else {\r\n      additionalServicesPrice += price;\r\n    }\r\n  }\r\n\r\n  // Equipment supply charge - only for Standard and Airbnb services when user selects 'yes'\r\n  let equipmentSupplyPrice = 0;\r\n  if (cleaningEquipment === 'yes' && serviceName && supportsRecurringBookings(serviceName)) {\r\n    equipmentSupplyPrice = EQUIPMENT_SUPPLY_CHARGE;\r\n  }\r\n\r\n  // Additional cleaners charge - only for Standard and Airbnb services\r\n  // First cleaner is included in base price, charge for each additional cleaner\r\n  let additionalCleanersPrice = 0;\r\n  if (serviceName && supportsRecurringBookings(serviceName) && numberOfCleaners > 1) {\r\n    const additionalCleanersCount = Math.max(0, Math.min(numberOfCleaners - 1, 4)); // Max 4 additional (total 5 cleaners)\r\n    additionalCleanersPrice = additionalCleanersCount * ADDITIONAL_CLEANER_CHARGE;\r\n  }\r\n\r\n  // Subtotal before discounts\r\n  const subtotal = basePrice + bedroomsPrice + bathroomsPrice + fittedRoomsPrice + looseCarpetsPrice + additionalServicesPrice + equipmentSupplyPrice + additionalCleanersPrice;\r\n\r\n  // Frequency discount - only apply to Standard and Airbnb cleaning services\r\n  let frequencyDiscountPercent = 0;\r\n  let frequencyDiscountAmount = 0;\r\n  \r\n  // Only apply frequency discount if ALL conditions are met:\r\n  // 1. Frequency is not one-time\r\n  // 2. Service name is provided (not undefined, not empty)\r\n  // 3. Service supports recurring bookings (Standard or Airbnb only)\r\n  if (cleaningFrequency !== 'one-time' && serviceName && serviceName.trim() !== '') {\r\n    if (supportsRecurringBookings(serviceName)) {\r\n      frequencyDiscountPercent = await getFrequencyDiscount(cleaningFrequency);\r\n      frequencyDiscountAmount = (subtotal * frequencyDiscountPercent) / 100;\r\n    }\r\n    // Explicitly: If service doesn't support recurring, discount remains 0\r\n    // This ensures Deep Cleaning, Move In/Out, and Carpet Cleaning NEVER get discounts\r\n  }\r\n\r\n  // Subtotal after frequency discount\r\n  const subtotalAfterFrequencyDiscount = subtotal - frequencyDiscountAmount;\r\n\r\n  // Apply discount code (passed in as discountAmount)\r\n  const finalSubtotal = Math.max(0, subtotalAfterFrequencyDiscount - discountAmount);\r\n\r\n  // Service fee (calculated on subtotal after frequency discount, before discount code)\r\n  const serviceFeePercentage = await getServiceFeePercentage();\r\n  const serviceFee = (subtotalAfterFrequencyDiscount * serviceFeePercentage) / 100;\r\n\r\n  // Total amount (subtotal after all discounts + service fee)\r\n  const totalAmount = finalSubtotal + serviceFee;\r\n\r\n  return {\r\n    basePrice,\r\n    bedroomsPrice,\r\n    bathroomsPrice,\r\n    fittedRoomsPrice,\r\n    looseCarpetsPrice,\r\n    additionalServicesPrice,\r\n    equipmentSupplyPrice,\r\n    additionalCleanersPrice,\r\n    subtotal,\r\n    frequencyDiscountPercent,\r\n    frequencyDiscountAmount,\r\n    discountAmount,\r\n    serviceFee,\r\n    totalAmount\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate price breakdown for display (used in real-time updates)\r\n * This is a lighter version that can be called frequently\r\n */\r\nexport async function calculatePriceBreakdown(\r\n  serviceId: string,\r\n  bedrooms: string,\r\n  bathrooms: string,\r\n  additionalServiceIds: string[],\r\n  cleaningFrequency: 'one-time' | 'weekly' | 'bi-weekly' | 'monthly',\r\n  discountAmount: number = 0,\r\n  numberOfFittedRooms: string = '',\r\n  numberOfLooseCarpets: string = '',\r\n  isCarpetCleaning: boolean = false,\r\n  serviceName?: string,\r\n  cleaningEquipment?: 'yes' | 'no' | '',\r\n  numberOfCleaners: number = 1\r\n): Promise<PriceBreakdown> {\r\n  return calculatePrice({\r\n    serviceId,\r\n    serviceName,\r\n    bedrooms,\r\n    bathrooms,\r\n    additionalServiceIds,\r\n    cleaningFrequency,\r\n    discountAmount,\r\n    numberOfFittedRooms,\r\n    numberOfLooseCarpets,\r\n    isCarpetCleaning,\r\n    cleaningEquipment,\r\n    numberOfCleaners\r\n  });\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;AAEA;AAYA;;;;;AAqBO,eAAe,eAAe,MAA4B;IAC/D,MAAM,EACJ,SAAS,EACT,WAAW,EACX,QAAQ,EACR,SAAS,EACT,oBAAoB,EACpB,qBAAqB,EAAE,EACvB,iBAAiB,EACjB,iBAAiB,CAAC,EAClB,sBAAsB,EAAE,EACxB,uBAAuB,EAAE,EACzB,mBAAmB,KAAK,EACxB,oBAAoB,EAAE,EACtB,mBAAmB,CAAC,EACrB,GAAG;IAEJ,mCAAmC;IACnC,MAAM,0BAA0B;IAEhC,mEAAmE;IACnE,MAAM,4BAA4B;IAElC,aAAa;IACb,MAAM,YAAY,MAAM,IAAA,8IAAY,EAAC;IAErC,+CAA+C;IAC/C,MAAM,gBAAgB,mBAAmB,IAAI,MAAM,IAAA,iJAAe,EAAC;IAEnE,gDAAgD;IAChD,MAAM,iBAAiB,mBAAmB,IAAI,MAAM,IAAA,kJAAgB,EAAC;IAErE,+CAA+C;IAC/C,MAAM,yBAAyB,MAAM,IAAA,oJAAkB;IACvD,MAAM,mBAAmB,yBAAyB,CAAC,WAAW,wBAAwB,CAAC;IAEvF,MAAM,0BAA0B,MAAM,IAAA,qJAAmB;IACzD,MAAM,oBAAoB,0BAA0B,CAAC,WAAW,yBAAyB,CAAC;IAE1F,4BAA4B;IAC5B,IAAI,0BAA0B;IAC9B,KAAK,MAAM,aAAa,qBAAsB;QAC5C,MAAM,QAAQ,MAAM,IAAA,2JAAyB,EAAC;QAE9C,gEAAgE;QAChE,MAAM,UAAU,mBAAmB,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QACtD,IAAI,SAAS,mBAAmB;YAC9B,iEAAiE;YACjE,oEAAoE;YACpE,2BAA2B,OAAO,6BAA6B;QACjE,OAAO;YACL,2BAA2B;QAC7B;IACF;IAEA,0FAA0F;IAC1F,IAAI,uBAAuB;IAC3B,IAAI,sBAAsB,SAAS,eAAe,IAAA,yKAAyB,EAAC,cAAc;QACxF,uBAAuB;IACzB;IAEA,qEAAqE;IACrE,8EAA8E;IAC9E,IAAI,0BAA0B;IAC9B,IAAI,eAAe,IAAA,yKAAyB,EAAC,gBAAgB,mBAAmB,GAAG;QACjF,MAAM,0BAA0B,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,mBAAmB,GAAG,KAAK,sCAAsC;QACtH,0BAA0B,0BAA0B;IACtD;IAEA,4BAA4B;IAC5B,MAAM,WAAW,YAAY,gBAAgB,iBAAiB,mBAAmB,oBAAoB,0BAA0B,uBAAuB;IAEtJ,2EAA2E;IAC3E,IAAI,2BAA2B;IAC/B,IAAI,0BAA0B;IAE9B,2DAA2D;IAC3D,+BAA+B;IAC/B,yDAAyD;IACzD,mEAAmE;IACnE,IAAI,sBAAsB,cAAc,eAAe,YAAY,IAAI,OAAO,IAAI;QAChF,IAAI,IAAA,yKAAyB,EAAC,cAAc;YAC1C,2BAA2B,MAAM,IAAA,sJAAoB,EAAC;YACtD,0BAA0B,AAAC,WAAW,2BAA4B;QACpE;IACA,uEAAuE;IACvE,mFAAmF;IACrF;IAEA,oCAAoC;IACpC,MAAM,iCAAiC,WAAW;IAElD,oDAAoD;IACpD,MAAM,gBAAgB,KAAK,GAAG,CAAC,GAAG,iCAAiC;IAEnE,sFAAsF;IACtF,MAAM,uBAAuB,MAAM,IAAA,yJAAuB;IAC1D,MAAM,aAAa,AAAC,iCAAiC,uBAAwB;IAE7E,4DAA4D;IAC5D,MAAM,cAAc,gBAAgB;IAEpC,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF;AAMO,eAAe,wBACpB,SAAiB,EACjB,QAAgB,EAChB,SAAiB,EACjB,oBAA8B,EAC9B,iBAAkE,EAClE,iBAAyB,CAAC,EAC1B,sBAA8B,EAAE,EAChC,uBAA+B,EAAE,EACjC,mBAA4B,KAAK,EACjC,WAAoB,EACpB,iBAAqC,EACrC,mBAA2B,CAAC;IAE5B,OAAO,eAAe;QACpB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF;;;IAxJsB;IA4HA;;AA5HA,+OAAA;AA4HA,+OAAA"}},
    {"offset": {"line": 617, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/utils/booking-number.ts"],"sourcesContent":["/**\r\n * Generate a unique booking number\r\n * Format: SHL followed by numbers only (e.g., SHL20250115123456)\r\n */\r\nexport function generateBookingNumber(): string {\r\n  const date = new Date();\r\n  const year = date.getFullYear();\r\n  const month = String(date.getMonth() + 1).padStart(2, '0');\r\n  const day = String(date.getDate()).padStart(2, '0');\r\n  \r\n  // Generate random 6-digit number (000000-999999)\r\n  const randomNumber = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');\r\n  \r\n  return `SHL${year}${month}${day}${randomNumber}`;\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AACM,SAAS;IACd,MAAM,OAAO,IAAI;IACjB,MAAM,OAAO,KAAK,WAAW;IAC7B,MAAM,QAAQ,OAAO,KAAK,QAAQ,KAAK,GAAG,QAAQ,CAAC,GAAG;IACtD,MAAM,MAAM,OAAO,KAAK,OAAO,IAAI,QAAQ,CAAC,GAAG;IAE/C,iDAAiD;IACjD,MAAM,eAAe,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,SAAS,QAAQ,GAAG,QAAQ,CAAC,GAAG;IAEhF,OAAO,CAAC,GAAG,EAAE,OAAO,QAAQ,MAAM,cAAc;AAClD"}},
    {"offset": {"line": 643, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/paystack/client.ts"],"sourcesContent":["/**\r\n * Paystack API client\r\n */\r\n\r\nconst PAYSTACK_SECRET_KEY = process.env.PAYSTACK_SECRET_KEY;\r\nconst PAYSTACK_PUBLIC_KEY = process.env.NEXT_PUBLIC_PAYSTACK_PUBLIC_KEY;\r\nconst PAYSTACK_API_URL = 'https://api.paystack.co';\r\n\r\nexport interface PaystackInitializeResponse {\r\n  status: boolean;\r\n  message: string;\r\n  data: {\r\n    authorization_url: string;\r\n    access_code: string;\r\n    reference: string;\r\n  };\r\n}\r\n\r\nexport interface PaystackVerifyResponse {\r\n  status: boolean;\r\n  message: string;\r\n  data: {\r\n    id: number;\r\n    domain: string;\r\n    status: string;\r\n    reference: string;\r\n    amount: number;\r\n    message: string | null;\r\n    gateway_response: string;\r\n    paid_at: string | null;\r\n    created_at: string;\r\n    channel: string;\r\n    currency: string;\r\n    ip_address: string;\r\n    metadata: {\r\n      booking_id?: string;\r\n      customer_email?: string;\r\n      custom_fields?: Array<{ display_name: string; variable_name: string; value: string }>;\r\n    };\r\n    log: any;\r\n    fees: number;\r\n    fees_split: any;\r\n    authorization: any;\r\n    customer: any;\r\n    plan: any;\r\n    split: any;\r\n    order_id: any;\r\n    paidAt: string | null;\r\n    createdAt: string;\r\n    requested_amount: number;\r\n    pos_transaction_data: any;\r\n    source: any;\r\n    fees_breakdown: any;\r\n  };\r\n}\r\n\r\n/**\r\n * Initialize a Paystack transaction\r\n */\r\nexport async function initializePayment(\r\n  email: string,\r\n  amount: number, // Amount in kobo (Nigerian Naira) or cents. For ZAR, convert to cents (amount * 100)\r\n  reference: string,\r\n  metadata?: {\r\n    booking_id?: string;\r\n    [key: string]: any;\r\n  }\r\n): Promise<PaystackInitializeResponse> {\r\n  if (!PAYSTACK_SECRET_KEY) {\r\n    throw new Error('Paystack secret key is not configured');\r\n  }\r\n\r\n  // Convert ZAR amount to kobo/cents (multiply by 100)\r\n  const amountInKobo = Math.round(amount * 100);\r\n\r\n  // Build callback URL for payment success page\r\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';\r\n  const callbackUrl = `${appUrl}/payment/success?reference=${reference}`;\r\n\r\n  const response = await fetch(`${PAYSTACK_API_URL}/transaction/initialize`, {\r\n    method: 'POST',\r\n    headers: {\r\n      'Authorization': `Bearer ${PAYSTACK_SECRET_KEY}`,\r\n      'Content-Type': 'application/json',\r\n    },\r\n    body: JSON.stringify({\r\n      email,\r\n      amount: amountInKobo,\r\n      reference,\r\n      metadata,\r\n      currency: 'ZAR', // South African Rand\r\n      callback_url: callbackUrl,\r\n    }),\r\n  });\r\n\r\n  if (!response.ok) {\r\n    const error = await response.json();\r\n    throw new Error(error.message || 'Failed to initialize payment');\r\n  }\r\n\r\n  return response.json();\r\n}\r\n\r\n/**\r\n * Verify a Paystack transaction\r\n */\r\nexport async function verifyPayment(reference: string): Promise<PaystackVerifyResponse> {\r\n  if (!PAYSTACK_SECRET_KEY) {\r\n    throw new Error('Paystack secret key is not configured');\r\n  }\r\n\r\n  const response = await fetch(`${PAYSTACK_API_URL}/transaction/verify/${reference}`, {\r\n    method: 'GET',\r\n    headers: {\r\n      'Authorization': `Bearer ${PAYSTACK_SECRET_KEY}`,\r\n      'Content-Type': 'application/json',\r\n    },\r\n  });\r\n\r\n  if (!response.ok) {\r\n    const error = await response.json();\r\n    throw new Error(error.message || 'Failed to verify payment');\r\n  }\r\n\r\n  return response.json();\r\n}\r\n\r\n/**\r\n * Verify Paystack webhook signature\r\n */\r\nexport function verifyWebhookSignature(\r\n  payload: string,\r\n  signature: string\r\n): boolean {\r\n  const crypto = require('crypto');\r\n  const secret = process.env.PAYSTACK_WEBHOOK_SECRET || PAYSTACK_SECRET_KEY || '';\r\n  \r\n  if (!secret) {\r\n    return false;\r\n  }\r\n\r\n  const hash = crypto\r\n    .createHmac('sha512', secret)\r\n    .update(payload)\r\n    .digest('hex');\r\n\r\n  return hash === signature;\r\n}\r\n\r\n/**\r\n * Get Paystack public key for client-side use\r\n */\r\nexport function getPaystackPublicKey(): string {\r\n  if (!PAYSTACK_PUBLIC_KEY) {\r\n    throw new Error('Paystack public key is not configured');\r\n  }\r\n  return PAYSTACK_PUBLIC_KEY;\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;CAEC,GAED,MAAM,sBAAsB,QAAQ,GAAG,CAAC,mBAAmB;AAC3D,MAAM;AACN,MAAM,mBAAmB;AAqDlB,eAAe,kBACpB,KAAa,EACb,MAAc,EACd,SAAiB,EACjB,QAGC;IAED,IAAI,CAAC,qBAAqB;QACxB,MAAM,IAAI,MAAM;IAClB;IAEA,qDAAqD;IACrD,MAAM,eAAe,KAAK,KAAK,CAAC,SAAS;IAEzC,8CAA8C;IAC9C,MAAM,SAAS,6DAAmC;IAClD,MAAM,cAAc,GAAG,OAAO,2BAA2B,EAAE,WAAW;IAEtE,MAAM,WAAW,MAAM,MAAM,GAAG,iBAAiB,uBAAuB,CAAC,EAAE;QACzE,QAAQ;QACR,SAAS;YACP,iBAAiB,CAAC,OAAO,EAAE,qBAAqB;YAChD,gBAAgB;QAClB;QACA,MAAM,KAAK,SAAS,CAAC;YACnB;YACA,QAAQ;YACR;YACA;YACA,UAAU;YACV,cAAc;QAChB;IACF;IAEA,IAAI,CAAC,SAAS,EAAE,EAAE;QAChB,MAAM,QAAQ,MAAM,SAAS,IAAI;QACjC,MAAM,IAAI,MAAM,MAAM,OAAO,IAAI;IACnC;IAEA,OAAO,SAAS,IAAI;AACtB;AAKO,eAAe,cAAc,SAAiB;IACnD,IAAI,CAAC,qBAAqB;QACxB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,WAAW,MAAM,MAAM,GAAG,iBAAiB,oBAAoB,EAAE,WAAW,EAAE;QAClF,QAAQ;QACR,SAAS;YACP,iBAAiB,CAAC,OAAO,EAAE,qBAAqB;YAChD,gBAAgB;QAClB;IACF;IAEA,IAAI,CAAC,SAAS,EAAE,EAAE;QAChB,MAAM,QAAQ,MAAM,SAAS,IAAI;QACjC,MAAM,IAAI,MAAM,MAAM,OAAO,IAAI;IACnC;IAEA,OAAO,SAAS,IAAI;AACtB;AAKO,SAAS,uBACd,OAAe,EACf,SAAiB;IAEjB,MAAM;IACN,MAAM,SAAS,QAAQ,GAAG,CAAC,uBAAuB,IAAI,uBAAuB;IAE7E,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IAEA,MAAM,OAAO,OACV,UAAU,CAAC,UAAU,QACrB,MAAM,CAAC,SACP,MAAM,CAAC;IAEV,OAAO,SAAS;AAClB;AAKO,SAAS;IACd;;IAGA,OAAO;AACT"}},
    {"offset": {"line": 723, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/utils/cleaner-utils.ts"],"sourcesContent":["import { Cleaner, CleanerWithAvailability } from '@/types/booking';\r\n\r\nexport type SortCriteria = 'best-match' | 'highest-rated' | 'most-reliable' | 'most-experienced';\r\n\r\n/**\r\n * Calculate reliability score from booking metrics\r\n * Formula:\r\n * - Completion Rate (40%): (completed_bookings / total_bookings) * 40\r\n * - On-Time Rate (30%): (on_time_bookings / total_bookings) * 30\r\n * - Rating Factor (20%): (rating / 5.0) * 20\r\n * - Booking Volume (10%): min(total_bookings / 50, 1) * 10\r\n */\r\nexport function calculateReliabilityScore(cleaner: Cleaner): number {\r\n  const totalBookings = cleaner.total_bookings || 0;\r\n  const completedBookings = cleaner.completed_bookings || 0;\r\n  const onTimeBookings = cleaner.on_time_bookings || 0;\r\n  const rating = cleaner.rating || 0;\r\n\r\n  // If no bookings, return default score of 50\r\n  if (totalBookings === 0) {\r\n    return 50.0;\r\n  }\r\n\r\n  // Calculate completion rate score (40% weight)\r\n  const completionRateScore = (completedBookings / totalBookings) * 40.0;\r\n\r\n  // Calculate on-time rate score (30% weight)\r\n  const onTimeRateScore = (onTimeBookings / totalBookings) * 30.0;\r\n\r\n  // Calculate rating score (20% weight)\r\n  const ratingScore = (rating / 5.0) * 20.0;\r\n\r\n  // Calculate volume score (10% weight) - normalized to max 50 bookings\r\n  const volumeScore = Math.min(totalBookings / 50.0, 1.0) * 10.0;\r\n\r\n  // Calculate final score\r\n  let finalScore = completionRateScore + onTimeRateScore + ratingScore + volumeScore;\r\n\r\n  // Ensure score is between 0 and 100\r\n  finalScore = Math.max(0.0, Math.min(100.0, finalScore));\r\n\r\n  return Math.round(finalScore * 100) / 100; // Round to 2 decimal places\r\n}\r\n\r\n/**\r\n * Format reliability score for display\r\n */\r\nexport function formatReliabilityScore(score: number | null | undefined): string {\r\n  if (score === null || score === undefined) {\r\n    return 'N/A';\r\n  }\r\n  return `${score.toFixed(0)}%`;\r\n}\r\n\r\n/**\r\n * Sort cleaners by selected criteria\r\n */\r\nexport function sortCleanersByCriteria(\r\n  cleaners: CleanerWithAvailability[],\r\n  criteria: SortCriteria\r\n): CleanerWithAvailability[] {\r\n  const sorted = [...cleaners];\r\n\r\n  switch (criteria) {\r\n    case 'best-match':\r\n      // Sort by: reliability_score (60%) + rating (40%)\r\n      sorted.sort((a, b) => {\r\n        const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n        const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n        return scoreB - scoreA;\r\n      });\r\n      break;\r\n\r\n    case 'highest-rated':\r\n      sorted.sort((a, b) => (b.rating || 0) - (a.rating || 0));\r\n      break;\r\n\r\n    case 'most-reliable':\r\n      sorted.sort((a, b) => (b.reliability_score || 0) - (a.reliability_score || 0));\r\n      break;\r\n\r\n    case 'most-experienced':\r\n      sorted.sort((a, b) => (b.years_experience || 0) - (a.years_experience || 0));\r\n      break;\r\n\r\n    default:\r\n      // Default to best-match\r\n      sorted.sort((a, b) => {\r\n        const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n        const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n        return scoreB - scoreA;\r\n      });\r\n  }\r\n\r\n  return sorted;\r\n}\r\n\r\n/**\r\n * Calculate completion rate for a cleaner\r\n */\r\nexport function calculateCompletionRate(cleaner: Cleaner): number {\r\n  const total = cleaner.total_bookings || 0;\r\n  const completed = cleaner.completed_bookings || 0;\r\n  if (total === 0) return 0;\r\n  return Math.round((completed / total) * 100);\r\n}\r\n\r\n/**\r\n * Calculate on-time rate for a cleaner\r\n */\r\nexport function calculateOnTimeRate(cleaner: Cleaner): number {\r\n  const total = cleaner.total_bookings || 0;\r\n  const onTime = cleaner.on_time_bookings || 0;\r\n  if (total === 0) return 0;\r\n  return Math.round((onTime / total) * 100);\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAYO,SAAS,0BAA0B,OAAgB;IACxD,MAAM,gBAAgB,QAAQ,cAAc,IAAI;IAChD,MAAM,oBAAoB,QAAQ,kBAAkB,IAAI;IACxD,MAAM,iBAAiB,QAAQ,gBAAgB,IAAI;IACnD,MAAM,SAAS,QAAQ,MAAM,IAAI;IAEjC,6CAA6C;IAC7C,IAAI,kBAAkB,GAAG;QACvB,OAAO;IACT;IAEA,+CAA+C;IAC/C,MAAM,sBAAsB,AAAC,oBAAoB,gBAAiB;IAElE,4CAA4C;IAC5C,MAAM,kBAAkB,AAAC,iBAAiB,gBAAiB;IAE3D,sCAAsC;IACtC,MAAM,cAAc,AAAC,SAAS,MAAO;IAErC,sEAAsE;IACtE,MAAM,cAAc,KAAK,GAAG,CAAC,gBAAgB,MAAM,OAAO;IAE1D,wBAAwB;IACxB,IAAI,aAAa,sBAAsB,kBAAkB,cAAc;IAEvE,oCAAoC;IACpC,aAAa,KAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,OAAO;IAE3C,OAAO,KAAK,KAAK,CAAC,aAAa,OAAO,KAAK,4BAA4B;AACzE;AAKO,SAAS,uBAAuB,KAAgC;IACrE,IAAI,UAAU,QAAQ,UAAU,WAAW;QACzC,OAAO;IACT;IACA,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC;AAC/B;AAKO,SAAS,uBACd,QAAmC,EACnC,QAAsB;IAEtB,MAAM,SAAS;WAAI;KAAS;IAE5B,OAAQ;QACN,KAAK;YACH,kDAAkD;YAClD,OAAO,IAAI,CAAC,CAAC,GAAG;gBACd,MAAM,SAAS,CAAC,EAAE,iBAAiB,IAAI,CAAC,IAAI,MAAM,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI;gBACpE,MAAM,SAAS,CAAC,EAAE,iBAAiB,IAAI,CAAC,IAAI,MAAM,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI;gBACpE,OAAO,SAAS;YAClB;YACA;QAEF,KAAK;YACH,OAAO,IAAI,CAAC,CAAC,GAAG,IAAM,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI,CAAC,EAAE,MAAM,IAAI,CAAC;YACtD;QAEF,KAAK;YACH,OAAO,IAAI,CAAC,CAAC,GAAG,IAAM,CAAC,EAAE,iBAAiB,IAAI,CAAC,IAAI,CAAC,EAAE,iBAAiB,IAAI,CAAC;YAC5E;QAEF,KAAK;YACH,OAAO,IAAI,CAAC,CAAC,GAAG,IAAM,CAAC,EAAE,gBAAgB,IAAI,CAAC,IAAI,CAAC,EAAE,gBAAgB,IAAI,CAAC;YAC1E;QAEF;YACE,wBAAwB;YACxB,OAAO,IAAI,CAAC,CAAC,GAAG;gBACd,MAAM,SAAS,CAAC,EAAE,iBAAiB,IAAI,CAAC,IAAI,MAAM,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI;gBACpE,MAAM,SAAS,CAAC,EAAE,iBAAiB,IAAI,CAAC,IAAI,MAAM,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI;gBACpE,OAAO,SAAS;YAClB;IACJ;IAEA,OAAO;AACT;AAKO,SAAS,wBAAwB,OAAgB;IACtD,MAAM,QAAQ,QAAQ,cAAc,IAAI;IACxC,MAAM,YAAY,QAAQ,kBAAkB,IAAI;IAChD,IAAI,UAAU,GAAG,OAAO;IACxB,OAAO,KAAK,KAAK,CAAC,AAAC,YAAY,QAAS;AAC1C;AAKO,SAAS,oBAAoB,OAAgB;IAClD,MAAM,QAAQ,QAAQ,cAAc,IAAI;IACxC,MAAM,SAAS,QAAQ,gBAAgB,IAAI;IAC3C,IAAI,UAAU,GAAG,OAAO;IACxB,OAAO,KAAK,KAAK,CAAC,AAAC,SAAS,QAAS;AACvC"}},
    {"offset": {"line": 812, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/utils/recurring-dates.ts"],"sourcesContent":["/**\r\n * Calculate all booking dates for the current month based on frequency\r\n * @param startDate - The initial booking date selected by the user\r\n * @param frequency - 'one-time' | 'weekly' | 'bi-weekly' | 'monthly'\r\n * @returns Array of dates for bookings in the current month\r\n */\r\nexport function calculateBookingDatesForMonth(\r\n  startDate: Date,\r\n  frequency: 'one-time' | 'weekly' | 'bi-weekly' | 'monthly'\r\n): Date[] {\r\n  const dates: Date[] = [];\r\n  const currentDate = new Date(startDate);\r\n  \r\n  // Get the month and year of the start date\r\n  const month = currentDate.getMonth();\r\n  const year = currentDate.getFullYear();\r\n  \r\n  // Get the last day of the month\r\n  const lastDayOfMonth = new Date(year, month + 1, 0).getDate();\r\n  \r\n  switch (frequency) {\r\n    case 'one-time':\r\n      // Return only the start date\r\n      dates.push(new Date(startDate));\r\n      break;\r\n      \r\n    case 'weekly':\r\n      // Find all occurrences of the same day of week in the month\r\n      const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      const startDay = currentDate.getDate();\r\n      \r\n      // Start from the selected date\r\n      let weeklyDate = new Date(year, month, startDay);\r\n      \r\n      // Add all remaining occurrences in the month\r\n      while (weeklyDate.getMonth() === month && weeklyDate.getDate() <= lastDayOfMonth) {\r\n        dates.push(new Date(weeklyDate));\r\n        weeklyDate.setDate(weeklyDate.getDate() + 7); // Add 7 days\r\n      }\r\n      break;\r\n      \r\n    case 'bi-weekly':\r\n      // Find occurrences every 2 weeks in the month\r\n      const biWeeklyStartDay = currentDate.getDate();\r\n      let biWeeklyDate = new Date(year, month, biWeeklyStartDay);\r\n      \r\n      // Add all occurrences in the month (every 2 weeks)\r\n      while (biWeeklyDate.getMonth() === month && biWeeklyDate.getDate() <= lastDayOfMonth) {\r\n        dates.push(new Date(biWeeklyDate));\r\n        biWeeklyDate.setDate(biWeeklyDate.getDate() + 14); // Add 14 days\r\n      }\r\n      break;\r\n      \r\n    case 'monthly':\r\n      // Return only the start date (one booking per month)\r\n      dates.push(new Date(startDate));\r\n      break;\r\n      \r\n    default:\r\n      dates.push(new Date(startDate));\r\n  }\r\n  \r\n  return dates;\r\n}\r\n\r\n/**\r\n * Calculate the next booking date for auto-creation\r\n * @param lastDate - The last booking date in the current series\r\n * @param frequency - 'one-time' | 'weekly' | 'bi-weekly' | 'monthly'\r\n * @returns The next booking date\r\n */\r\nexport function calculateNextBookingDate(\r\n  lastDate: Date,\r\n  frequency: 'one-time' | 'weekly' | 'bi-weekly' | 'monthly'\r\n): Date {\r\n  const nextDate = new Date(lastDate);\r\n  \r\n  switch (frequency) {\r\n    case 'one-time':\r\n      // Should not be called for one-time, but return next month just in case\r\n      nextDate.setMonth(nextDate.getMonth() + 1);\r\n      break;\r\n      \r\n    case 'weekly':\r\n      // Next booking is 1 week from last date, but we want first of next month\r\n      // So calculate first occurrence of next month\r\n      nextDate.setMonth(nextDate.getMonth() + 1);\r\n      // Keep the same day of week - find first occurrence in next month\r\n      const dayOfWeek = lastDate.getDay();\r\n      const dayOfMonth = lastDate.getDate();\r\n      \r\n      // Start from the 1st of next month\r\n      nextDate.setDate(1);\r\n      \r\n      // Find the first occurrence of the same day of week\r\n      while (nextDate.getDay() !== dayOfWeek) {\r\n        nextDate.setDate(nextDate.getDate() + 1);\r\n      }\r\n      break;\r\n      \r\n    case 'bi-weekly':\r\n      // Next booking is 2 weeks from last date, but we want first of next month\r\n      // Calculate first occurrence in next month (same day of week)\r\n      nextDate.setMonth(nextDate.getMonth() + 1);\r\n      const biWeeklyDayOfWeek = lastDate.getDay();\r\n      nextDate.setDate(1);\r\n      \r\n      // Find the first occurrence of the same day of week\r\n      while (nextDate.getDay() !== biWeeklyDayOfWeek) {\r\n        nextDate.setDate(nextDate.getDate() + 1);\r\n      }\r\n      break;\r\n      \r\n    case 'monthly':\r\n      // Next booking is same day next month\r\n      nextDate.setMonth(nextDate.getMonth() + 1);\r\n      // Handle edge case where day doesn't exist in next month (e.g., Jan 31 -> Feb 28/29)\r\n      const originalDay = lastDate.getDate();\r\n      const daysInNextMonth = new Date(nextDate.getFullYear(), nextDate.getMonth() + 1, 0).getDate();\r\n      nextDate.setDate(Math.min(originalDay, daysInNextMonth));\r\n      break;\r\n      \r\n    default:\r\n      nextDate.setMonth(nextDate.getMonth() + 1);\r\n  }\r\n  \r\n  return nextDate;\r\n}\r\n\r\n/**\r\n * Format date to YYYY-MM-DD string for database storage\r\n */\r\nexport function formatDateForDB(date: Date): string {\r\n  const year = date.getFullYear();\r\n  const month = String(date.getMonth() + 1).padStart(2, '0');\r\n  const day = String(date.getDate()).padStart(2, '0');\r\n  return `${year}-${month}-${day}`;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 924, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/book/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { BookingFormData, BookingCreateInput, WorkingHour, TimeSlotAvailability, Cleaner, CleanerWithAvailability } from '@/types/booking';\r\nimport { calculatePrice } from '@/lib/pricing/calculator';\r\nimport { generateBookingNumber } from '@/lib/utils/booking-number';\r\nimport { initializePayment } from '@/lib/paystack/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { calculateReliabilityScore, calculateCompletionRate, calculateOnTimeRate } from '@/lib/utils/cleaner-utils';\r\nimport { calculateBookingDatesForMonth, calculateNextBookingDate, formatDateForDB } from '@/lib/utils/recurring-dates';\r\nimport { isValidFrequencyForService } from '@/lib/utils/service-validation';\r\n\r\n/**\r\n * Get available working hours (30-minute interval start times)\r\n */\r\nexport async function getWorkingHours(): Promise<WorkingHour[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('working_hours')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as WorkingHour[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get working hours from home_detail_options (backward compatibility)\r\n */\r\nexport async function getWorkingHoursFromOptions(): Promise<Array<{ value: string; label: string }>> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('value, label')\r\n      .eq('option_type', 'working_hours')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours from options:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []).map((item) => ({\r\n      value: item.value,\r\n      label: item.label,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours from options:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check cleaner availability for a specific date and time slot\r\n * Returns availability status and count of available cleaners\r\n */\r\nexport async function checkCleanerAvailabilityForSlot(\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<TimeSlotAvailability> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, check if any active cleaners exist in the system\r\n    const { data: activeCleaners, error: cleanersError } = await supabase\r\n      .from('cleaners')\r\n      .select('id')\r\n      .eq('is_active', true);\r\n\r\n    if (cleanersError) {\r\n      console.error('Error checking active cleaners:', cleanersError);\r\n      // If we can't check cleaners, assume unavailable for safety\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    // If no active cleaners exist, no slots are available\r\n    if (!activeCleaners || activeCleaners.length === 0) {\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    const totalCleaners = activeCleaners.length;\r\n\r\n    // Query bookings for the specified date that might overlap\r\n    // We need to check for bookings where:\r\n    // (booking_start_time < new_end_time) AND (booking_end_time > new_start_time)\r\n    // Only consider pending or confirmed bookings (exclude cancelled/completed)\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration, preferred_cleaner_id, preferred_cleaner_ids, number_of_cleaners')\r\n      .eq('service_date', serviceDate)\r\n      .in('status', ['pending', 'confirmed']);\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking bookings:', bookingsError);\r\n      // If we can't check bookings, assume available (optimistic approach)\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      // No bookings for this date, all cleaners are available\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Track which cleaners are booked (by ID)\r\n    const bookedCleanerIds = new Set<string>();\r\n    \r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n      \r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number' \r\n          ? booking.service_duration \r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        // There's an overlap\r\n        // Check preferred_cleaner_ids first (new multi-cleaner support)\r\n        if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n          // Multiple cleaners are assigned\r\n          booking.preferred_cleaner_ids.forEach((cleanerId: string) => {\r\n            if (cleanerId) bookedCleanerIds.add(cleanerId);\r\n          });\r\n        } else if (booking.preferred_cleaner_id) {\r\n          // Single cleaner assigned (backward compatibility)\r\n          bookedCleanerIds.add(booking.preferred_cleaner_id);\r\n        } else {\r\n          // If no preferred cleaner, use number_of_cleaners to count generic cleaner slots\r\n          // This handles bookings without specific cleaner assignments\r\n          const numCleaners = booking.number_of_cleaners || 1;\r\n          // We don't add specific IDs here, but count them in bookingsWithoutPreferredCleaner\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate available cleaners\r\n    // Count bookings without preferred cleaners (generic assignments)\r\n    // These use number_of_cleaners to determine how many cleaner slots are taken\r\n    const bookingsWithoutPreferredCleaner = bookings.filter(\r\n      (b) => {\r\n        const hasPreferredCleaners = (b.preferred_cleaner_ids && Array.isArray(b.preferred_cleaner_ids) && b.preferred_cleaner_ids.length > 0) || b.preferred_cleaner_id;\r\n        if (hasPreferredCleaners) return false;\r\n        \r\n        // Check for time overlap\r\n        const [hours, mins] = b.service_time.split(':').slice(0, 2).map(Number);\r\n        const start = hours * 60 + mins;\r\n        const duration = Math.round((typeof b.service_duration === 'number' ? b.service_duration : parseFloat(b.service_duration || '0')) * 60);\r\n        const end = start + duration;\r\n        return newStartTimeMinutes < end && newEndTimeMinutes > start;\r\n      }\r\n    ).reduce((sum, b) => {\r\n      // Sum up the number_of_cleaners for bookings without preferred cleaners\r\n      return sum + (b.number_of_cleaners || 1);\r\n    }, 0);\r\n\r\n    const unavailableCleaners = bookedCleanerIds.size + bookingsWithoutPreferredCleaner;\r\n    const availableCleanersCount = Math.max(0, totalCleaners - unavailableCleaners);\r\n\r\n    return {\r\n      available: availableCleanersCount > 0,\r\n      availableCleanersCount,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking cleaner availability:', error);\r\n    // On error, assume unavailable for safety\r\n    return { available: false, availableCleanersCount: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Check availability for all time slots for a given date\r\n */\r\nexport async function checkAvailabilityForAllSlots(\r\n  serviceDate: string,\r\n  workingHours: WorkingHour[],\r\n  serviceDuration: number\r\n): Promise<Record<string, TimeSlotAvailability>> {\r\n  const availability: Record<string, TimeSlotAvailability> = {};\r\n\r\n  // Check availability for each time slot in parallel\r\n  // Use the service duration provided (either from form data or calculated)\r\n  const promises = workingHours.map(async (hour) => {\r\n    // Use the provided service duration, not the working hour's duration\r\n    // The working hour duration is just the slot length, but the actual booking\r\n    // will use the service duration from the form\r\n    const slotAvailability = await checkCleanerAvailabilityForSlot(\r\n      serviceDate,\r\n      hour.start_time,\r\n      serviceDuration\r\n    );\r\n    return { time: hour.start_time, availability: slotAvailability };\r\n  });\r\n\r\n  const results = await Promise.all(promises);\r\n  \r\n  results.forEach(({ time, availability: avail }) => {\r\n    availability[time] = avail;\r\n  });\r\n\r\n  return availability;\r\n}\r\n\r\n/**\r\n * Validate discount code\r\n */\r\nexport async function validateDiscountCode(code: string, subtotal: number): Promise<{\r\n  valid: boolean;\r\n  discountAmount: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (!code || !code.trim()) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('discount_codes')\r\n      .select('*')\r\n      .eq('code', code.trim().toUpperCase())\r\n      .eq('is_active', true)\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      return { valid: false, discountAmount: 0, error: 'Invalid discount code' };\r\n    }\r\n\r\n    // Check validity dates\r\n    const now = new Date();\r\n    const validFrom = new Date(data.valid_from);\r\n    const validUntil = new Date(data.valid_until);\r\n\r\n    if (now < validFrom || now > validUntil) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has expired' };\r\n    }\r\n\r\n    // Check max uses\r\n    if (data.max_uses && data.used_count >= data.max_uses) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has reached maximum uses' };\r\n    }\r\n\r\n    // Check min purchase amount\r\n    if (data.min_purchase_amount && subtotal < data.min_purchase_amount) {\r\n      return { \r\n        valid: false, \r\n        discountAmount: 0, \r\n        error: `Minimum purchase amount of R${data.min_purchase_amount} required` \r\n      };\r\n    }\r\n\r\n    // Calculate discount amount\r\n    let discountAmount = 0;\r\n    if (data.discount_type === 'percentage') {\r\n      discountAmount = (subtotal * data.discount_value) / 100;\r\n      if (data.max_discount_amount && discountAmount > data.max_discount_amount) {\r\n        discountAmount = data.max_discount_amount;\r\n      }\r\n    } else {\r\n      discountAmount = data.discount_value;\r\n    }\r\n\r\n    // Ensure discount doesn't exceed subtotal\r\n    discountAmount = Math.min(discountAmount, subtotal);\r\n\r\n    return { valid: true, discountAmount };\r\n  } catch (error) {\r\n    console.error('Error validating discount code:', error);\r\n    return { valid: false, discountAmount: 0, error: 'Error validating discount code' };\r\n  }\r\n}\r\n\r\n/**\r\n * Create booking draft (before payment)\r\n */\r\nexport async function createBookingDraft(formData: BookingFormData): Promise<{\r\n  success: boolean;\r\n  bookingId?: string;\r\n  bookingIds?: string[];\r\n  totalAmount?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current user if logged in\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n    const userId = user?.id || null;\r\n\r\n    // Get service name\r\n    const { data: service } = await supabase\r\n      .from('services')\r\n      .select('name')\r\n      .eq('id', formData.serviceId)\r\n      .single();\r\n\r\n    if (!service) {\r\n      return { success: false, error: 'Service not found' };\r\n    }\r\n\r\n    // Validate that the selected frequency is valid for this service\r\n    if (!isValidFrequencyForService(service.name, formData.cleaningFrequency)) {\r\n      return { \r\n        success: false, \r\n        error: `Recurring bookings are only available for Standard Cleaning and Airbnb Cleaning services. Selected service: ${service.name}` \r\n      };\r\n    }\r\n\r\n    // Calculate pricing\r\n    const priceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount: 0, // Will calculate discount in next step\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Apply discount code if provided\r\n    let discountAmount = 0;\r\n    if (formData.discountCode) {\r\n      const discountValidation = await validateDiscountCode(\r\n        formData.discountCode,\r\n        priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount\r\n      );\r\n      if (discountValidation.valid) {\r\n        discountAmount = discountValidation.discountAmount;\r\n      }\r\n    }\r\n\r\n    // Recalculate with discount\r\n    const finalPriceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount,\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Determine if this is a recurring booking\r\n    const isRecurring = formData.cleaningFrequency !== 'one-time';\r\n\r\n    // Calculate booking dates based on frequency\r\n    const startDate = new Date(formData.serviceDate);\r\n    const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n\r\n    // Calculate next booking date for recurring bookings\r\n    let nextBookingDate: Date | null = null;\r\n    if (isRecurring && bookingDates.length > 0) {\r\n      const lastDate = bookingDates[bookingDates.length - 1];\r\n      nextBookingDate = calculateNextBookingDate(lastDate, formData.cleaningFrequency);\r\n    }\r\n\r\n    // Create bookings for all dates\r\n    const bookingsToCreate: BookingCreateInput[] = [];\r\n\r\n    for (let i = 0; i < bookingDates.length; i++) {\r\n      const bookingDate = bookingDates[i];\r\n      const bookingNumber = generateBookingNumber();\r\n\r\n      // Tip is only applied to the first booking in a recurring series (one-time payment)\r\n      const tipAmount = (i === 0) ? (formData.tipAmount || 0) : 0;\r\n      \r\n      const bookingInput: BookingCreateInput = {\r\n        booking_number: bookingNumber,\r\n        customer_first_name: formData.customerFirstName,\r\n        customer_last_name: formData.customerLastName,\r\n        customer_email: formData.customerEmail,\r\n        customer_phone: formData.customerPhone,\r\n        service_id: formData.serviceId,\r\n        service_type: service.name,\r\n        bedrooms: formData.bedrooms,\r\n        bathrooms: formData.bathrooms,\r\n        additional_services: formData.additionalServices,\r\n        cleaning_equipment: formData.cleaningEquipment,\r\n        preferred_cleaner_ids: formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n          ? formData.preferredCleanerIds \r\n          : null,\r\n        preferred_cleaner_id: formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n          ? formData.preferredCleanerIds[0] \r\n          : null, // Backward compatibility: set to first cleaner\r\n        cleaning_frequency: formData.cleaningFrequency,\r\n        service_date: formatDateForDB(bookingDate),\r\n        service_time: formData.serviceTime,\r\n        service_duration: formData.serviceDuration,\r\n        service_address: formData.serviceAddress,\r\n        service_apt_unit: formData.serviceAptUnit || null,\r\n        service_suburb: formData.serviceSuburb,\r\n        service_city: formData.serviceCity,\r\n        special_instructions: formData.specialInstructions || null,\r\n        tip_amount: tipAmount,\r\n        base_price: finalPriceBreakdown.basePrice,\r\n        additional_services_price: finalPriceBreakdown.additionalServicesPrice,\r\n        equipment_supply_price: finalPriceBreakdown.equipmentSupplyPrice,\r\n        number_of_cleaners: formData.numberOfCleaners || 1,\r\n        additional_cleaners_price: finalPriceBreakdown.additionalCleanersPrice,\r\n        frequency_discount_percent: finalPriceBreakdown.frequencyDiscountPercent,\r\n        frequency_discount_amount: finalPriceBreakdown.frequencyDiscountAmount,\r\n        subtotal: finalPriceBreakdown.subtotal,\r\n        service_fee: finalPriceBreakdown.serviceFee,\r\n        total_amount: finalPriceBreakdown.totalAmount + tipAmount,\r\n        discount_code: formData.discountCode || null,\r\n        discount_amount: discountAmount,\r\n        referral_code: formData.referralCode || null,\r\n        amount_paid: 0,\r\n        payment_status: 'pending',\r\n        status: 'pending',\r\n        user_id: userId,\r\n        parent_booking_id: null, // Will be updated after first booking is created\r\n        is_recurring: isRecurring,\r\n        recurrence_status: isRecurring ? 'active' : undefined,\r\n        next_booking_date: i === 0 && isRecurring && nextBookingDate ? formatDateForDB(nextBookingDate) : null,\r\n        credits_used: 0, // Will be updated when credits are used during payment\r\n      };\r\n\r\n      bookingsToCreate.push(bookingInput);\r\n    }\r\n\r\n    // Insert all bookings\r\n    const { data: insertedBookings, error } = await supabase\r\n      .from('bookings')\r\n      .insert(bookingsToCreate)\r\n      .select('id, total_amount');\r\n\r\n    if (error) {\r\n      console.error('Error creating booking drafts:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!insertedBookings || insertedBookings.length === 0) {\r\n      return { success: false, error: 'Failed to create bookings' };\r\n    }\r\n\r\n    // Update parent_booking_id for subsequent bookings if there are multiple\r\n    if (insertedBookings.length > 1 && isRecurring) {\r\n      const firstBookingId = insertedBookings[0].id;\r\n      const subsequentBookingIds = insertedBookings.slice(1).map(b => b.id);\r\n      \r\n      // Update all subsequent bookings to reference the first one\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({ parent_booking_id: firstBookingId })\r\n        .in('id', subsequentBookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating parent_booking_id:', updateError);\r\n        // Don't fail, but log the error\r\n      }\r\n    }\r\n\r\n    // Calculate total amount\r\n    const totalAmount = insertedBookings.reduce((sum, booking) => sum + Number(booking.total_amount), 0);\r\n    const bookingIds = insertedBookings.map(booking => booking.id);\r\n\r\n    // For backward compatibility, also return single bookingId\r\n    const bookingId = bookingIds[0];\r\n\r\n    // If multiple bookings, return array; otherwise return single ID for backward compatibility\r\n    if (bookingIds.length > 1) {\r\n      return { \r\n        success: true, \r\n        bookingIds,\r\n        totalAmount,\r\n        bookingId // Keep for backward compatibility\r\n      };\r\n    }\r\n\r\n    return { \r\n      success: true, \r\n      bookingId,\r\n      bookingIds,\r\n      totalAmount\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error creating booking draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize payment for booking(s)\r\n * Accepts either a single bookingId or an array of bookingIds\r\n */\r\nexport async function initializePaymentForBooking(\r\n  bookingIdOrIds: string | string[]\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const bookingIds = Array.isArray(bookingIdOrIds) ? bookingIdOrIds : [bookingIdOrIds];\r\n\r\n    // Get all booking details\r\n    const { data: bookings, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (fetchError || !bookings || bookings.length === 0) {\r\n      return { success: false, error: 'Booking(s) not found' };\r\n    }\r\n\r\n    // Check if all bookings are in pending status\r\n    const nonPendingBookings = bookings.filter(b => b.payment_status !== 'pending');\r\n    if (nonPendingBookings.length > 0) {\r\n      return { success: false, error: 'Some bookings are not in pending payment status' };\r\n    }\r\n\r\n    // Calculate total amount from all bookings (including tip)\r\n    // Note: total_amount in database now includes tip for new bookings\r\n    // For backward compatibility with existing bookings that might not have tip in total_amount, \r\n    // we check and add tip_amount if it's missing\r\n    const totalAmount = bookings.reduce((sum, booking) => {\r\n      const bookingTotal = Number(booking.total_amount) || 0;\r\n      const tipAmount = Number(booking.tip_amount) || 0;\r\n      const baseTotal = Number(booking.subtotal || 0) + Number(booking.service_fee || 0);\r\n      \r\n      // Check if tip is already included in total_amount\r\n      // If total_amount equals baseTotal exactly, then tip is not included, so add it\r\n      // Otherwise, total_amount already includes tip\r\n      if (tipAmount > 0 && Math.abs(bookingTotal - baseTotal) < 0.01) {\r\n        // Tip is not included in total_amount (backward compatibility case)\r\n        return sum + bookingTotal + tipAmount;\r\n      }\r\n      // Tip is already included in total_amount (new bookings)\r\n      return sum + bookingTotal;\r\n    }, 0);\r\n\r\n    // Calculate total credits used across all bookings\r\n    const totalCreditsUsed = bookings.reduce((sum, booking) => {\r\n      return sum + (Number(booking.credits_used) || 0);\r\n    }, 0);\r\n\r\n    // Calculate remaining amount after credits\r\n    const remainingAmount = totalAmount - totalCreditsUsed;\r\n\r\n    // Use the first booking's email and details for payment\r\n    const firstBooking = bookings[0];\r\n\r\n    // If credits fully cover the booking, mark as paid and skip Paystack\r\n    if (remainingAmount <= 0) {\r\n      // Update all bookings to mark as paid\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({\r\n          payment_status: 'paid',\r\n          amount_paid: totalAmount, // Fully paid with credits\r\n          status: 'confirmed', // Auto-confirm when fully paid\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .in('id', bookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating bookings payment status:', updateError);\r\n        return { success: false, error: 'Failed to update booking payment status' };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        // No authorizationUrl - payment fully covered by credits\r\n      };\r\n    }\r\n\r\n    // Partial credit coverage or no credits - proceed with Paystack for remaining amount\r\n    const reference = firstBooking.paystack_reference || `${firstBooking.booking_number}${Date.now()}`;\r\n    \r\n    // Initialize Paystack payment with remaining amount (after credits)\r\n    const paymentResponse = await initializePayment(\r\n      firstBooking.customer_email,\r\n      remainingAmount, // Only charge the remaining amount\r\n      reference,\r\n      {\r\n        booking_ids: bookingIds,\r\n        booking_id: firstBooking.id, // Keep for backward compatibility\r\n        booking_number: firstBooking.booking_number,\r\n        customer_email: firstBooking.customer_email,\r\n        credits_used: totalCreditsUsed, // Include in metadata for tracking\r\n      }\r\n    );\r\n\r\n    if (!paymentResponse.status) {\r\n      return { success: false, error: paymentResponse.message || 'Failed to initialize payment' };\r\n    }\r\n\r\n    // Use the reference that Paystack actually returned (may differ from what we sent)\r\n    const paystackReference = paymentResponse.data.reference;\r\n\r\n    // Update all bookings with the Paystack reference and partial payment from credits\r\n    const { error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        paystack_reference: paystackReference,\r\n        amount_paid: totalCreditsUsed, // Partial payment from credits, Paystack will complete it\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .in('id', bookingIds);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating bookings with Paystack reference:', updateError);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentResponse.data.authorization_url,\r\n      reference: paystackReference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing payment:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get booking by ID\r\n */\r\nexport async function getBooking(bookingId: string): Promise<{\r\n  success: boolean;\r\n  booking?: any;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners for selection\r\n * Optionally filter by service area/suburb\r\n */\r\nexport async function getAvailableCleaners(serviceSuburb?: string): Promise<{\r\n  success: boolean;\r\n  cleaners?: any[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Build query - only filter by is_available if the column exists\r\n    // First, try to get all active cleaners\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = data || [];\r\n\r\n    // Filter by is_available if the column exists (client-side filter as fallback)\r\n    cleaners = cleaners.filter((cleaner) => {\r\n      // If is_available column doesn't exist or is null/undefined, include the cleaner\r\n      // Otherwise, only include if is_available is true\r\n      return cleaner.is_available !== false;\r\n    });\r\n\r\n    // Filter by area if suburb is provided\r\n    // Since PostgreSQL array contains is complex in Supabase, we filter client-side\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        // If cleaner has no areas specified, include them (they serve all areas)\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true;\r\n        }\r\n        // Check if any area matches the suburb (case-insensitive partial match)\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    return { success: true, cleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a cleaner is available for a specific day of the week\r\n * dayOfWeek: 0 = Sunday, 1 = Monday, ..., 6 = Saturday\r\n */\r\nexport async function isCleanerAvailableForDay(cleaner: any, dayOfWeek: number): Promise<boolean> {\r\n  const dayMap: Record<number, keyof typeof cleaner> = {\r\n    0: 'available_sunday',\r\n    1: 'available_monday',\r\n    2: 'available_tuesday',\r\n    3: 'available_wednesday',\r\n    4: 'available_thursday',\r\n    5: 'available_friday',\r\n    6: 'available_saturday',\r\n  };\r\n\r\n  const dayField = dayMap[dayOfWeek];\r\n  return cleaner[dayField] !== false && cleaner.is_available !== false;\r\n}\r\n\r\n/**\r\n * Check if a cleaner has a booking conflict for a specific date and time slot\r\n */\r\nexport async function checkCleanerBookingConflict(\r\n  cleanerId: string,\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Query bookings for this cleaner on the specified date\r\n    const { data: bookings, error } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration')\r\n      .eq('preferred_cleaner_id', cleanerId)\r\n      .eq('service_date', serviceDate)\r\n      .in('status', ['pending', 'confirmed']);\r\n\r\n    if (error) {\r\n      console.error('Error checking booking conflicts:', error);\r\n      return false; // Assume no conflict on error\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      return false; // No bookings, no conflict\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n\r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number'\r\n          ? booking.service_duration\r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        return true; // Conflict found\r\n      }\r\n    }\r\n\r\n    return false; // No conflicts\r\n  } catch (error) {\r\n    console.error('Unexpected error checking booking conflict:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate reliability score for a cleaner (server-side wrapper)\r\n * This calls the database function if available, otherwise calculates client-side\r\n */\r\nexport async function calculateCleanerReliabilityScore(cleanerId: string): Promise<number> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Try to call the database function\r\n    const { data, error } = await supabase.rpc('calculate_cleaner_reliability_score', {\r\n      cleaner_id: cleanerId,\r\n    });\r\n\r\n    if (!error && data !== null) {\r\n      return parseFloat(data.toString());\r\n    }\r\n\r\n    // Fallback: fetch cleaner and calculate client-side\r\n    const { data: cleaner, error: fetchError } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('id', cleanerId)\r\n      .single();\r\n\r\n    if (fetchError || !cleaner) {\r\n      return 50.0; // Default score\r\n    }\r\n\r\n    return calculateReliabilityScore(cleaner as Cleaner);\r\n  } catch (error) {\r\n    console.error('Error calculating reliability score:', error);\r\n    return 50.0; // Default score on error\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners with enhanced filtering criteria\r\n * Filters by: Location, Availability, Booking conflicts\r\n * Sorts by: Reliability Score, Rating\r\n */\r\nexport async function getAvailableCleanersWithCriteria(params: {\r\n  serviceSuburb?: string;\r\n  serviceDate?: string;\r\n  serviceTime?: string;\r\n  serviceDuration?: number;\r\n  minRating?: number;\r\n  minReliabilityScore?: number;\r\n}): Promise<{\r\n  success: boolean;\r\n  cleaners?: CleanerWithAvailability[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const {\r\n      serviceSuburb,\r\n      serviceDate,\r\n      serviceTime,\r\n      serviceDuration = 3,\r\n      minRating = 0,\r\n      minReliabilityScore = 0,\r\n    } = params;\r\n\r\n    // Build base query\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query.order('reliability_score', { ascending: false, nullsFirst: false })\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = (data || []) as Cleaner[];\r\n\r\n    // Filter by is_available\r\n    cleaners = cleaners.filter((cleaner) => cleaner.is_available !== false);\r\n\r\n    // Filter by location (suburb)\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true; // Serve all areas\r\n        }\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Filter by day of week availability if date is provided\r\n    if (serviceDate) {\r\n      const date = new Date(serviceDate);\r\n      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        const dayMap: Record<number, keyof Cleaner> = {\r\n          0: 'available_sunday',\r\n          1: 'available_monday',\r\n          2: 'available_tuesday',\r\n          3: 'available_wednesday',\r\n          4: 'available_thursday',\r\n          5: 'available_friday',\r\n          6: 'available_saturday',\r\n        };\r\n        const dayField = dayMap[dayOfWeek];\r\n        return cleaner[dayField] !== false;\r\n      });\r\n    }\r\n\r\n    // Filter by minimum rating\r\n    if (minRating > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.rating || 0) >= minRating);\r\n    }\r\n\r\n    // Filter by minimum reliability score\r\n    if (minReliabilityScore > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.reliability_score || 0) >= minReliabilityScore);\r\n    }\r\n\r\n    // Enrich cleaners with availability and booking conflict information\r\n    const enrichedCleaners: CleanerWithAvailability[] = await Promise.all(\r\n      cleaners.map(async (cleaner) => {\r\n        let isAvailableForSlot = true;\r\n        let bookingConflict = false;\r\n\r\n        // Check booking conflict if date and time are provided\r\n        if (serviceDate && serviceTime && serviceDuration) {\r\n          bookingConflict = await checkCleanerBookingConflict(\r\n            cleaner.id,\r\n            serviceDate,\r\n            serviceTime,\r\n            serviceDuration\r\n          );\r\n          isAvailableForSlot = !bookingConflict;\r\n        }\r\n\r\n        // Calculate reliability score if not present\r\n        const reliabilityScore = cleaner.reliability_score ?? calculateReliabilityScore(cleaner);\r\n\r\n        return {\r\n          ...cleaner,\r\n          reliability_score: reliabilityScore,\r\n          isAvailableForSlot,\r\n          bookingConflict,\r\n          completionRate: calculateCompletionRate(cleaner),\r\n          onTimeRate: calculateOnTimeRate(cleaner),\r\n        };\r\n      })\r\n    );\r\n\r\n    // Sort by reliability score and rating (already sorted by query, but ensure consistency)\r\n    enrichedCleaners.sort((a, b) => {\r\n      const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n      const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n\r\n    return { success: true, cleaners: enrichedCleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners with criteria:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1773, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/.next-internal/server/app/booking/details/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getServices as '00f6a41d53889140d7e9eb8567bc58b1384742947f'} from 'ACTIONS_MODULE0'\nexport {getAdditionalServices as '40ba270d5bde2a8477c429febb815e3168fe1f680c'} from 'ACTIONS_MODULE0'\nexport {getHomeDetailOptions as '4064366348e3635d7d32c5f8e580ee61d31c234f51'} from 'ACTIONS_MODULE0'\nexport {getCleaningEquipment as '00d1405999e1046495476b3d80637183450821bfc0'} from 'ACTIONS_MODULE0'\nexport {getWorkingHours as '0019532f868a94df6c0122768d799c068359648554'} from 'ACTIONS_MODULE1'\nexport {getWorkingHoursFromOptions as '00c3eb366471dc28d2ba12ca24c27104c719562fe7'} from 'ACTIONS_MODULE1'\nexport {checkAvailabilityForAllSlots as '70aa5452687b8d50280a60de82263c1c523830b083'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AAIA"}}]
}