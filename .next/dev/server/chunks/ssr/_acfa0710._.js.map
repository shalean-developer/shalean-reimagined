{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function createClient() {\r\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\r\n  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\r\n\r\n  if (!supabaseUrl || !supabaseAnonKey) {\r\n    console.error('Missing Supabase environment variables: NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY')\r\n    throw new Error('Supabase configuration is missing. Please check your environment variables.')\r\n  }\r\n\r\n  try {\r\n    const cookieStore = await cookies()\r\n\r\n    return createServerClient(\r\n      supabaseUrl,\r\n      supabaseAnonKey,\r\n      {\r\n        cookies: {\r\n          getAll() {\r\n            return cookieStore.getAll()\r\n          },\r\n          setAll(cookiesToSet) {\r\n            try {\r\n              cookiesToSet.forEach(({ name, value, options }) =>\r\n                cookieStore.set(name, value, options)\r\n              )\r\n            } catch {\r\n              // The `setAll` method was called from a Server Component.\r\n              // This can be ignored if you have middleware refreshing\r\n              // user sessions.\r\n            }\r\n          },\r\n        },\r\n      }\r\n    )\r\n  } catch (error) {\r\n    console.error('Error creating Supabase client:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM;IACN,MAAM;IAEN;;IAKA,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,0IAAO;QAEjC,OAAO,IAAA,+LAAkB,EACvB,aACA,iBACA;YACE,SAAS;gBACP;oBACE,OAAO,YAAY,MAAM;gBAC3B;gBACA,QAAO,YAAY;oBACjB,IAAI;wBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;oBAEjC,EAAE,OAAM;oBACN,0DAA0D;oBAC1D,wDAAwD;oBACxD,iBAAiB;oBACnB;gBACF;YACF;QACF;IAEJ,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,mCAAmC;QACjD,MAAM;IACR;AACF"}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/%28dashboard%29/layout-client.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const CleanerLayoutClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call CleanerLayoutClient() from the server but CleanerLayoutClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/cleaner/(dashboard)/layout-client.tsx <module evaluation>\",\n    \"CleanerLayoutClient\",\n);\n"],"names":[],"mappings":";;;;AAAA,uEAAuE;AACvE;;AACO,MAAM,sBAAsB,IAAA,wQAAuB,EACtD;IAAa,MAAM,IAAI,MAAM;AAAsP,GACnR,2EACA","ignoreList":[0]}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/%28dashboard%29/layout-client.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const CleanerLayoutClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call CleanerLayoutClient() from the server but CleanerLayoutClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/cleaner/(dashboard)/layout-client.tsx\",\n    \"CleanerLayoutClient\",\n);\n"],"names":[],"mappings":";;;;AAAA,uEAAuE;AACvE;;AACO,MAAM,sBAAsB,IAAA,wQAAuB,EACtD;IAAa,MAAM,IAAI,MAAM;AAAsP,GACnR,uDACA","ignoreList":[0]}},
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/supabase/server-admin.ts"],"sourcesContent":["import { createClient as createSupabaseClient } from '@supabase/supabase-js'\r\n\r\n/**\r\n * Creates a Supabase client with service role key (bypasses RLS)\r\n * Use this ONLY for server-side operations that need to bypass Row Level Security\r\n * This should only be used in server actions, API routes, and server components\r\n * \r\n * IMPORTANT: Add SUPABASE_SERVICE_ROLE_KEY to your .env.local file\r\n * Get it from: Supabase Dashboard -> Settings -> API -> service_role key (secret)\r\n */\r\nexport function createAdminClient() {\r\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!\r\n  const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY\r\n\r\n  if (!supabaseServiceRoleKey) {\r\n    const errorMsg = 'SUPABASE_SERVICE_ROLE_KEY is not set. This is REQUIRED for profile operations.'\r\n    console.error('‚ùå', errorMsg)\r\n    console.error('üìù Get your service role key from: Supabase Dashboard -> Settings -> API -> service_role key (secret)')\r\n    console.error('üìù Add it to your .env.local file as: SUPABASE_SERVICE_ROLE_KEY=your_key_here')\r\n    \r\n    // Throw an error instead of falling back to anon key\r\n    // This forces users to set the service role key\r\n    throw new Error(errorMsg)\r\n  }\r\n\r\n  // Create client with service role key (bypasses RLS completely)\r\n  const client = createSupabaseClient(supabaseUrl, supabaseServiceRoleKey, {\r\n    auth: {\r\n      autoRefreshToken: false,\r\n      persistSession: false,\r\n    },\r\n    db: {\r\n      schema: 'public',\r\n    },\r\n  })\r\n  \r\n  return client\r\n}\r\n\r\n"],"names":[],"mappings":";;;;AAAA;;AAUO,SAAS;IACd,MAAM;IACN,MAAM,yBAAyB,QAAQ,GAAG,CAAC,yBAAyB;IAEpE,IAAI,CAAC,wBAAwB;QAC3B,MAAM,WAAW;QACjB,QAAQ,KAAK,CAAC,KAAK;QACnB,QAAQ,KAAK,CAAC;QACd,QAAQ,KAAK,CAAC;QAEd,qDAAqD;QACrD,gDAAgD;QAChD,MAAM,IAAI,MAAM;IAClB;IAEA,gEAAgE;IAChE,MAAM,SAAS,IAAA,8LAAoB,EAAC,aAAa,wBAAwB;QACvE,MAAM;YACJ,kBAAkB;YAClB,gBAAgB;QAClB;QACA,IAAI;YACF,QAAQ;QACV;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/lib/utils/cleaner-earnings.ts"],"sourcesContent":["/**\r\n * Cleaner earnings calculation utilities\r\n * \r\n * Implements tiered earnings system:\r\n * - Standard/Airbnb: 70% if ‚â•3 months AND ‚â•400 hours, else 60%\r\n * - Deep Cleaning/Move In/Out/Carpet Cleaning: R250 per cleaner (fixed)\r\n * - Tips are added to earnings and divided among cleaners if multiple assigned\r\n */\r\n\r\nimport { Booking } from '@/types/booking';\r\n\r\n/**\r\n * Check if a service is team-based (Deep Cleaning, Move In/Out, Carpet Cleaning)\r\n * These services pay a fixed R250 per cleaner\r\n * \r\n * @param serviceType - The service type name (case-insensitive)\r\n * @returns true if the service is team-based and uses fixed earnings\r\n */\r\nexport function isTeamBasedService(serviceType: string): boolean {\r\n  if (!serviceType) return false;\r\n  \r\n  const normalized = serviceType.toLowerCase().trim();\r\n  \r\n  // Deep Cleaning\r\n  if (normalized.includes('deep')) {\r\n    return true;\r\n  }\r\n  \r\n  // Move In/Out\r\n  if (normalized.includes('move')) {\r\n    if (normalized.includes('in/out') || \r\n        normalized.includes('in out') || \r\n        normalized.includes('inout')) {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  // Carpet Cleaning\r\n  if (normalized.includes('carpet')) {\r\n    return true;\r\n  }\r\n  \r\n  return false;\r\n}\r\n\r\n/**\r\n * Calculate cleaner tenure in months from created_at date\r\n * \r\n * @param createdAt - The cleaner's created_at timestamp (ISO string or Date)\r\n * @returns Number of months (as a decimal, e.g., 3.5 months)\r\n */\r\nexport function calculateCleanerTenure(createdAt: string | Date): number {\r\n  if (!createdAt) return 0;\r\n  \r\n  const createdDate = typeof createdAt === 'string' ? new Date(createdAt) : createdAt;\r\n  const now = new Date();\r\n  \r\n  // Calculate difference in milliseconds\r\n  const diffMs = now.getTime() - createdDate.getTime();\r\n  \r\n  // Convert to months (approximate: 30 days per month)\r\n  const diffDays = diffMs / (1000 * 60 * 60 * 24);\r\n  const months = diffDays / 30;\r\n  \r\n  return Math.max(0, months);\r\n}\r\n\r\n/**\r\n * Calculate total hours worked from completed and paid bookings\r\n * \r\n * @param bookings - Array of bookings with status, payment_status, and service_duration\r\n * @returns Total hours worked (sum of service_duration from completed AND paid bookings)\r\n */\r\nexport function calculateTotalHours(bookings: Array<{\r\n  status: string;\r\n  payment_status: string;\r\n  service_duration: number;\r\n}>): number {\r\n  if (!bookings || bookings.length === 0) return 0;\r\n  \r\n  return bookings\r\n    .filter(b => b.status === 'completed' && b.payment_status === 'paid')\r\n    .reduce((total, booking) => {\r\n      const duration = Number(booking.service_duration) || 0;\r\n      return total + duration;\r\n    }, 0);\r\n}\r\n\r\n/**\r\n * Determine earnings percentage based on cleaner eligibility\r\n * \r\n * @param tenureMonths - Cleaner's tenure in months\r\n * @param totalHours - Total hours worked (completed AND paid bookings)\r\n * @returns 0.70 if eligible (‚â•3 months AND ‚â•400 hours), else 0.60\r\n */\r\nexport function getEarningsPercentage(tenureMonths: number, totalHours: number): number {\r\n  if (tenureMonths >= 3 && totalHours >= 400) {\r\n    return 0.70;\r\n  }\r\n  return 0.60;\r\n}\r\n\r\n/**\r\n * Calculate cleaner earnings for a single booking\r\n * \r\n * Calculation steps for non-team services:\r\n * 1. Calculate earnings for 1 default cleaner: (total_amount - service_fee - equipment_supply_price) √ó earningsPercentage\r\n * 2. Add additional_cleaners_price to the earnings pool\r\n * 3. Divide the total earnings pool by the number of cleaners (including the base cleaner)\r\n * \r\n * Equipment fee is excluded from earnings. Additional cleaners fee is added to the earnings pool\r\n * and then divided among all cleaners equally.\r\n * \r\n * @param booking - The booking object\r\n * @param cleanerId - The cleaner's ID (for verification if needed)\r\n * @param earningsPercentage - The percentage to use (0.60 or 0.70) for non-team services\r\n * @param preferredCleanerIds - Array of cleaner IDs assigned to this booking\r\n * @returns The cleaner's earnings for this booking (excluding tip, which is added separately)\r\n */\r\nexport function calculateCleanerEarnings(\r\n  booking: {\r\n    service_type: string;\r\n    total_amount: number;\r\n    service_fee: number;\r\n    equipment_supply_price?: number;\r\n    additional_cleaners_price?: number;\r\n    preferred_cleaner_ids?: string[] | null;\r\n    preferred_cleaner_id?: string | null;\r\n  },\r\n  cleanerId: string,\r\n  earningsPercentage: number,\r\n  preferredCleanerIds?: string[] | null\r\n): number {\r\n  // For team-based services: fixed R250 per cleaner\r\n  if (isTeamBasedService(booking.service_type)) {\r\n    return 250;\r\n  }\r\n  \r\n  // For other services: \r\n  // Step 1: Calculate earnings for 1 default cleaner (excluding only equipment and service fee)\r\n  // Step 2: Add additional_cleaners_price to the earnings pool\r\n  // Step 3: Divide the total by the number of cleaners (including the base cleaner)\r\n  // Equipment fee is excluded from earnings, but additional cleaners fee is added to the earnings pool\r\n  const equipmentPrice = Number(booking.equipment_supply_price) || 0;\r\n  const additionalCleanersPrice = Number(booking.additional_cleaners_price) || 0;\r\n  \r\n  // Step 1: Calculate amount for base cleaner (excluding only equipment and service fee)\r\n  const amountForBaseCleaner = (Number(booking.total_amount) || 0) - (Number(booking.service_fee) || 0) - equipmentPrice;\r\n  \r\n  // Calculate earnings for 1 cleaner\r\n  const baseEarningsForOneCleaner = amountForBaseCleaner * earningsPercentage;\r\n  \r\n  // Step 2: Add additional cleaners fee to the earnings pool\r\n  const totalEarningsPool = baseEarningsForOneCleaner + additionalCleanersPrice;\r\n  \r\n  // Determine number of cleaners assigned to this booking\r\n  // Use preferred_cleaner_ids if available, otherwise check preferred_cleaner_id\r\n  let numCleaners = 1;\r\n  if (preferredCleanerIds && Array.isArray(preferredCleanerIds) && preferredCleanerIds.length > 0) {\r\n    numCleaners = preferredCleanerIds.length;\r\n  } else if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids) && booking.preferred_cleaner_ids.length > 0) {\r\n    numCleaners = booking.preferred_cleaner_ids.length;\r\n  } else if (booking.preferred_cleaner_id) {\r\n    numCleaners = 1;\r\n  }\r\n  \r\n  // Step 3: Divide total earnings pool equally among all assigned cleaners\r\n  return totalEarningsPool / numCleaners;\r\n}\r\n\r\n/**\r\n * Calculate tip amount per cleaner (tips are divided equally among all cleaners)\r\n * \r\n * @param tipAmount - Total tip amount from booking\r\n * @param preferredCleanerIds - Array of cleaner IDs assigned to this booking\r\n * @param preferredCleanerId - Single cleaner ID (for backward compatibility)\r\n * @returns Tip amount for this cleaner\r\n */\r\nexport function calculateTipPerCleaner(\r\n  tipAmount: number,\r\n  preferredCleanerIds?: string[] | null,\r\n  preferredCleanerId?: string | null\r\n): number {\r\n  const tip = Number(tipAmount) || 0;\r\n  if (tip <= 0) return 0;\r\n  \r\n  // Determine number of cleaners\r\n  let numCleaners = 1;\r\n  if (preferredCleanerIds && Array.isArray(preferredCleanerIds) && preferredCleanerIds.length > 0) {\r\n    numCleaners = preferredCleanerIds.length;\r\n  } else if (preferredCleanerId) {\r\n    numCleaners = 1;\r\n  }\r\n  \r\n  // Divide tip equally among all cleaners\r\n  return tip / numCleaners;\r\n}\r\n\r\n/**\r\n * Calculate total earnings for a cleaner from a booking (base earnings + tip)\r\n * \r\n * @param booking - The booking object with all required fields\r\n * @param cleanerId - The cleaner's ID\r\n * @param earningsPercentage - The percentage to use (0.60 or 0.70)\r\n * @returns Total earnings (base + tip) for this cleaner from this booking\r\n */\r\nexport function calculateTotalEarningsFromBooking(\r\n  booking: {\r\n    service_type: string;\r\n    total_amount: number;\r\n    service_fee: number;\r\n    equipment_supply_price?: number;\r\n    additional_cleaners_price?: number;\r\n    tip_amount: number;\r\n    preferred_cleaner_ids?: string[] | null;\r\n    preferred_cleaner_id?: string | null;\r\n  },\r\n  cleanerId: string,\r\n  earningsPercentage: number\r\n): number {\r\n  const baseEarnings = calculateCleanerEarnings(\r\n    booking,\r\n    cleanerId,\r\n    earningsPercentage,\r\n    booking.preferred_cleaner_ids || null\r\n  );\r\n  \r\n  const tip = calculateTipPerCleaner(\r\n    booking.tip_amount || 0,\r\n    booking.preferred_cleaner_ids,\r\n    booking.preferred_cleaner_id\r\n  );\r\n  \r\n  return baseEarnings + tip;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 234, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { createAdminClient } from '@/lib/supabase/server-admin';\r\nimport { Booking } from '@/types/booking';\r\nimport { Cleaner } from '@/types/booking';\r\nimport {\r\n  calculateCleanerTenure,\r\n  calculateTotalHours,\r\n  getEarningsPercentage,\r\n  calculateTotalEarningsFromBooking,\r\n  calculateCleanerEarnings,\r\n  calculateTipPerCleaner,\r\n} from '@/lib/utils/cleaner-earnings';\r\n\r\n/**\r\n * Get cleaner by phone number\r\n */\r\nexport async function getCleanerByPhone(phone: string): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    \r\n    // Normalize phone number (remove spaces, dashes, etc.)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    \r\n    const { data, error } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .or(`phone.eq.${normalizedPhone},phone.eq.+${normalizedPhone}`)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaner by phone:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!data) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: data as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerByPhone:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Authenticate cleaner with phone and password\r\n * Uses Supabase Auth - expects email format: {phone}@cleaners.shalean.local\r\n * Admin should create auth accounts with this email format when creating cleaner accounts\r\n */\r\nexport async function authenticateCleaner(\r\n  phone: string,\r\n  password: string\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // First, find the cleaner by phone to verify they exist\r\n    const cleanerResult = await getCleanerByPhone(phone);\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    const cleaner = cleanerResult.cleaner;\r\n\r\n    // Use phone-based email format for login\r\n    // Format: {phone}@cleaners.shalean.local\r\n    // Normalize phone (remove spaces, keep + if present)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    const authEmail = `${normalizedPhone}@cleaners.shalean.local`;\r\n\r\n    // Authenticate with Supabase Auth using client-side (this should be called from client)\r\n    // Note: This function should ideally be called from a client component\r\n    // For server-side, we'll return the cleaner info and let client handle auth\r\n    const supabase = await createClient();\r\n    \r\n    // Try to authenticate\r\n    const { data, error } = await supabase.auth.signInWithPassword({\r\n      email: authEmail,\r\n      password,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Authentication error:', error);\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Authentication failed' };\r\n    }\r\n\r\n    // Update cleaner's auth_user_id if not set\r\n    if (!cleaner.auth_user_id) {\r\n      try {\r\n        const adminSupabase = createAdminClient();\r\n        await adminSupabase\r\n          .from('cleaners')\r\n          .update({ auth_user_id: data.user.id })\r\n          .eq('id', cleaner.id);\r\n      } catch (updateError) {\r\n        // Log but don't fail - auth_user_id update is optional\r\n        console.warn('Could not update auth_user_id:', updateError);\r\n      }\r\n    }\r\n\r\n    return { success: true, cleaner };\r\n  } catch (error) {\r\n    console.error('Error in authenticateCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Authentication failed',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get current authenticated cleaner\r\n */\r\nexport async function getCurrentCleaner(): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    // Try to find cleaner by auth_user_id first\r\n    let cleanerQuery = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('auth_user_id', user.id)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    let { data: cleaner, error: cleanerError } = await cleanerQuery;\r\n\r\n    // If not found by auth_user_id, try to match by phone from email\r\n    if (!cleaner && !cleanerError && user.email) {\r\n      // Extract phone from email format: {phone}@cleaners.shalean.local\r\n      const phoneMatch = user.email.match(/^(.+)@cleaners\\.shalean\\.local$/);\r\n      if (phoneMatch) {\r\n        const phone = phoneMatch[1];\r\n        const phoneResult = await getCleanerByPhone(phone);\r\n        if (phoneResult.success && phoneResult.cleaner) {\r\n          cleaner = phoneResult.cleaner;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner profile not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: cleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCurrentCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get bookings assigned to the authenticated cleaner\r\n */\r\nexport async function getCleanerBookings(\r\n  filter?: 'all' | 'today' | 'upcoming' | 'past' | 'on_my_way' | 'started'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n    \r\n    // Fetch bookings where cleaner is assigned via preferred_cleaner_id (single)\r\n    let singleQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter\r\n    let arrayQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Apply filters to both queries\r\n    if (filter && filter !== 'all') {\r\n      const today = new Date().toISOString().split('T')[0];\r\n      \r\n      switch (filter) {\r\n        case 'today':\r\n          singleQuery = singleQuery.eq('service_date', today);\r\n          arrayQuery = arrayQuery.eq('service_date', today);\r\n          break;\r\n        case 'upcoming':\r\n          singleQuery = singleQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          arrayQuery = arrayQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          break;\r\n        case 'past':\r\n          singleQuery = singleQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          arrayQuery = arrayQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          break;\r\n        case 'on_my_way':\r\n          singleQuery = singleQuery.eq('status', 'on_my_way');\r\n          arrayQuery = arrayQuery.eq('status', 'on_my_way');\r\n          break;\r\n        case 'started':\r\n          singleQuery = singleQuery.eq('status', 'started');\r\n          arrayQuery = arrayQuery.eq('status', 'started');\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Execute both queries\r\n    const [singleResult, arrayResult] = await Promise.all([\r\n      singleQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true }),\r\n      arrayQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true })\r\n    ]);\r\n\r\n    if (singleResult.error) {\r\n      console.error('Error fetching cleaner bookings (single):', singleResult.error);\r\n      return { success: false, error: singleResult.error.message };\r\n    }\r\n\r\n    if (arrayResult.error) {\r\n      console.error('Error fetching cleaner bookings (array):', arrayResult.error);\r\n      return { success: false, error: arrayResult.error.message };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerBookings] Fetched bookings:', {\r\n      cleanerId,\r\n      filter,\r\n      singleBookingsCount: singleResult.data?.length || 0,\r\n      arrayBookingsCount: arrayResult.data?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const filteredArrayBookings = (arrayResult.data || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine results and remove duplicates\r\n    const allBookings = [\r\n      ...(singleResult.data || []),\r\n      ...filteredArrayBookings\r\n    ];\r\n\r\n    // Remove duplicates by booking ID\r\n    const uniqueBookingsMap = new Map<string, Booking>();\r\n    allBookings.forEach((booking: any) => {\r\n      if (booking.id && !uniqueBookingsMap.has(booking.id)) {\r\n        uniqueBookingsMap.set(booking.id, booking as Booking);\r\n      }\r\n    });\r\n\r\n    const bookings = Array.from(uniqueBookingsMap.values());\r\n\r\n    // Sort by service_date and service_time\r\n    bookings.sort((a, b) => {\r\n      const dateCompare = a.service_date.localeCompare(b.service_date);\r\n      if (dateCompare !== 0) return dateCompare;\r\n      return a.service_time.localeCompare(b.service_time);\r\n    });\r\n\r\n    return { success: true, bookings };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate cleaner earnings for a specific booking\r\n * This helper function is used to display earnings on booking details page\r\n */\r\nexport async function calculateBookingEarnings(bookingId: string): Promise<{\r\n  success: boolean;\r\n  earnings?: {\r\n    baseEarnings: number;\r\n    tipAmount: number;\r\n    totalEarnings: number;\r\n    earningsPercentage: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get the booking\r\n    const { data: booking, error: bookingError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (bookingError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Calculate tenure and total hours to determine percentage\r\n    // For single booking display, we need all paid completed bookings to calculate hours\r\n    // Use the same approach as getCleanerStats\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate base earnings\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const baseEarnings = calculateCleanerEarnings(\r\n      {\r\n        service_type: booking.service_type || '',\r\n        total_amount: Number(booking.total_amount) || 0,\r\n        service_fee: Number(booking.service_fee) || 0,\r\n        equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n        additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n        preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n        preferred_cleaner_id: booking.preferred_cleaner_id,\r\n      },\r\n      cleanerId,\r\n      earningsPercentage,\r\n      booking.preferred_cleaner_ids\r\n    );\r\n\r\n    // Calculate tip per cleaner\r\n    const tipAmount = calculateTipPerCleaner(\r\n      Number(booking.tip_amount) || 0,\r\n      booking.preferred_cleaner_ids,\r\n      booking.preferred_cleaner_id\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      earnings: {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n        earningsPercentage,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error calculating booking earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get a specific booking by ID (only if assigned to authenticated cleaner)\r\n */\r\nexport async function getCleanerBookingById(\r\n  bookingId: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Fetch the booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError) {\r\n      console.error('Error fetching booking:', fetchError);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    if (!booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Verify the cleaner is assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    // Check single cleaner assignment\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    // Check multiple cleaner assignment\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    if (!isAssignedSingle && !isAssignedMultiple) {\r\n      return { \r\n        success: false, \r\n        error: 'Unauthorized: You are not assigned to this booking' \r\n      };\r\n    }\r\n\r\n    return { success: true, booking: booking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookingById:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch booking',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update booking status (with authorization check for authenticated cleaner)\r\n */\r\nexport async function updateBookingStatus(\r\n  bookingId: string,\r\n  status: Booking['status']\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // First, verify the cleaner is assigned to this booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Validate status transition\r\n    const validTransitions: Record<string, string[]> = {\r\n      'pending': ['confirmed', 'cancelled'],\r\n      'confirmed': ['on_my_way', 'cancelled'],\r\n      'on_my_way': ['started', 'cancelled'],\r\n      'started': ['completed', 'cancelled'],\r\n      'completed': [],\r\n      'cancelled': [],\r\n    };\r\n\r\n    const currentStatus = booking.status;\r\n    const allowedStatuses = validTransitions[currentStatus] || [];\r\n    \r\n    if (!allowedStatuses.includes(status) && status !== currentStatus) {\r\n      return { \r\n        success: false, \r\n        error: `Invalid status transition: cannot change from ${currentStatus} to ${status}` \r\n      };\r\n    }\r\n\r\n    // Update booking status\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({ \r\n        status,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating booking status:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in updateBookingStatus:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update booking status',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Report lateness for a booking (with authorization check for authenticated cleaner)\r\n */\r\nexport async function reportLateness(\r\n  bookingId: string,\r\n  expectedArrivalTime: string, // ISO timestamp\r\n  reason: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Verify authorization\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Update booking with lateness information\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        expected_arrival_time: expectedArrivalTime,\r\n        lateness_reason: reason,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error reporting lateness:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in reportLateness:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to report lateness',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate earnings for multiple bookings at once\r\n * This is more efficient than calculating earnings one booking at a time\r\n */\r\nexport async function calculateBookingsEarnings(bookingIds: string[]): Promise<{\r\n  success: boolean;\r\n  earnings?: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }>;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    if (bookingIds.length === 0) {\r\n      return { success: true, earnings: {} };\r\n    }\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (bookingsError || !bookings) {\r\n      return { success: false, error: 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Get all cleaner bookings to calculate hours\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    // Calculate tenure and hours\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings for each booking\r\n    const earningsRecord: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }> = {};\r\n\r\n    for (const booking of bookings) {\r\n      const baseEarnings = calculateCleanerEarnings(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage,\r\n        booking.preferred_cleaner_ids\r\n      );\r\n\r\n      const tipAmount = calculateTipPerCleaner(\r\n        Number(booking.tip_amount) || 0,\r\n        booking.preferred_cleaner_ids,\r\n        booking.preferred_cleaner_id\r\n      );\r\n\r\n      earningsRecord[booking.id] = {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n      };\r\n    }\r\n\r\n    return { success: true, earnings: earningsRecord };\r\n  } catch (error) {\r\n    console.error('Error calculating bookings earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get cleaner statistics for the authenticated cleaner\r\n */\r\nexport async function getCleanerStats(): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalBookings: number;\r\n    completedBookings: number;\r\n    upcomingBookings: number;\r\n    todayBookings: number;\r\n    totalEarnings: number;\r\n    monthlyEarnings: number;\r\n    averageRating: number;\r\n    reliabilityScore: number;\r\n    completionRate: number;\r\n    onTimeRate: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info including created_at for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('rating, reliability_score, total_bookings, completed_bookings, on_time_bookings, created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings assigned to this cleaner\r\n    // Fetch bookings with preferred_cleaner_id (single) - include all fields needed for earnings calculation\r\n    const { data: singleBookings, error: singleError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter in JS\r\n    const { data: allMultiBookings, error: multiError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_ids, preferred_cleaner_id')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    if (singleError || multiError) {\r\n      console.error('Error fetching bookings for stats:', singleError || multiError);\r\n      return { success: false, error: (singleError || multiError)?.message || 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerStats] Fetched bookings:', {\r\n      cleanerId,\r\n      singleBookingsCount: singleBookings?.length || 0,\r\n      allMultiBookingsCount: allMultiBookings?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const arrayBookings = (allMultiBookings || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates by ID\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((booking: any) => {\r\n      if (booking.id) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    arrayBookings.forEach((booking: any) => {\r\n      if (booking.id && !allBookingsMap.has(booking.id)) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    \r\n    const allBookings = Array.from(allBookingsMap.values());\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n    const now = new Date();\r\n    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];\r\n    const completedBookings = allBookings.filter(b => b.status === 'completed');\r\n    const upcomingBookings = allBookings.filter(b => \r\n      ['pending', 'confirmed', 'on_my_way', 'started'].includes(b.status) &&\r\n      b.service_date >= today\r\n    );\r\n    const todayBookings = allBookings.filter(b => b.service_date === today);\r\n    const paidBookings = allBookings.filter(b => b.payment_status === 'paid');\r\n    const monthlyPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid' && \r\n      b.service_date >= firstDayOfMonth\r\n    );\r\n    const completedPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid'\r\n    );\r\n\r\n    // Calculate cleaner tenure and total hours for eligibility determination\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(allBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings using the new system\r\n    // Only calculate earnings for paid bookings (earnings are only paid when customer has paid)\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const totalEarnings = completedPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const monthlyEarnings = monthlyPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const completionRate = cleaner.total_bookings \r\n      ? (cleaner.completed_bookings || 0) / cleaner.total_bookings * 100 \r\n      : 0;\r\n    \r\n    const onTimeRate = cleaner.completed_bookings\r\n      ? (cleaner.on_time_bookings || 0) / cleaner.completed_bookings * 100\r\n      : 0;\r\n\r\n    return {\r\n      success: true,\r\n      stats: {\r\n        totalBookings: allBookings.length,\r\n        completedBookings: completedBookings.length,\r\n        upcomingBookings: upcomingBookings.length,\r\n        todayBookings: todayBookings.length,\r\n        totalEarnings,\r\n        monthlyEarnings,\r\n        averageRating: Number(cleaner.rating) || 0,\r\n        reliabilityScore: Number(cleaner.reliability_score) || 0,\r\n        completionRate,\r\n        onTimeRate,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update cleaner availability\r\n */\r\nexport async function updateCleanerAvailability(\r\n  cleanerId: string,\r\n  updates: {\r\n    isAvailable?: boolean;\r\n    availableMonday?: boolean;\r\n    availableTuesday?: boolean;\r\n    availableWednesday?: boolean;\r\n    availableThursday?: boolean;\r\n    availableFriday?: boolean;\r\n    availableSaturday?: boolean;\r\n    availableSunday?: boolean;\r\n  }\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (updates.isAvailable !== undefined) {\r\n      updateData.is_available = updates.isAvailable;\r\n    }\r\n    if (updates.availableMonday !== undefined) {\r\n      updateData.available_monday = updates.availableMonday;\r\n    }\r\n    if (updates.availableTuesday !== undefined) {\r\n      updateData.available_tuesday = updates.availableTuesday;\r\n    }\r\n    if (updates.availableWednesday !== undefined) {\r\n      updateData.available_wednesday = updates.availableWednesday;\r\n    }\r\n    if (updates.availableThursday !== undefined) {\r\n      updateData.available_thursday = updates.availableThursday;\r\n    }\r\n    if (updates.availableFriday !== undefined) {\r\n      updateData.available_friday = updates.availableFriday;\r\n    }\r\n    if (updates.availableSaturday !== undefined) {\r\n      updateData.available_saturday = updates.availableSaturday;\r\n    }\r\n    if (updates.availableSunday !== undefined) {\r\n      updateData.available_sunday = updates.availableSunday;\r\n    }\r\n\r\n    const { data: updatedCleaner, error } = await supabase\r\n      .from('cleaners')\r\n      .update(updateData)\r\n      .eq('id', cleanerId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error updating cleaner availability:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, cleaner: updatedCleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in updateCleanerAvailability:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update availability',\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AAGA;;;;;;AAYO,eAAe,kBAAkB,KAAa;IAKnD,IAAI;QACF,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,uDAAuD;QACvD,MAAM,kBAAkB,MAAM,OAAO,CAAC,QAAQ,IAAI,IAAI;QAEtD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAC3B,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,CAAC,SAAS,EAAE,gBAAgB,WAAW,EAAE,iBAAiB,EAC7D,EAAE,CAAC,aAAa,MAChB,WAAW;QAEd,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,oCAAoC;YAClD,OAAO;gBAAE,SAAS;gBAAO,OAAO,MAAM,OAAO;YAAC;QAChD;QAEA,IAAI,CAAC,MAAM;YACT,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoB;QACtD;QAEA,OAAO;YAAE,SAAS;YAAM,SAAS;QAAgB;IACnD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YACL,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF;AAOO,eAAe,oBACpB,KAAa,EACb,QAAgB;IAMhB,IAAI;QACF,wDAAwD;QACxD,MAAM,gBAAgB,MAAM,kBAAkB;QAC9C,IAAI,CAAC,cAAc,OAAO,IAAI,CAAC,cAAc,OAAO,EAAE;YACpD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAmC;QACrE;QAEA,MAAM,UAAU,cAAc,OAAO;QAErC,yCAAyC;QACzC,yCAAyC;QACzC,qDAAqD;QACrD,MAAM,kBAAkB,MAAM,OAAO,CAAC,QAAQ,IAAI,IAAI;QACtD,MAAM,YAAY,GAAG,gBAAgB,uBAAuB,CAAC;QAE7D,wFAAwF;QACxF,uEAAuE;QACvE,4EAA4E;QAC5E,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,sBAAsB;QACtB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,kBAAkB,CAAC;YAC7D,OAAO;YACP;QACF;QAEA,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,yBAAyB;YACvC,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAmC;QACrE;QAEA,IAAI,CAAC,KAAK,IAAI,EAAE;YACd,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAwB;QAC1D;QAEA,2CAA2C;QAC3C,IAAI,CAAC,QAAQ,YAAY,EAAE;YACzB,IAAI;gBACF,MAAM,gBAAgB,IAAA,8JAAiB;gBACvC,MAAM,cACH,IAAI,CAAC,YACL,MAAM,CAAC;oBAAE,cAAc,KAAK,IAAI,CAAC,EAAE;gBAAC,GACpC,EAAE,CAAC,MAAM,QAAQ,EAAE;YACxB,EAAE,OAAO,aAAa;gBACpB,uDAAuD;gBACvD,QAAQ,IAAI,CAAC,kCAAkC;YACjD;QACF;QAEA,OAAO;YAAE,SAAS;YAAM;QAAQ;IAClC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO;YACL,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF;AAKO,eAAe;IAKpB,IAAI;QACF,MAAM,WAAW,MAAM,IAAA,gJAAY;QACnC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,OAAO,SAAS,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAExE,IAAI,aAAa,CAAC,MAAM;YACtB,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoB;QACtD;QAEA,4CAA4C;QAC5C,IAAI,eAAe,SAChB,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,gBAAgB,KAAK,EAAE,EAC1B,EAAE,CAAC,aAAa,MAChB,WAAW;QAEd,IAAI,EAAE,MAAM,OAAO,EAAE,OAAO,YAAY,EAAE,GAAG,MAAM;QAEnD,iEAAiE;QACjE,IAAI,CAAC,WAAW,CAAC,gBAAgB,KAAK,KAAK,EAAE;YAC3C,kEAAkE;YAClE,MAAM,aAAa,KAAK,KAAK,CAAC,KAAK,CAAC;YACpC,IAAI,YAAY;gBACd,MAAM,QAAQ,UAAU,CAAC,EAAE;gBAC3B,MAAM,cAAc,MAAM,kBAAkB;gBAC5C,IAAI,YAAY,OAAO,IAAI,YAAY,OAAO,EAAE;oBAC9C,UAAU,YAAY,OAAO;gBAC/B;YACF;QACF;QAEA,IAAI,gBAAgB,CAAC,SAAS;YAC5B,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA4B;QAC9D;QAEA,OAAO;YAAE,SAAS;YAAM,SAAS;QAAmB;IACtD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YACL,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF;AAKO,eAAe,mBACpB,MAAwE;IAMxE,IAAI;QACF,kCAAkC;QAClC,MAAM,gBAAgB,MAAM;QAC5B,IAAI,CAAC,cAAc,OAAO,IAAI,CAAC,cAAc,OAAO,EAAE;YACpD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAiD;QACnF;QAEA,MAAM,YAAY,cAAc,OAAO,CAAC,EAAE;QAC1C,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,6EAA6E;QAC7E,IAAI,cAAc,SACf,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,wBAAwB;QAE9B,yFAAyF;QACzF,IAAI,aAAa,SACd,IAAI,CAAC,YACL,MAAM,CAAC,KACP,GAAG,CAAC,yBAAyB,MAAM;QAEtC,gCAAgC;QAChC,IAAI,UAAU,WAAW,OAAO;YAC9B,MAAM,QAAQ,IAAI,OAAO,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;YAEpD,OAAQ;gBACN,KAAK;oBACH,cAAc,YAAY,EAAE,CAAC,gBAAgB;oBAC7C,aAAa,WAAW,EAAE,CAAC,gBAAgB;oBAC3C;gBACF,KAAK;oBACH,cAAc,YAAY,GAAG,CAAC,gBAAgB,OACjC,EAAE,CAAC,UAAU;wBAAC;wBAAW;wBAAa;wBAAa;qBAAU;oBAC1E,aAAa,WAAW,GAAG,CAAC,gBAAgB,OAC/B,EAAE,CAAC,UAAU;wBAAC;wBAAW;wBAAa;wBAAa;qBAAU;oBAC1E;gBACF,KAAK;oBACH,cAAc,YAAY,EAAE,CAAC,gBAAgB,OAChC,EAAE,CAAC;oBAChB,aAAa,WAAW,EAAE,CAAC,gBAAgB,OAC9B,EAAE,CAAC;oBAChB;gBACF,KAAK;oBACH,cAAc,YAAY,EAAE,CAAC,UAAU;oBACvC,aAAa,WAAW,EAAE,CAAC,UAAU;oBACrC;gBACF,KAAK;oBACH,cAAc,YAAY,EAAE,CAAC,UAAU;oBACvC,aAAa,WAAW,EAAE,CAAC,UAAU;oBACrC;YACJ;QACF;QAEA,uBAAuB;QACvB,MAAM,CAAC,cAAc,YAAY,GAAG,MAAM,QAAQ,GAAG,CAAC;YACpD,YAAY,KAAK,CAAC,gBAAgB;gBAAE,WAAW;YAAK,GAAG,KAAK,CAAC,gBAAgB;gBAAE,WAAW;YAAK;YAC/F,WAAW,KAAK,CAAC,gBAAgB;gBAAE,WAAW;YAAK,GAAG,KAAK,CAAC,gBAAgB;gBAAE,WAAW;YAAK;SAC/F;QAED,IAAI,aAAa,KAAK,EAAE;YACtB,QAAQ,KAAK,CAAC,6CAA6C,aAAa,KAAK;YAC7E,OAAO;gBAAE,SAAS;gBAAO,OAAO,aAAa,KAAK,CAAC,OAAO;YAAC;QAC7D;QAEA,IAAI,YAAY,KAAK,EAAE;YACrB,QAAQ,KAAK,CAAC,4CAA4C,YAAY,KAAK;YAC3E,OAAO;gBAAE,SAAS;gBAAO,OAAO,YAAY,KAAK,CAAC,OAAO;YAAC;QAC5D;QAEA,gBAAgB;QAChB,QAAQ,GAAG,CAAC,0CAA0C;YACpD;YACA;YACA,qBAAqB,aAAa,IAAI,EAAE,UAAU;YAClD,oBAAoB,YAAY,IAAI,EAAE,UAAU;QAClD;QAEA,4EAA4E;QAC5E,8EAA8E;QAC9E,MAAM,gBAAgB,CAAC;YACrB,IAAI,CAAC,IAAI,OAAO;YAChB,OAAO,OAAO,IAAI,WAAW,GAAG,IAAI;QACtC;QACA,MAAM,sBAAsB,cAAc;QAE1C,MAAM,wBAAwB,CAAC,YAAY,IAAI,IAAI,EAAE,EAAE,MAAM,CAAC,CAAC;YAC7D,IAAI,CAAC,QAAQ,qBAAqB,IAAI,CAAC,MAAM,OAAO,CAAC,QAAQ,qBAAqB,GAAG;gBACnF,OAAO;YACT;YACA,0BAA0B;YAC1B,IAAI,QAAQ,qBAAqB,CAAC,MAAM,KAAK,GAAG;gBAC9C,OAAO;YACT;YACA,wEAAwE;YACxE,OAAO,QAAQ,qBAAqB,CAAC,IAAI,CAAC,CAAC,KAAe,cAAc,QAAQ;QAClF;QAEA,wCAAwC;QACxC,MAAM,cAAc;eACd,aAAa,IAAI,IAAI,EAAE;eACxB;SACJ;QAED,kCAAkC;QAClC,MAAM,oBAAoB,IAAI;QAC9B,YAAY,OAAO,CAAC,CAAC;YACnB,IAAI,QAAQ,EAAE,IAAI,CAAC,kBAAkB,GAAG,CAAC,QAAQ,EAAE,GAAG;gBACpD,kBAAkB,GAAG,CAAC,QAAQ,EAAE,EAAE;YACpC;QACF;QAEA,MAAM,WAAW,MAAM,IAAI,CAAC,kBAAkB,MAAM;QAEpD,wCAAwC;QACxC,SAAS,IAAI,CAAC,CAAC,GAAG;YAChB,MAAM,cAAc,EAAE,YAAY,CAAC,aAAa,CAAC,EAAE,YAAY;YAC/D,IAAI,gBAAgB,GAAG,OAAO;YAC9B,OAAO,EAAE,YAAY,CAAC,aAAa,CAAC,EAAE,YAAY;QACpD;QAEA,OAAO;YAAE,SAAS;YAAM;QAAS;IACnC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO;YACL,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF;AAMO,eAAe,yBAAyB,SAAiB;IAU9D,IAAI;QACF,kCAAkC;QAClC,MAAM,gBAAgB,MAAM;QAC5B,IAAI,CAAC,cAAc,OAAO,IAAI,CAAC,cAAc,OAAO,EAAE;YACpD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAiD;QACnF;QAEA,MAAM,YAAY,cAAc,OAAO,CAAC,EAAE;QAC1C,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,0CAA0C;QAC1C,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,YAAY,EAAE,GAAG,MAAM,SAClD,IAAI,CAAC,YACL,MAAM,CAAC,cACP,EAAE,CAAC,MAAM,WACT,WAAW;QAEd,IAAI,gBAAgB,CAAC,SAAS;YAC5B,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoB;QACtD;QAEA,kBAAkB;QAClB,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,YAAY,EAAE,GAAG,MAAM,SAClD,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,WACT,WAAW;QAEd,IAAI,gBAAgB,CAAC,SAAS;YAC5B,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoB;QACtD;QAEA,2DAA2D;QAC3D,qFAAqF;QACrF,2CAA2C;QAC3C,MAAM,EAAE,MAAM,cAAc,EAAE,GAAG,MAAM,SACpC,IAAI,CAAC,YACL,MAAM,CAAC,yFACP,EAAE,CAAC,wBAAwB;QAE9B,MAAM,EAAE,MAAM,gBAAgB,EAAE,GAAG,MAAM,SACtC,IAAI,CAAC,YACL,MAAM,CAAC,yFACP,GAAG,CAAC,yBAAyB,MAAM;QAEtC,2CAA2C;QAC3C,MAAM,gBAAgB,CAAC;YACrB,IAAI,CAAC,IAAI,OAAO;YAChB,OAAO,OAAO,IAAI,WAAW,GAAG,IAAI;QACtC;QACA,MAAM,sBAAsB,cAAc;QAE1C,MAAM,gBAAgB,CAAC,oBAAoB,EAAE,EAAE,MAAM,CAAC,CAAC;YACrD,IAAI,CAAC,EAAE,qBAAqB,IAAI,CAAC,MAAM,OAAO,CAAC,EAAE,qBAAqB,GAAG;gBACvE,OAAO;YACT;YACA,IAAI,EAAE,qBAAqB,CAAC,MAAM,KAAK,GAAG;gBACxC,OAAO;YACT;YACA,OAAO,EAAE,qBAAqB,CAAC,IAAI,CAAC,CAAC,KAAe,cAAc,QAAQ;QAC5E;QAEA,gCAAgC;QAChC,MAAM,iBAAiB,IAAI;QAC3B,CAAC,kBAAkB,EAAE,EAAE,OAAO,CAAC,CAAC;YAC9B,IAAI,EAAE,EAAE,EAAE;gBACR,eAAe,GAAG,CAAC,EAAE,EAAE,EAAE;YAC3B;QACF;QACA,cAAc,OAAO,CAAC,CAAC;YACrB,IAAI,EAAE,EAAE,IAAI,CAAC,eAAe,GAAG,CAAC,EAAE,EAAE,GAAG;gBACrC,eAAe,GAAG,CAAC,EAAE,EAAE,EAAE;YAC3B;QACF;QAEA,MAAM,kBAAkB,MAAM,IAAI,CAAC,eAAe,MAAM;QAExD,MAAM,eAAe,IAAA,oKAAsB,EAAC,QAAQ,UAAU;QAC9D,MAAM,aAAa,IAAA,iKAAmB,EAAC;QACvC,MAAM,qBAAqB,IAAA,mKAAqB,EAAC,cAAc;QAE/D,0BAA0B;QAC1B,mFAAmF;QACnF,MAAM,eAAe,IAAA,sKAAwB,EAC3C;YACE,cAAc,QAAQ,YAAY,IAAI;YACtC,cAAc,OAAO,QAAQ,YAAY,KAAK;YAC9C,aAAa,OAAO,QAAQ,WAAW,KAAK;YAC5C,wBAAwB,OAAO,QAAQ,sBAAsB,KAAK;YAClE,2BAA2B,OAAO,QAAQ,yBAAyB,KAAK;YACxE,uBAAuB,QAAQ,qBAAqB;YACpD,sBAAsB,QAAQ,oBAAoB;QACpD,GACA,WACA,oBACA,QAAQ,qBAAqB;QAG/B,4BAA4B;QAC5B,MAAM,YAAY,IAAA,oKAAsB,EACtC,OAAO,QAAQ,UAAU,KAAK,GAC9B,QAAQ,qBAAqB,EAC7B,QAAQ,oBAAoB;QAG9B,OAAO;YACL,SAAS;YACT,UAAU;gBACR;gBACA;gBACA,eAAe,eAAe;gBAC9B;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uCAAuC;QACrD,OAAO;YACL,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF;AAKO,eAAe,sBACpB,SAAiB;IAMjB,IAAI;QACF,kCAAkC;QAClC,MAAM,gBAAgB,MAAM;QAC5B,IAAI,CAAC,cAAc,OAAO,IAAI,CAAC,cAAc,OAAO,EAAE;YACpD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAiD;QACnF;QAEA,MAAM,YAAY,cAAc,OAAO,CAAC,EAAE;QAC1C,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,oBAAoB;QACpB,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,UAAU,EAAE,GAAG,MAAM,SAChD,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,WACT,WAAW;QAEd,IAAI,YAAY;YACd,QAAQ,KAAK,CAAC,2BAA2B;YACzC,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoB;QACtD;QAEA,IAAI,CAAC,SAAS;YACZ,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoB;QACtD;QAEA,iDAAiD;QACjD,MAAM,gBAAgB,CAAC;YACrB,IAAI,CAAC,IAAI,OAAO;YAChB,OAAO,OAAO,IAAI,WAAW,GAAG,IAAI;QACtC;QACA,MAAM,sBAAsB,cAAc;QAE1C,kCAAkC;QAClC,MAAM,mBAAmB,QAAQ,oBAAoB,IACnD,cAAc,QAAQ,oBAAoB,MAAM;QAElD,oCAAoC;QACpC,IAAI,qBAAqB;QACzB,IAAI,QAAQ,qBAAqB,IAAI,MAAM,OAAO,CAAC,QAAQ,qBAAqB,GAAG;YACjF,qBAAqB,QAAQ,qBAAqB,CAAC,IAAI,CACrD,CAAC,KAAe,cAAc,QAAQ;QAE1C;QAEA,IAAI,CAAC,oBAAoB,CAAC,oBAAoB;YAC5C,OAAO;gBACL,SAAS;gBACT,OAAO;YACT;QACF;QAEA,OAAO;YAAE,SAAS;YAAM,SAAS;QAAmB;IACtD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO;YACL,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF;AAKO,eAAe,oBACpB,SAAiB,EACjB,MAAyB;IAMzB,IAAI;QACF,kCAAkC;QAClC,MAAM,gBAAgB,MAAM;QAC5B,IAAI,CAAC,cAAc,OAAO,IAAI,CAAC,cAAc,OAAO,EAAE;YACpD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAiD;QACnF;QAEA,MAAM,YAAY,cAAc,OAAO,CAAC,EAAE;QAC1C,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,wDAAwD;QACxD,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,UAAU,EAAE,GAAG,MAAM,SAChD,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,WACT,WAAW;QAEd,IAAI,cAAc,CAAC,SAAS;YAC1B,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoB;QACtD;QAEA,gEAAgE;QAChE,MAAM,gBAAgB,CAAC;YACrB,IAAI,CAAC,IAAI,OAAO;YAChB,OAAO,OAAO,IAAI,WAAW,GAAG,IAAI;QACtC;QACA,MAAM,sBAAsB,cAAc;QAE1C,MAAM,mBAAmB,QAAQ,oBAAoB,IACnD,cAAc,QAAQ,oBAAoB,MAAM;QAElD,IAAI,qBAAqB;QACzB,IAAI,QAAQ,qBAAqB,IAAI,MAAM,OAAO,CAAC,QAAQ,qBAAqB,GAAG;YACjF,qBAAqB,QAAQ,qBAAqB,CAAC,IAAI,CACrD,CAAC,KAAe,cAAc,QAAQ;QAE1C;QAEA,MAAM,aAAa,oBAAoB;QAEvC,IAAI,CAAC,YAAY;YACf,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAqD;QACvF;QAEA,6BAA6B;QAC7B,MAAM,mBAA6C;YACjD,WAAW;gBAAC;gBAAa;aAAY;YACrC,aAAa;gBAAC;gBAAa;aAAY;YACvC,aAAa;gBAAC;gBAAW;aAAY;YACrC,WAAW;gBAAC;gBAAa;aAAY;YACrC,aAAa,EAAE;YACf,aAAa,EAAE;QACjB;QAEA,MAAM,gBAAgB,QAAQ,MAAM;QACpC,MAAM,kBAAkB,gBAAgB,CAAC,cAAc,IAAI,EAAE;QAE7D,IAAI,CAAC,gBAAgB,QAAQ,CAAC,WAAW,WAAW,eAAe;YACjE,OAAO;gBACL,SAAS;gBACT,OAAO,CAAC,8CAA8C,EAAE,cAAc,IAAI,EAAE,QAAQ;YACtF;QACF;QAEA,wBAAwB;QACxB,MAAM,EAAE,MAAM,cAAc,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SACxD,IAAI,CAAC,YACL,MAAM,CAAC;YACN;YACA,YAAY,IAAI,OAAO,WAAW;QACpC,GACC,EAAE,CAAC,MAAM,WACT,MAAM,GACN,MAAM;QAET,IAAI,aAAa;YACf,QAAQ,KAAK,CAAC,kCAAkC;YAChD,OAAO;gBAAE,SAAS;gBAAO,OAAO,YAAY,OAAO;YAAC;QACtD;QAEA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA0B;IAC7D,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO;YACL,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF;AAKO,eAAe,eACpB,SAAiB,EACjB,mBAA2B,EAC3B,MAAc;IAMd,IAAI;QACF,kCAAkC;QAClC,MAAM,gBAAgB,MAAM;QAC5B,IAAI,CAAC,cAAc,OAAO,IAAI,CAAC,cAAc,OAAO,EAAE;YACpD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAiD;QACnF;QAEA,MAAM,YAAY,cAAc,OAAO,CAAC,EAAE;QAC1C,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,uBAAuB;QACvB,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,UAAU,EAAE,GAAG,MAAM,SAChD,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,WACT,WAAW;QAEd,IAAI,cAAc,CAAC,SAAS;YAC1B,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoB;QACtD;QAEA,gEAAgE;QAChE,MAAM,gBAAgB,CAAC;YACrB,IAAI,CAAC,IAAI,OAAO;YAChB,OAAO,OAAO,IAAI,WAAW,GAAG,IAAI;QACtC;QACA,MAAM,sBAAsB,cAAc;QAE1C,MAAM,mBAAmB,QAAQ,oBAAoB,IACnD,cAAc,QAAQ,oBAAoB,MAAM;QAElD,IAAI,qBAAqB;QACzB,IAAI,QAAQ,qBAAqB,IAAI,MAAM,OAAO,CAAC,QAAQ,qBAAqB,GAAG;YACjF,qBAAqB,QAAQ,qBAAqB,CAAC,IAAI,CACrD,CAAC,KAAe,cAAc,QAAQ;QAE1C;QAEA,MAAM,aAAa,oBAAoB;QAEvC,IAAI,CAAC,YAAY;YACf,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAqD;QACvF;QAEA,2CAA2C;QAC3C,MAAM,EAAE,MAAM,cAAc,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SACxD,IAAI,CAAC,YACL,MAAM,CAAC;YACN,uBAAuB;YACvB,iBAAiB;YACjB,YAAY,IAAI,OAAO,WAAW;QACpC,GACC,EAAE,CAAC,MAAM,WACT,MAAM,GACN,MAAM;QAET,IAAI,aAAa;YACf,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,OAAO;gBAAE,SAAS;gBAAO,OAAO,YAAY,OAAO;YAAC;QACtD;QAEA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA0B;IAC7D,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO;YACL,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF;AAMO,eAAe,0BAA0B,UAAoB;IAKlE,IAAI;QACF,kCAAkC;QAClC,MAAM,gBAAgB,MAAM;QAC5B,IAAI,CAAC,cAAc,OAAO,IAAI,CAAC,cAAc,OAAO,EAAE;YACpD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAiD;QACnF;QAEA,MAAM,YAAY,cAAc,OAAO,CAAC,EAAE;QAC1C,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,IAAI,WAAW,MAAM,KAAK,GAAG;YAC3B,OAAO;gBAAE,SAAS;gBAAM,UAAU,CAAC;YAAE;QACvC;QAEA,0CAA0C;QAC1C,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,YAAY,EAAE,GAAG,MAAM,SAClD,IAAI,CAAC,YACL,MAAM,CAAC,cACP,EAAE,CAAC,MAAM,WACT,WAAW;QAEd,IAAI,gBAAgB,CAAC,SAAS;YAC5B,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoB;QACtD;QAEA,mBAAmB;QACnB,MAAM,EAAE,MAAM,QAAQ,EAAE,OAAO,aAAa,EAAE,GAAG,MAAM,SACpD,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM;QAEZ,IAAI,iBAAiB,CAAC,UAAU;YAC9B,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA2B;QAC7D;QAEA,8CAA8C;QAC9C,MAAM,EAAE,MAAM,cAAc,EAAE,GAAG,MAAM,SACpC,IAAI,CAAC,YACL,MAAM,CAAC,yFACP,EAAE,CAAC,wBAAwB;QAE9B,MAAM,EAAE,MAAM,gBAAgB,EAAE,GAAG,MAAM,SACtC,IAAI,CAAC,YACL,MAAM,CAAC,yFACP,GAAG,CAAC,yBAAyB,MAAM;QAEtC,2CAA2C;QAC3C,MAAM,gBAAgB,CAAC;YACrB,IAAI,CAAC,IAAI,OAAO;YAChB,OAAO,OAAO,IAAI,WAAW,GAAG,IAAI;QACtC;QACA,MAAM,sBAAsB,cAAc;QAE1C,MAAM,gBAAgB,CAAC,oBAAoB,EAAE,EAAE,MAAM,CAAC,CAAC;YACrD,IAAI,CAAC,EAAE,qBAAqB,IAAI,CAAC,MAAM,OAAO,CAAC,EAAE,qBAAqB,GAAG;gBACvE,OAAO;YACT;YACA,IAAI,EAAE,qBAAqB,CAAC,MAAM,KAAK,GAAG;gBACxC,OAAO;YACT;YACA,OAAO,EAAE,qBAAqB,CAAC,IAAI,CAAC,CAAC,KAAe,cAAc,QAAQ;QAC5E;QAEA,gCAAgC;QAChC,MAAM,iBAAiB,IAAI;QAC3B,CAAC,kBAAkB,EAAE,EAAE,OAAO,CAAC,CAAC;YAC9B,IAAI,EAAE,EAAE,EAAE;gBACR,eAAe,GAAG,CAAC,EAAE,EAAE,EAAE;YAC3B;QACF;QACA,cAAc,OAAO,CAAC,CAAC;YACrB,IAAI,EAAE,EAAE,IAAI,CAAC,eAAe,GAAG,CAAC,EAAE,EAAE,GAAG;gBACrC,eAAe,GAAG,CAAC,EAAE,EAAE,EAAE;YAC3B;QACF;QAEA,MAAM,kBAAkB,MAAM,IAAI,CAAC,eAAe,MAAM;QAExD,6BAA6B;QAC7B,MAAM,eAAe,IAAA,oKAAsB,EAAC,QAAQ,UAAU;QAC9D,MAAM,aAAa,IAAA,iKAAmB,EAAC;QACvC,MAAM,qBAAqB,IAAA,mKAAqB,EAAC,cAAc;QAE/D,sCAAsC;QACtC,MAAM,iBAAqG,CAAC;QAE5G,KAAK,MAAM,WAAW,SAAU;YAC9B,MAAM,eAAe,IAAA,sKAAwB,EAC3C;gBACE,cAAc,QAAQ,YAAY,IAAI;gBACtC,cAAc,OAAO,QAAQ,YAAY,KAAK;gBAC9C,aAAa,OAAO,QAAQ,WAAW,KAAK;gBAC5C,wBAAwB,OAAO,QAAQ,sBAAsB,KAAK;gBAClE,2BAA2B,OAAO,QAAQ,yBAAyB,KAAK;gBACxE,uBAAuB,QAAQ,qBAAqB;gBACpD,sBAAsB,QAAQ,oBAAoB;YACpD,GACA,WACA,oBACA,QAAQ,qBAAqB;YAG/B,MAAM,YAAY,IAAA,oKAAsB,EACtC,OAAO,QAAQ,UAAU,KAAK,GAC9B,QAAQ,qBAAqB,EAC7B,QAAQ,oBAAoB;YAG9B,cAAc,CAAC,QAAQ,EAAE,CAAC,GAAG;gBAC3B;gBACA;gBACA,eAAe,eAAe;YAChC;QACF;QAEA,OAAO;YAAE,SAAS;YAAM,UAAU;QAAe;IACnD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wCAAwC;QACtD,OAAO;YACL,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF;AAKO,eAAe;IAgBpB,IAAI;QACF,kCAAkC;QAClC,MAAM,gBAAgB,MAAM;QAC5B,IAAI,CAAC,cAAc,OAAO,IAAI,CAAC,cAAc,OAAO,EAAE;YACpD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAiD;QACnF;QAEA,MAAM,YAAY,cAAc,OAAO,CAAC,EAAE;QAC1C,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,+DAA+D;QAC/D,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,YAAY,EAAE,GAAG,MAAM,SAClD,IAAI,CAAC,YACL,MAAM,CAAC,+FACP,EAAE,CAAC,MAAM,WACT,WAAW;QAEd,IAAI,gBAAgB,CAAC,SAAS;YAC5B,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoB;QACtD;QAEA,4CAA4C;QAC5C,yGAAyG;QACzG,MAAM,EAAE,MAAM,cAAc,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SACxD,IAAI,CAAC,YACL,MAAM,CAAC,6NACP,EAAE,CAAC,wBAAwB;QAE9B,+FAA+F;QAC/F,MAAM,EAAE,MAAM,gBAAgB,EAAE,OAAO,UAAU,EAAE,GAAG,MAAM,SACzD,IAAI,CAAC,YACL,MAAM,CAAC,6NACP,GAAG,CAAC,yBAAyB,MAAM;QAEtC,IAAI,eAAe,YAAY;YAC7B,QAAQ,KAAK,CAAC,sCAAsC,eAAe;YACnE,OAAO;gBAAE,SAAS;gBAAO,OAAO,CAAC,eAAe,UAAU,GAAG,WAAW;YAA2B;QACrG;QAEA,gBAAgB;QAChB,QAAQ,GAAG,CAAC,uCAAuC;YACjD;YACA,qBAAqB,gBAAgB,UAAU;YAC/C,uBAAuB,kBAAkB,UAAU;QACrD;QAEA,4EAA4E;QAC5E,8EAA8E;QAC9E,MAAM,gBAAgB,CAAC;YACrB,IAAI,CAAC,IAAI,OAAO;YAChB,OAAO,OAAO,IAAI,WAAW,GAAG,IAAI;QACtC;QACA,MAAM,sBAAsB,cAAc;QAE1C,MAAM,gBAAgB,CAAC,oBAAoB,EAAE,EAAE,MAAM,CAAC,CAAC;YACrD,IAAI,CAAC,QAAQ,qBAAqB,IAAI,CAAC,MAAM,OAAO,CAAC,QAAQ,qBAAqB,GAAG;gBACnF,OAAO;YACT;YACA,0BAA0B;YAC1B,IAAI,QAAQ,qBAAqB,CAAC,MAAM,KAAK,GAAG;gBAC9C,OAAO;YACT;YACA,wEAAwE;YACxE,OAAO,QAAQ,qBAAqB,CAAC,IAAI,CAAC,CAAC,KAAe,cAAc,QAAQ;QAClF;QAEA,sCAAsC;QACtC,MAAM,iBAAiB,IAAI;QAC3B,CAAC,kBAAkB,EAAE,EAAE,OAAO,CAAC,CAAC;YAC9B,IAAI,QAAQ,EAAE,EAAE;gBACd,eAAe,GAAG,CAAC,QAAQ,EAAE,EAAE;YACjC;QACF;QACA,cAAc,OAAO,CAAC,CAAC;YACrB,IAAI,QAAQ,EAAE,IAAI,CAAC,eAAe,GAAG,CAAC,QAAQ,EAAE,GAAG;gBACjD,eAAe,GAAG,CAAC,QAAQ,EAAE,EAAE;YACjC;QACF;QAEA,MAAM,cAAc,MAAM,IAAI,CAAC,eAAe,MAAM;QAEpD,MAAM,QAAQ,IAAI,OAAO,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;QACpD,MAAM,MAAM,IAAI;QAChB,MAAM,kBAAkB,IAAI,KAAK,IAAI,WAAW,IAAI,IAAI,QAAQ,IAAI,GAAG,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;QAClG,MAAM,oBAAoB,YAAY,MAAM,CAAC,CAAA,IAAK,EAAE,MAAM,KAAK;QAC/D,MAAM,mBAAmB,YAAY,MAAM,CAAC,CAAA,IAC1C;gBAAC;gBAAW;gBAAa;gBAAa;aAAU,CAAC,QAAQ,CAAC,EAAE,MAAM,KAClE,EAAE,YAAY,IAAI;QAEpB,MAAM,gBAAgB,YAAY,MAAM,CAAC,CAAA,IAAK,EAAE,YAAY,KAAK;QACjE,MAAM,eAAe,YAAY,MAAM,CAAC,CAAA,IAAK,EAAE,cAAc,KAAK;QAClE,MAAM,sBAAsB,YAAY,MAAM,CAAC,CAAA,IAC7C,EAAE,MAAM,KAAK,eACb,EAAE,cAAc,KAAK,UACrB,EAAE,YAAY,IAAI;QAEpB,MAAM,wBAAwB,YAAY,MAAM,CAAC,CAAA,IAC/C,EAAE,MAAM,KAAK,eACb,EAAE,cAAc,KAAK;QAGvB,yEAAyE;QACzE,MAAM,eAAe,IAAA,oKAAsB,EAAC,QAAQ,UAAU;QAC9D,MAAM,aAAa,IAAA,iKAAmB,EAAC;QACvC,MAAM,qBAAqB,IAAA,mKAAqB,EAAC,cAAc;QAE/D,0CAA0C;QAC1C,4FAA4F;QAC5F,mFAAmF;QACnF,MAAM,gBAAgB,sBAAsB,MAAM,CAAC,CAAC,KAAK;YACvD,MAAM,WAAW,IAAA,+KAAiC,EAChD;gBACE,cAAc,QAAQ,YAAY,IAAI;gBACtC,cAAc,OAAO,QAAQ,YAAY,KAAK;gBAC9C,aAAa,OAAO,QAAQ,WAAW,KAAK;gBAC5C,wBAAwB,OAAO,QAAQ,sBAAsB,KAAK;gBAClE,2BAA2B,OAAO,QAAQ,yBAAyB,KAAK;gBACxE,YAAY,OAAO,QAAQ,UAAU,KAAK;gBAC1C,uBAAuB,QAAQ,qBAAqB;gBACpD,sBAAsB,QAAQ,oBAAoB;YACpD,GACA,WACA;YAEF,OAAO,MAAM;QACf,GAAG;QAEH,MAAM,kBAAkB,oBAAoB,MAAM,CAAC,CAAC,KAAK;YACvD,MAAM,WAAW,IAAA,+KAAiC,EAChD;gBACE,cAAc,QAAQ,YAAY,IAAI;gBACtC,cAAc,OAAO,QAAQ,YAAY,KAAK;gBAC9C,aAAa,OAAO,QAAQ,WAAW,KAAK;gBAC5C,wBAAwB,OAAO,QAAQ,sBAAsB,KAAK;gBAClE,2BAA2B,OAAO,QAAQ,yBAAyB,KAAK;gBACxE,YAAY,OAAO,QAAQ,UAAU,KAAK;gBAC1C,uBAAuB,QAAQ,qBAAqB;gBACpD,sBAAsB,QAAQ,oBAAoB;YACpD,GACA,WACA;YAEF,OAAO,MAAM;QACf,GAAG;QAEH,MAAM,iBAAiB,QAAQ,cAAc,GACzC,CAAC,QAAQ,kBAAkB,IAAI,CAAC,IAAI,QAAQ,cAAc,GAAG,MAC7D;QAEJ,MAAM,aAAa,QAAQ,kBAAkB,GACzC,CAAC,QAAQ,gBAAgB,IAAI,CAAC,IAAI,QAAQ,kBAAkB,GAAG,MAC/D;QAEJ,OAAO;YACL,SAAS;YACT,OAAO;gBACL,eAAe,YAAY,MAAM;gBACjC,mBAAmB,kBAAkB,MAAM;gBAC3C,kBAAkB,iBAAiB,MAAM;gBACzC,eAAe,cAAc,MAAM;gBACnC;gBACA;gBACA,eAAe,OAAO,QAAQ,MAAM,KAAK;gBACzC,kBAAkB,OAAO,QAAQ,iBAAiB,KAAK;gBACvD;gBACA;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;YACL,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF;AAKO,eAAe,0BACpB,SAAiB,EACjB,OASC;IAMD,IAAI;QACF,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,MAAM,aAAkB;YACtB,YAAY,IAAI,OAAO,WAAW;QACpC;QAEA,IAAI,QAAQ,WAAW,KAAK,WAAW;YACrC,WAAW,YAAY,GAAG,QAAQ,WAAW;QAC/C;QACA,IAAI,QAAQ,eAAe,KAAK,WAAW;YACzC,WAAW,gBAAgB,GAAG,QAAQ,eAAe;QACvD;QACA,IAAI,QAAQ,gBAAgB,KAAK,WAAW;YAC1C,WAAW,iBAAiB,GAAG,QAAQ,gBAAgB;QACzD;QACA,IAAI,QAAQ,kBAAkB,KAAK,WAAW;YAC5C,WAAW,mBAAmB,GAAG,QAAQ,kBAAkB;QAC7D;QACA,IAAI,QAAQ,iBAAiB,KAAK,WAAW;YAC3C,WAAW,kBAAkB,GAAG,QAAQ,iBAAiB;QAC3D;QACA,IAAI,QAAQ,eAAe,KAAK,WAAW;YACzC,WAAW,gBAAgB,GAAG,QAAQ,eAAe;QACvD;QACA,IAAI,QAAQ,iBAAiB,KAAK,WAAW;YAC3C,WAAW,kBAAkB,GAAG,QAAQ,iBAAiB;QAC3D;QACA,IAAI,QAAQ,eAAe,KAAK,WAAW;YACzC,WAAW,gBAAgB,GAAG,QAAQ,eAAe;QACvD;QAEA,MAAM,EAAE,MAAM,cAAc,EAAE,KAAK,EAAE,GAAG,MAAM,SAC3C,IAAI,CAAC,YACL,MAAM,CAAC,YACP,EAAE,CAAC,MAAM,WACT,MAAM,GACN,MAAM;QAET,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,wCAAwC;YACtD,OAAO;gBAAE,SAAS;gBAAO,OAAO,MAAM,OAAO;YAAC;QAChD;QAEA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA0B;IAC7D,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uCAAuC;QACrD,OAAO;YACL,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF;;;IA1kCsB;IA0CA;IAsEA;IAqDA;IA8IA;IAwIA;IAwEA;IAqGA;IAoFA;IAqIA;IAoMA;;AArgCA,+OAAA;AA0CA,+OAAA;AAsEA,+OAAA;AAqDA,+OAAA;AA8IA,+OAAA;AAwIA,+OAAA;AAwEA,+OAAA;AAqGA,+OAAA;AAoFA,+OAAA;AAqIA,+OAAA;AAoMA,+OAAA"}},
    {"offset": {"line": 1164, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/%28dashboard%29/layout.tsx"],"sourcesContent":["import { redirect } from 'next/navigation';\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { CleanerLayoutClient } from './layout-client';\r\nimport { getCurrentCleaner } from '../actions';\r\n\r\nexport default async function CleanerDashboardLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode;\r\n}) {\r\n  try {\r\n    // Server-side authentication check\r\n    const supabase = await createClient();\r\n\r\n    const {\r\n      data: { user },\r\n      error,\r\n    } = await supabase.auth.getUser();\r\n\r\n    if (error) {\r\n      console.error('Error getting user in cleaner layout:', error.message);\r\n      redirect('/cleaner/login?redirect=/cleaner');\r\n    }\r\n\r\n    if (!user) {\r\n      redirect('/cleaner/login?redirect=/cleaner');\r\n    }\r\n\r\n    // Verify user is a cleaner\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      // User is authenticated but not a cleaner - redirect to login\r\n      redirect('/cleaner/login?redirect=/cleaner');\r\n    }\r\n\r\n    return <CleanerLayoutClient>{children}</CleanerLayoutClient>;\r\n  } catch (error) {\r\n    // Handle errors from createClient or other operations\r\n    console.error('Error in cleaner layout:', error);\r\n    redirect('/cleaner/login?redirect=/cleaner');\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;AAAA;AAAA;AACA;AACA;AACA;;;;;;AAEe,eAAe,uBAAuB,EACnD,QAAQ,EAGT;IACC,IAAI;QACF,mCAAmC;QACnC,MAAM,WAAW,MAAM,IAAA,gJAAY;QAEnC,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACd,KAAK,EACN,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAE/B,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,yCAAyC,MAAM,OAAO;YACpE,IAAA,iMAAQ,EAAC;QACX;QAEA,IAAI,CAAC,MAAM;YACT,IAAA,iMAAQ,EAAC;QACX;QAEA,2BAA2B;QAC3B,MAAM,gBAAgB,MAAM,IAAA,8IAAiB;QAC7C,IAAI,CAAC,cAAc,OAAO,IAAI,CAAC,cAAc,OAAO,EAAE;YACpD,8DAA8D;YAC9D,IAAA,iMAAQ,EAAC;QACX;QAEA,qBAAO,8OAAC,2KAAmB;sBAAE;;;;;;IAC/B,EAAE,OAAO,OAAO;QACd,sDAAsD;QACtD,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,IAAA,iMAAQ,EAAC;IACX;AACF"}}]
}