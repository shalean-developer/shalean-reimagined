{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst buttonVariants = cva(\r\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-lg text-sm font-semibold ring-offset-background transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90 shadow-button hover:shadow-lg hover:-translate-y-0.5\",\r\n        destructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\r\n        outline: \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\r\n        secondary: \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\r\n        link: \"text-primary underline-offset-4 hover:underline\",\r\n        hero: \"bg-primary text-primary-foreground shadow-button hover:shadow-lg hover:-translate-y-0.5 hover:bg-primary/90\",\r\n        heroOutline: \"border-2 border-primary bg-transparent text-primary hover:bg-primary hover:text-primary-foreground\",\r\n        cta: \"bg-primary text-primary-foreground shadow-button hover:shadow-lg hover:-translate-y-1 hover:bg-primary/90\",\r\n      },\r\n      size: {\r\n        default: \"h-10 px-4 py-2\",\r\n        sm: \"h-9 rounded-md px-3\",\r\n        lg: \"h-12 rounded-lg px-6\",\r\n        xl: \"h-14 rounded-xl px-8 text-base\",\r\n        icon: \"h-10 w-10\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n      size: \"default\",\r\n    },\r\n  },\r\n);\r\n\r\nexport interface ButtonProps\r\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\r\n    VariantProps<typeof buttonVariants> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\r\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\r\n    const Comp = asChild ? Slot : \"button\";\r\n    return <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />;\r\n  },\r\n);\r\nButton.displayName = \"Button\";\r\n\r\nexport { Button, buttonVariants };\r\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,iBAAiB,IAAA,0KAAG,EACxB,wWACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aAAa;YACb,SAAS;YACT,WAAW;YACX,OAAO;YACP,MAAM;YACN,MAAM;YACN,aAAa;YACb,KAAK;QACP;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,MAAM;QACR;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AASF,MAAM,uBAAS,2KAAgB,MAC7B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,KAAK,EAAE,GAAG,OAAO,EAAE;IACxD,MAAM,OAAO,UAAU,2KAAI,GAAG;IAC9B,qBAAO,6LAAC;QAAK,WAAW,IAAA,4HAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QAAK,KAAK;QAAM,GAAG,KAAK;;;;;;AAC/F;;AAEF,OAAO,WAAW,GAAG"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/label.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as LabelPrimitive from \"@radix-ui/react-label\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst labelVariants = cva(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\");\r\n\r\nconst Label = React.forwardRef<\r\n  React.ElementRef<typeof LabelPrimitive.Root>,\r\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>\r\n>(({ className, ...props }, ref) => (\r\n  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />\r\n));\r\nLabel.displayName = LabelPrimitive.Root.displayName;\r\n\r\nexport { Label };\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,gBAAgB,IAAA,0KAAG,EAAC;AAE1B,MAAM,sBAAQ,2KAAgB,MAG5B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,4KAAmB;QAAC,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,iBAAiB;QAAa,GAAG,KAAK;;;;;;;AAErF,MAAM,WAAW,GAAG,4KAAmB,CAAC,WAAW"}},
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\r\n  ({ className, type, ...props }, ref) => {\r\n    return (\r\n      <input\r\n        type={type}\r\n        className={cn(\r\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\r\n          className,\r\n        )}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    );\r\n  },\r\n);\r\nInput.displayName = \"Input\";\r\n\r\nexport { Input };\r\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,2KAAgB,MAC5B,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAO,EAAE;IAC9B,qBACE,6LAAC;QACC,MAAM;QACN,WAAW,IAAA,4HAAE,EACX,kYACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,MAAM,WAAW,GAAG"}},
    {"offset": {"line": 147, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/book/components/Step3ContactReview.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useState } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Button } from '@/components/ui/button';\r\nimport { User, Mail, Phone, MapPin, Calendar, Clock, Pencil, Lock, Home, Users, Package, Sparkles } from 'lucide-react';\r\nimport { BookingFormData, PriceBreakdown } from '@/types/booking';\r\nimport { format } from 'date-fns';\r\nimport { getServices, getAdditionalServices } from '../../quote/actions';\r\nimport { AdditionalService } from '@/types/quote';\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { calculateBookingDatesForMonth } from '@/lib/utils/recurring-dates';\r\nimport { supportsRecurringBookings } from '@/lib/utils/service-validation';\r\n\r\ninterface Step3ContactReviewProps {\r\n  formData: BookingFormData;\r\n  priceBreakdown: PriceBreakdown;\r\n  updateFormData: (updates: Partial<BookingFormData>) => void;\r\n  onValidateDiscountCode: (code: string) => Promise<void>;\r\n  onProceedToPayment: () => void;\r\n  isProcessing?: boolean;\r\n}\r\n\r\nexport function Step3ContactReview({\r\n  formData,\r\n  priceBreakdown,\r\n  updateFormData,\r\n  onValidateDiscountCode,\r\n  onProceedToPayment,\r\n  isProcessing = false,\r\n}: Step3ContactReviewProps) {\r\n  const [discountCodeInput, setDiscountCodeInput] = useState(formData.discountCode || '');\r\n  const [isValidatingDiscount, setIsValidatingDiscount] = useState(false);\r\n  \r\n  // Fetch services and additional services\r\n  const { data: services = [] } = useQuery({\r\n    queryKey: ['services'],\r\n    queryFn: getServices,\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  const { data: additionalServices = [] } = useQuery({\r\n    queryKey: ['additional-services', formData.serviceId],\r\n    queryFn: () => getAdditionalServices(formData.serviceId || undefined),\r\n    enabled: !!formData.serviceId,\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Get selected service name\r\n  const selectedService = services.find((s) => s.id === formData.serviceId);\r\n  const serviceName = selectedService?.name || 'Standard Cleaning';\r\n  \r\n  // Check if selected service is carpet cleaning\r\n  const isCarpetCleaning = serviceName?.toLowerCase().includes('carpet') ?? false;\r\n\r\n  // Get selected additional services\r\n  const selectedAdditionalServices = formData.additionalServices\r\n    .map((id) => additionalServices.find((s) => s.id === id))\r\n    .filter((s): s is AdditionalService => s !== undefined);\r\n\r\n  // Fetch selected cleaners\r\n  const { data: cleaners = [] } = useQuery({\r\n    queryKey: ['cleaners', JSON.stringify(formData.preferredCleanerIds)],\r\n    queryFn: async () => {\r\n      if (!formData.preferredCleanerIds || formData.preferredCleanerIds.length === 0) {\r\n        return [];\r\n      }\r\n      // Create client inside query function to avoid hydration issues\r\n      const supabase = createClient();\r\n      // Fetch cleaner details by IDs\r\n      const { data } = await supabase\r\n        .from('cleaners')\r\n        .select('id, name, avatar_url, photo_url')\r\n        .in('id', formData.preferredCleanerIds);\r\n      return data || [];\r\n    },\r\n    enabled: formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0,\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Calculate final subtotal (after all discounts, before service fee)\r\n  const finalSubtotal = priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount - priceBreakdown.discountAmount;\r\n\r\n  // Check if service supports recurring bookings\r\n  const supportsRecurring = supportsRecurringBookings(serviceName);\r\n\r\n  // Calculate recurring total for the first month\r\n  const isRecurring = formData.cleaningFrequency !== 'one-time';\r\n  const hasServiceDate = Boolean(formData.serviceDate);\r\n  const shouldCalculateRecurringTotal = isRecurring && hasServiceDate && supportsRecurring;\r\n\r\n  // Tip is one-time only (applied to first booking only, not recurring)\r\n  const tipAmount = formData.tipAmount || 0;\r\n\r\n  let numberOfBookingsInMonth = 1;\r\n  let recurringTotal = priceBreakdown.totalAmount + tipAmount; // Single booking: base + tip\r\n\r\n  if (shouldCalculateRecurringTotal) {\r\n    try {\r\n      const startDate = new Date(formData.serviceDate);\r\n      const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n      numberOfBookingsInMonth = bookingDates.length;\r\n      // For recurring: multiply base total by number of bookings, then add tip once\r\n      recurringTotal = (priceBreakdown.totalAmount * numberOfBookingsInMonth) + tipAmount;\r\n    } catch (error) {\r\n      // If date parsing fails, fall back to single booking\r\n      console.error('Error calculating recurring total:', error);\r\n      numberOfBookingsInMonth = 1;\r\n      recurringTotal = priceBreakdown.totalAmount + tipAmount;\r\n    }\r\n  }\r\n\r\n  // Get frequency label for display\r\n  const getFrequencyLabel = () => {\r\n    switch (formData.cleaningFrequency) {\r\n      case 'weekly':\r\n        return 'Weekly';\r\n      case 'bi-weekly':\r\n        return 'Bi-Weekly';\r\n      case 'monthly':\r\n        return 'Monthly';\r\n      default:\r\n        return '';\r\n    }\r\n  };\r\n\r\n  const handleApplyDiscount = async () => {\r\n    setIsValidatingDiscount(true);\r\n    await onValidateDiscountCode(discountCodeInput);\r\n    setIsValidatingDiscount(false);\r\n  };\r\n\r\n  const tipOptions = [0, 25, 50, 75, 100];\r\n\r\n  // Format cleaning frequency\r\n  const formatFrequency = (freq: string) => {\r\n    const freqMap: Record<string, string> = {\r\n      'one-time': 'One-time',\r\n      'weekly': 'Weekly',\r\n      'bi-weekly': 'Bi-weekly',\r\n      'monthly': 'Monthly',\r\n    };\r\n    return freqMap[freq] || freq;\r\n  };\r\n\r\n  return (\r\n    <div className=\"space-y-4\">\r\n      <div>\r\n        <h2 className=\"text-2xl font-bold text-foreground mb-1\">Review Your Booking</h2>\r\n        <p className=\"text-sm text-muted-foreground\">Please review your booking details before confirming.</p>\r\n      </div>\r\n\r\n      {/* Cleaner */}\r\n      <div className=\"bg-white rounded-xl p-4 border border-border\">\r\n        <div className=\"flex items-center justify-between mb-3\">\r\n          <h3 className=\"text-lg font-semibold\">Cleaner</h3>\r\n          <button type=\"button\" className=\"text-primary\">\r\n            <Pencil className=\"w-4 h-4\" />\r\n          </button>\r\n        </div>\r\n        <div className=\"bg-primary text-primary-foreground rounded-lg p-3 mb-3\">\r\n          <p className=\"text-xs mb-1\">An upfront tip for</p>\r\n          {cleaners.length > 0 ? (\r\n            <div className=\"space-y-1\">\r\n              {cleaners.map((cleaner) => (\r\n                <p key={cleaner.id} className=\"font-bold text-base\">\r\n                  {cleaner.name}\r\n                </p>\r\n              ))}\r\n            </div>\r\n          ) : (\r\n            <p className=\"font-bold text-base\">No preference - Best available</p>\r\n          )}\r\n        </div>\r\n        <div>\r\n          <Label className=\"mb-2 block text-sm\">\r\n            Tip amount\r\n            {isRecurring && shouldCalculateRecurringTotal && (\r\n              <span className=\"text-xs text-muted-foreground font-normal ml-1\">(one-time, first booking only)</span>\r\n            )}\r\n          </Label>\r\n          <div className=\"flex gap-2 flex-wrap items-center\">\r\n            {tipOptions.map((amount) => (\r\n              <button\r\n                key={amount}\r\n                type=\"button\"\r\n                onClick={() => updateFormData({ tipAmount: amount })}\r\n                className={`px-3 py-1.5 rounded-full border-2 transition-all text-sm ${\r\n                  formData.tipAmount === amount\r\n                    ? 'border-primary bg-primary text-primary-foreground'\r\n                    : 'border-border hover:border-primary/50'\r\n                }`}\r\n              >\r\n                R{amount}\r\n              </button>\r\n            ))}\r\n            <Input\r\n              type=\"number\"\r\n              value={formData.tipAmount || ''}\r\n              onChange={(e) => updateFormData({ tipAmount: parseFloat(e.target.value) || 0 })}\r\n              placeholder=\"Custom\"\r\n              className=\"w-24 h-8 text-sm\"\r\n            />\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Contact Information */}\r\n      <div className=\"bg-white rounded-xl p-4 border border-border\">\r\n        <div className=\"flex items-center justify-between mb-3\">\r\n          <h3 className=\"text-lg font-semibold\">Contact & Address</h3>\r\n          <button type=\"button\" className=\"text-primary\">\r\n            <Pencil className=\"w-4 h-4\" />\r\n          </button>\r\n        </div>\r\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\r\n          <div className=\"space-y-2\">\r\n            <Label>First Name *</Label>\r\n            <div className=\"relative\">\r\n              <User className=\"absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground\" />\r\n              <Input\r\n                placeholder=\"e.g., Thabo\"\r\n                className=\"pl-10\"\r\n                value={formData.customerFirstName}\r\n                onChange={(e) => updateFormData({ customerFirstName: e.target.value })}\r\n              />\r\n            </div>\r\n          </div>\r\n          <div className=\"space-y-2\">\r\n            <Label>Last Name *</Label>\r\n            <div className=\"relative\">\r\n              <User className=\"absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground\" />\r\n              <Input\r\n                placeholder=\"e.g., Mokoena\"\r\n                className=\"pl-10\"\r\n                value={formData.customerLastName}\r\n                onChange={(e) => updateFormData({ customerLastName: e.target.value })}\r\n              />\r\n            </div>\r\n          </div>\r\n          <div className=\"space-y-2\">\r\n            <Label>Email Address *</Label>\r\n            <div className=\"relative\">\r\n              <Mail className=\"absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground\" />\r\n              <Input\r\n                type=\"email\"\r\n                placeholder=\"e.g., thabo@example.com\"\r\n                className=\"pl-10\"\r\n                value={formData.customerEmail}\r\n                onChange={(e) => updateFormData({ customerEmail: e.target.value })}\r\n              />\r\n            </div>\r\n          </div>\r\n          <div className=\"space-y-2\">\r\n            <Label>Phone Number *</Label>\r\n            <div className=\"relative\">\r\n              <Phone className=\"absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground\" />\r\n              <Input\r\n                placeholder=\"0821234567 or +27821234567\"\r\n                className=\"pl-10\"\r\n                value={formData.customerPhone}\r\n                onChange={(e) => updateFormData({ customerPhone: e.target.value })}\r\n              />\r\n            </div>\r\n          </div>\r\n          <div className=\"space-y-2 md:col-span-2\">\r\n            <Label>Address *</Label>\r\n            <div className=\"relative\">\r\n              <MapPin className=\"absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground\" />\r\n              <Input\r\n                placeholder=\"Street address, Suburb, City\"\r\n                className=\"pl-10\"\r\n                value={[\r\n                  formData.serviceAddress,\r\n                  formData.serviceAptUnit,\r\n                  formData.serviceSuburb,\r\n                  formData.serviceCity\r\n                ].filter(Boolean).join(', ')}\r\n                onChange={(e) => {\r\n                  const address = e.target.value;\r\n                  // Store the full address in serviceAddress for now\r\n                  // Can be parsed into separate fields if needed\r\n                  updateFormData({ serviceAddress: address });\r\n                }}\r\n              />\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Booking Review Sections */}\r\n      <div className=\"space-y-3\">\r\n        {/* Consolidated Review Details */}\r\n        <div className=\"bg-white rounded-xl p-4 border border-border\">\r\n          <div className=\"flex items-center justify-between mb-4\">\r\n            <h3 className=\"text-lg font-semibold\">What You're Booking</h3>\r\n            <button type=\"button\" className=\"text-primary\">\r\n              <Pencil className=\"w-4 h-4\" />\r\n            </button>\r\n          </div>\r\n          \r\n          <div className=\"space-y-4\">\r\n            {/* Service Type */}\r\n            <div className=\"pb-3 border-b border-border\">\r\n              <div className=\"flex items-center gap-2 mb-2\">\r\n                <Sparkles className=\"w-4 h-4 text-primary\" />\r\n                <span className=\"text-sm font-medium text-muted-foreground\">Service</span>\r\n              </div>\r\n              <p className=\"text-base font-semibold text-foreground\">{serviceName}</p>\r\n              {formData.cleaningFrequency && formData.cleaningFrequency !== 'one-time' && (\r\n                <p className=\"text-xs text-muted-foreground mt-1\">\r\n                  Frequency: {formatFrequency(formData.cleaningFrequency)}\r\n                </p>\r\n              )}\r\n            </div>\r\n\r\n            {/* Property Details - Conditional based on service type */}\r\n            {isCarpetCleaning ? (\r\n              // Show carpet-specific fields\r\n              (formData.carpetTypes.length > 0 || formData.numberOfFittedRooms || formData.numberOfLooseCarpets || formData.roomStatus) && (\r\n                <div className=\"pb-3 border-b border-border\">\r\n                  <div className=\"flex items-center gap-2 mb-2\">\r\n                    <Home className=\"w-4 h-4 text-primary\" />\r\n                    <span className=\"text-sm font-medium text-muted-foreground\">Carpet Details</span>\r\n                  </div>\r\n                  <div className=\"space-y-2 text-sm\">\r\n                    {formData.carpetTypes.length > 0 && (\r\n                      <div>\r\n                        <span className=\"text-muted-foreground\">Carpet Types: </span>\r\n                        <span className=\"font-medium capitalize\">{formData.carpetTypes.join(', ')}</span>\r\n                      </div>\r\n                    )}\r\n                    {formData.numberOfFittedRooms && (\r\n                      <div>\r\n                        <span className=\"text-muted-foreground\">Fitted Rooms: </span>\r\n                        <span className=\"font-medium\">{formData.numberOfFittedRooms}</span>\r\n                      </div>\r\n                    )}\r\n                    {formData.numberOfLooseCarpets && (\r\n                      <div>\r\n                        <span className=\"text-muted-foreground\">Loose Carpets/Rugs: </span>\r\n                        <span className=\"font-medium\">{formData.numberOfLooseCarpets}</span>\r\n                      </div>\r\n                    )}\r\n                    {formData.roomStatus && (\r\n                      <div>\r\n                        <span className=\"text-muted-foreground\">Room Status: </span>\r\n                        <span className=\"font-medium capitalize\">{formData.roomStatus.replace(/-/g, ' ')}</span>\r\n                      </div>\r\n                    )}\r\n                  </div>\r\n                </div>\r\n              )\r\n            ) : (\r\n              // Show bedrooms/bathrooms for non-carpet services\r\n              (parseInt(formData.bedrooms) > 0 || parseInt(formData.bathrooms) > 0) && (\r\n                <div className=\"pb-3 border-b border-border\">\r\n                  <div className=\"flex items-center gap-2 mb-2\">\r\n                    <Home className=\"w-4 h-4 text-primary\" />\r\n                    <span className=\"text-sm font-medium text-muted-foreground\">Property Details</span>\r\n                  </div>\r\n                  <div className=\"grid grid-cols-2 gap-3 text-sm\">\r\n                    <div>\r\n                      <span className=\"text-muted-foreground\">Bedrooms: </span>\r\n                      <span className=\"font-medium\">{formData.bedrooms}</span>\r\n                    </div>\r\n                    <div>\r\n                      <span className=\"text-muted-foreground\">Bathrooms: </span>\r\n                      <span className=\"font-medium\">{formData.bathrooms}</span>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              )\r\n            )}\r\n\r\n            {/* Additional Services */}\r\n            {selectedAdditionalServices.length > 0 && (\r\n              <div className=\"pb-3 border-b border-border\">\r\n                <div className=\"flex items-center gap-2 mb-2\">\r\n                  <Sparkles className=\"w-4 h-4 text-primary\" />\r\n                  <span className=\"text-sm font-medium text-muted-foreground\">Additional Services</span>\r\n                </div>\r\n                <div className=\"flex flex-wrap gap-2\">\r\n                  {selectedAdditionalServices.map((service) => (\r\n                    <span\r\n                      key={service.id}\r\n                      className=\"inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium bg-primary/10 text-primary border border-primary/20\"\r\n                    >\r\n                      {service.name}\r\n                    </span>\r\n                  ))}\r\n                </div>\r\n              </div>\r\n            )}\r\n\r\n            {/* Service Options */}\r\n            {(formData.numberOfCleaners > 1 || formData.cleaningEquipment === 'yes' || formData.serviceDuration) && (\r\n              <div className=\"pb-3 border-b border-border space-y-2\">\r\n                <div className=\"flex items-center gap-2 mb-2\">\r\n                  <Package className=\"w-4 h-4 text-primary\" />\r\n                  <span className=\"text-sm font-medium text-muted-foreground\">Service Options</span>\r\n                </div>\r\n                {formData.numberOfCleaners > 1 && (\r\n                  <div className=\"flex items-center gap-2\">\r\n                    <Users className=\"w-4 h-4 text-primary\" />\r\n                    <span className=\"text-sm text-muted-foreground\">\r\n                      <span className=\"font-medium\">{formData.numberOfCleaners}</span> cleaner{formData.numberOfCleaners > 1 ? 's' : ''} assigned\r\n                      {formData.numberOfCleaners > 1 && (\r\n                        <span className=\"text-xs ml-1\">(+R{((formData.numberOfCleaners - 1) * 250).toFixed(2)})</span>\r\n                      )}\r\n                    </span>\r\n                  </div>\r\n                )}\r\n                {formData.cleaningEquipment === 'yes' && (\r\n                  <div className=\"flex items-center gap-2\">\r\n                    <Package className=\"w-4 h-4 text-primary\" />\r\n                    <span className=\"text-sm text-muted-foreground\">\r\n                      Equipment & supplies included\r\n                      {priceBreakdown.equipmentSupplyPrice > 0 && (\r\n                        <span className=\"text-xs ml-1\">(+R{priceBreakdown.equipmentSupplyPrice.toFixed(2)})</span>\r\n                      )}\r\n                    </span>\r\n                  </div>\r\n                )}\r\n                {formData.serviceDuration && (\r\n                  <div className=\"flex items-center gap-2\">\r\n                    <Clock className=\"w-4 h-4 text-primary\" />\r\n                    <span className=\"text-sm text-muted-foreground\">\r\n                      Estimated duration: <span className=\"font-medium\">{formData.serviceDuration} hours</span>\r\n                    </span>\r\n                  </div>\r\n                )}\r\n              </div>\r\n            )}\r\n\r\n            {/* Schedule */}\r\n            <div>\r\n              <div className=\"flex items-center gap-2 mb-3\">\r\n                <Calendar className=\"w-4 h-4 text-primary\" />\r\n                <span className=\"text-sm font-medium text-muted-foreground\">Schedule</span>\r\n              </div>\r\n              <div className=\"space-y-2 text-sm\">\r\n                <div className=\"flex items-center justify-between\">\r\n                  <span className=\"text-muted-foreground\">Date</span>\r\n                  <span className=\"font-medium\">\r\n                    {formData.serviceDate ? format(new Date(formData.serviceDate), 'EEE, MMM d, yyyy') : 'Not set'}\r\n                  </span>\r\n                </div>\r\n                <div className=\"flex items-center justify-between\">\r\n                  <span className=\"text-muted-foreground\">Time</span>\r\n                  <span className=\"font-medium\">{formData.serviceTime || 'Not set'}</span>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Total Amount & Payment */}\r\n      <div className=\"bg-primary/5 rounded-xl p-4 border border-primary/20\">\r\n        <div className=\"flex items-center justify-between mb-3\">\r\n          <div>\r\n            <h3 className=\"text-lg font-semibold\">\r\n              {shouldCalculateRecurringTotal \r\n                ? `Total Amount (${numberOfBookingsInMonth} ${numberOfBookingsInMonth === 1 ? 'booking' : 'bookings'} this month)`\r\n                : 'Total Amount'}\r\n            </h3>\r\n            <p className=\"text-xs text-muted-foreground\">\r\n              {shouldCalculateRecurringTotal \r\n                ? `${getFrequencyLabel()} recurring - All fees included`\r\n                : isRecurring && !hasServiceDate\r\n                ? 'Select a date to see monthly total'\r\n                : 'All fees included'}\r\n            </p>\r\n          </div>\r\n          <div className=\"text-right\">\r\n            <p className=\"text-2xl font-bold text-primary\">\r\n              R{shouldCalculateRecurringTotal ? recurringTotal.toFixed(2) : (priceBreakdown.totalAmount + tipAmount).toFixed(2)}\r\n            </p>\r\n          </div>\r\n        </div>\r\n        {shouldCalculateRecurringTotal && numberOfBookingsInMonth > 1 && (\r\n          <div className=\"mb-3 text-xs text-muted-foreground text-right\">\r\n            (R{priceBreakdown.totalAmount.toFixed(2)} Ã— {numberOfBookingsInMonth}) {tipAmount > 0 ? `+ R${tipAmount.toFixed(2)} tip` : ''} = R{recurringTotal.toFixed(2)}\r\n          </div>\r\n        )}\r\n\r\n        <div className=\"space-y-1.5 mb-3 pt-3 border-t border-border\">\r\n          <div className=\"flex justify-between text-sm\">\r\n            <span className=\"text-muted-foreground\">Service & rooms</span>\r\n            <span>R{Math.max(0, finalSubtotal).toFixed(2)}</span>\r\n          </div>\r\n          <div className=\"flex justify-between text-sm\">\r\n            <span className=\"text-muted-foreground\">Service fee</span>\r\n            <span>+R{priceBreakdown.serviceFee.toFixed(2)}</span>\r\n          </div>\r\n          {tipAmount > 0 && (\r\n            <div className=\"flex justify-between text-sm\">\r\n              <span className=\"text-muted-foreground\">\r\n                Tip{isRecurring && shouldCalculateRecurringTotal ? ' (one-time, first booking only)' : ''}\r\n              </span>\r\n              <span>+R{tipAmount.toFixed(2)}</span>\r\n            </div>\r\n          )}\r\n        </div>\r\n\r\n        {/* Discount Code */}\r\n        <div className=\"mb-3\">\r\n          <Label className=\"mb-1.5 block text-sm\">Have a discount code?</Label>\r\n          <div className=\"flex gap-2\">\r\n            <Input\r\n              placeholder=\"Enter discount code\"\r\n              value={discountCodeInput}\r\n              onChange={(e) => setDiscountCodeInput(e.target.value)}\r\n              className=\"h-9 text-sm\"\r\n            />\r\n            <Button\r\n              type=\"button\"\r\n              variant=\"outline\"\r\n              onClick={handleApplyDiscount}\r\n              disabled={isValidatingDiscount || !discountCodeInput}\r\n              className=\"h-9\"\r\n            >\r\n              Apply\r\n            </Button>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"flex items-center gap-2 text-xs text-muted-foreground mb-3\">\r\n          <Lock className=\"w-3.5 h-3.5\" />\r\n          <span>Secure payment powered by Paystack</span>\r\n        </div>\r\n\r\n        <Button\r\n          type=\"button\"\r\n          className=\"w-full\"\r\n          size=\"lg\"\r\n          onClick={onProceedToPayment}\r\n          disabled={isProcessing}\r\n        >\r\n          {isProcessing ? 'Processing...' : 'Confirm & Pay'}\r\n        </Button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1662, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/book/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { BookingFormData, BookingCreateInput, WorkingHour, TimeSlotAvailability, Cleaner, CleanerWithAvailability } from '@/types/booking';\r\nimport { calculatePrice } from '@/lib/pricing/calculator';\r\nimport { generateBookingNumber } from '@/lib/utils/booking-number';\r\nimport { initializePayment } from '@/lib/paystack/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { calculateReliabilityScore, calculateCompletionRate, calculateOnTimeRate } from '@/lib/utils/cleaner-utils';\r\nimport { calculateBookingDatesForMonth, calculateNextBookingDate, formatDateForDB } from '@/lib/utils/recurring-dates';\r\nimport { isValidFrequencyForService } from '@/lib/utils/service-validation';\r\n\r\n/**\r\n * Get available working hours (30-minute interval start times)\r\n */\r\nexport async function getWorkingHours(): Promise<WorkingHour[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('working_hours')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as WorkingHour[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get working hours from home_detail_options (backward compatibility)\r\n */\r\nexport async function getWorkingHoursFromOptions(): Promise<Array<{ value: string; label: string }>> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('value, label')\r\n      .eq('option_type', 'working_hours')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours from options:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []).map((item) => ({\r\n      value: item.value,\r\n      label: item.label,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours from options:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check cleaner availability for a specific date and time slot\r\n * Returns availability status and count of available cleaners\r\n */\r\nexport async function checkCleanerAvailabilityForSlot(\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<TimeSlotAvailability> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, check if any active cleaners exist in the system\r\n    const { data: activeCleaners, error: cleanersError } = await supabase\r\n      .from('cleaners')\r\n      .select('id')\r\n      .eq('is_active', true);\r\n\r\n    if (cleanersError) {\r\n      console.error('Error checking active cleaners:', cleanersError);\r\n      // If we can't check cleaners, assume unavailable for safety\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    // If no active cleaners exist, no slots are available\r\n    if (!activeCleaners || activeCleaners.length === 0) {\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    const totalCleaners = activeCleaners.length;\r\n\r\n    // Query bookings for the specified date that might overlap\r\n    // We need to check for bookings where:\r\n    // (booking_start_time < new_end_time) AND (booking_end_time > new_start_time)\r\n    // Only consider pending or confirmed bookings (exclude cancelled/completed)\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration, preferred_cleaner_id, preferred_cleaner_ids, number_of_cleaners')\r\n      .eq('service_date', serviceDate)\r\n      .in('status', ['pending', 'confirmed']);\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking bookings:', bookingsError);\r\n      // If we can't check bookings, assume available (optimistic approach)\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      // No bookings for this date, all cleaners are available\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Track which cleaners are booked (by ID)\r\n    const bookedCleanerIds = new Set<string>();\r\n    \r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n      \r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number' \r\n          ? booking.service_duration \r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        // There's an overlap\r\n        // Check preferred_cleaner_ids first (new multi-cleaner support)\r\n        if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n          // Multiple cleaners are assigned\r\n          booking.preferred_cleaner_ids.forEach((cleanerId: string) => {\r\n            if (cleanerId) bookedCleanerIds.add(cleanerId);\r\n          });\r\n        } else if (booking.preferred_cleaner_id) {\r\n          // Single cleaner assigned (backward compatibility)\r\n          bookedCleanerIds.add(booking.preferred_cleaner_id);\r\n        } else {\r\n          // If no preferred cleaner, use number_of_cleaners to count generic cleaner slots\r\n          // This handles bookings without specific cleaner assignments\r\n          const numCleaners = booking.number_of_cleaners || 1;\r\n          // We don't add specific IDs here, but count them in bookingsWithoutPreferredCleaner\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate available cleaners\r\n    // Count bookings without preferred cleaners (generic assignments)\r\n    // These use number_of_cleaners to determine how many cleaner slots are taken\r\n    const bookingsWithoutPreferredCleaner = bookings.filter(\r\n      (b) => {\r\n        const hasPreferredCleaners = (b.preferred_cleaner_ids && Array.isArray(b.preferred_cleaner_ids) && b.preferred_cleaner_ids.length > 0) || b.preferred_cleaner_id;\r\n        if (hasPreferredCleaners) return false;\r\n        \r\n        // Check for time overlap\r\n        const [hours, mins] = b.service_time.split(':').slice(0, 2).map(Number);\r\n        const start = hours * 60 + mins;\r\n        const duration = Math.round((typeof b.service_duration === 'number' ? b.service_duration : parseFloat(b.service_duration || '0')) * 60);\r\n        const end = start + duration;\r\n        return newStartTimeMinutes < end && newEndTimeMinutes > start;\r\n      }\r\n    ).reduce((sum, b) => {\r\n      // Sum up the number_of_cleaners for bookings without preferred cleaners\r\n      return sum + (b.number_of_cleaners || 1);\r\n    }, 0);\r\n\r\n    const unavailableCleaners = bookedCleanerIds.size + bookingsWithoutPreferredCleaner;\r\n    const availableCleanersCount = Math.max(0, totalCleaners - unavailableCleaners);\r\n\r\n    return {\r\n      available: availableCleanersCount > 0,\r\n      availableCleanersCount,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking cleaner availability:', error);\r\n    // On error, assume unavailable for safety\r\n    return { available: false, availableCleanersCount: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Check availability for all time slots for a given date\r\n */\r\nexport async function checkAvailabilityForAllSlots(\r\n  serviceDate: string,\r\n  workingHours: WorkingHour[],\r\n  serviceDuration: number\r\n): Promise<Record<string, TimeSlotAvailability>> {\r\n  const availability: Record<string, TimeSlotAvailability> = {};\r\n\r\n  // Check availability for each time slot in parallel\r\n  // Use the service duration provided (either from form data or calculated)\r\n  const promises = workingHours.map(async (hour) => {\r\n    // Use the provided service duration, not the working hour's duration\r\n    // The working hour duration is just the slot length, but the actual booking\r\n    // will use the service duration from the form\r\n    const slotAvailability = await checkCleanerAvailabilityForSlot(\r\n      serviceDate,\r\n      hour.start_time,\r\n      serviceDuration\r\n    );\r\n    return { time: hour.start_time, availability: slotAvailability };\r\n  });\r\n\r\n  const results = await Promise.all(promises);\r\n  \r\n  results.forEach(({ time, availability: avail }) => {\r\n    availability[time] = avail;\r\n  });\r\n\r\n  return availability;\r\n}\r\n\r\n/**\r\n * Validate discount code\r\n */\r\nexport async function validateDiscountCode(code: string, subtotal: number): Promise<{\r\n  valid: boolean;\r\n  discountAmount: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (!code || !code.trim()) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('discount_codes')\r\n      .select('*')\r\n      .eq('code', code.trim().toUpperCase())\r\n      .eq('is_active', true)\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      return { valid: false, discountAmount: 0, error: 'Invalid discount code' };\r\n    }\r\n\r\n    // Check validity dates\r\n    const now = new Date();\r\n    const validFrom = new Date(data.valid_from);\r\n    const validUntil = new Date(data.valid_until);\r\n\r\n    if (now < validFrom || now > validUntil) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has expired' };\r\n    }\r\n\r\n    // Check max uses\r\n    if (data.max_uses && data.used_count >= data.max_uses) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has reached maximum uses' };\r\n    }\r\n\r\n    // Check min purchase amount\r\n    if (data.min_purchase_amount && subtotal < data.min_purchase_amount) {\r\n      return { \r\n        valid: false, \r\n        discountAmount: 0, \r\n        error: `Minimum purchase amount of R${data.min_purchase_amount} required` \r\n      };\r\n    }\r\n\r\n    // Calculate discount amount\r\n    let discountAmount = 0;\r\n    if (data.discount_type === 'percentage') {\r\n      discountAmount = (subtotal * data.discount_value) / 100;\r\n      if (data.max_discount_amount && discountAmount > data.max_discount_amount) {\r\n        discountAmount = data.max_discount_amount;\r\n      }\r\n    } else {\r\n      discountAmount = data.discount_value;\r\n    }\r\n\r\n    // Ensure discount doesn't exceed subtotal\r\n    discountAmount = Math.min(discountAmount, subtotal);\r\n\r\n    return { valid: true, discountAmount };\r\n  } catch (error) {\r\n    console.error('Error validating discount code:', error);\r\n    return { valid: false, discountAmount: 0, error: 'Error validating discount code' };\r\n  }\r\n}\r\n\r\n/**\r\n * Create booking draft (before payment)\r\n */\r\nexport async function createBookingDraft(formData: BookingFormData): Promise<{\r\n  success: boolean;\r\n  bookingId?: string;\r\n  bookingIds?: string[];\r\n  totalAmount?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current user if logged in\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n    const userId = user?.id || null;\r\n\r\n    // Get service name\r\n    const { data: service } = await supabase\r\n      .from('services')\r\n      .select('name')\r\n      .eq('id', formData.serviceId)\r\n      .single();\r\n\r\n    if (!service) {\r\n      return { success: false, error: 'Service not found' };\r\n    }\r\n\r\n    // Validate that the selected frequency is valid for this service\r\n    if (!isValidFrequencyForService(service.name, formData.cleaningFrequency)) {\r\n      return { \r\n        success: false, \r\n        error: `Recurring bookings are only available for Standard Cleaning and Airbnb Cleaning services. Selected service: ${service.name}` \r\n      };\r\n    }\r\n\r\n    // Calculate pricing\r\n    const priceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount: 0, // Will calculate discount in next step\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Apply discount code if provided\r\n    let discountAmount = 0;\r\n    if (formData.discountCode) {\r\n      const discountValidation = await validateDiscountCode(\r\n        formData.discountCode,\r\n        priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount\r\n      );\r\n      if (discountValidation.valid) {\r\n        discountAmount = discountValidation.discountAmount;\r\n      }\r\n    }\r\n\r\n    // Recalculate with discount\r\n    const finalPriceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount,\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Determine if this is a recurring booking\r\n    const isRecurring = formData.cleaningFrequency !== 'one-time';\r\n\r\n    // Calculate booking dates based on frequency\r\n    const startDate = new Date(formData.serviceDate);\r\n    const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n\r\n    // Calculate next booking date for recurring bookings\r\n    let nextBookingDate: Date | null = null;\r\n    if (isRecurring && bookingDates.length > 0) {\r\n      const lastDate = bookingDates[bookingDates.length - 1];\r\n      nextBookingDate = calculateNextBookingDate(lastDate, formData.cleaningFrequency);\r\n    }\r\n\r\n    // Create bookings for all dates\r\n    const bookingsToCreate: BookingCreateInput[] = [];\r\n\r\n    for (let i = 0; i < bookingDates.length; i++) {\r\n      const bookingDate = bookingDates[i];\r\n      const bookingNumber = generateBookingNumber();\r\n\r\n      // Tip is only applied to the first booking in a recurring series (one-time payment)\r\n      const tipAmount = (i === 0) ? (formData.tipAmount || 0) : 0;\r\n      \r\n      const bookingInput: BookingCreateInput = {\r\n        booking_number: bookingNumber,\r\n        customer_first_name: formData.customerFirstName,\r\n        customer_last_name: formData.customerLastName,\r\n        customer_email: formData.customerEmail,\r\n        customer_phone: formData.customerPhone,\r\n        service_id: formData.serviceId,\r\n        service_type: service.name,\r\n        bedrooms: formData.bedrooms,\r\n        bathrooms: formData.bathrooms,\r\n        additional_services: formData.additionalServices,\r\n        cleaning_equipment: formData.cleaningEquipment,\r\n        preferred_cleaner_ids: formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n          ? formData.preferredCleanerIds \r\n          : null,\r\n        preferred_cleaner_id: formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n          ? formData.preferredCleanerIds[0] \r\n          : null, // Backward compatibility: set to first cleaner\r\n        cleaning_frequency: formData.cleaningFrequency,\r\n        service_date: formatDateForDB(bookingDate),\r\n        service_time: formData.serviceTime,\r\n        service_duration: formData.serviceDuration,\r\n        service_address: formData.serviceAddress,\r\n        service_apt_unit: formData.serviceAptUnit || null,\r\n        service_suburb: formData.serviceSuburb,\r\n        service_city: formData.serviceCity,\r\n        special_instructions: formData.specialInstructions || null,\r\n        tip_amount: tipAmount,\r\n        base_price: finalPriceBreakdown.basePrice,\r\n        additional_services_price: finalPriceBreakdown.additionalServicesPrice,\r\n        equipment_supply_price: finalPriceBreakdown.equipmentSupplyPrice,\r\n        number_of_cleaners: formData.numberOfCleaners || 1,\r\n        additional_cleaners_price: finalPriceBreakdown.additionalCleanersPrice,\r\n        frequency_discount_percent: finalPriceBreakdown.frequencyDiscountPercent,\r\n        frequency_discount_amount: finalPriceBreakdown.frequencyDiscountAmount,\r\n        subtotal: finalPriceBreakdown.subtotal,\r\n        service_fee: finalPriceBreakdown.serviceFee,\r\n        total_amount: finalPriceBreakdown.totalAmount + tipAmount,\r\n        discount_code: formData.discountCode || null,\r\n        discount_amount: discountAmount,\r\n        referral_code: formData.referralCode || null,\r\n        amount_paid: 0,\r\n        payment_status: 'pending',\r\n        status: 'pending',\r\n        user_id: userId,\r\n        parent_booking_id: null, // Will be updated after first booking is created\r\n        is_recurring: isRecurring,\r\n        recurrence_status: isRecurring ? 'active' : undefined,\r\n        next_booking_date: i === 0 && isRecurring && nextBookingDate ? formatDateForDB(nextBookingDate) : null,\r\n      };\r\n\r\n      bookingsToCreate.push(bookingInput);\r\n    }\r\n\r\n    // Insert all bookings\r\n    const { data: insertedBookings, error } = await supabase\r\n      .from('bookings')\r\n      .insert(bookingsToCreate)\r\n      .select('id, total_amount');\r\n\r\n    if (error) {\r\n      console.error('Error creating booking drafts:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!insertedBookings || insertedBookings.length === 0) {\r\n      return { success: false, error: 'Failed to create bookings' };\r\n    }\r\n\r\n    // Update parent_booking_id for subsequent bookings if there are multiple\r\n    if (insertedBookings.length > 1 && isRecurring) {\r\n      const firstBookingId = insertedBookings[0].id;\r\n      const subsequentBookingIds = insertedBookings.slice(1).map(b => b.id);\r\n      \r\n      // Update all subsequent bookings to reference the first one\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({ parent_booking_id: firstBookingId })\r\n        .in('id', subsequentBookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating parent_booking_id:', updateError);\r\n        // Don't fail, but log the error\r\n      }\r\n    }\r\n\r\n    // Calculate total amount\r\n    const totalAmount = insertedBookings.reduce((sum, booking) => sum + Number(booking.total_amount), 0);\r\n    const bookingIds = insertedBookings.map(booking => booking.id);\r\n\r\n    // For backward compatibility, also return single bookingId\r\n    const bookingId = bookingIds[0];\r\n\r\n    // If multiple bookings, return array; otherwise return single ID for backward compatibility\r\n    if (bookingIds.length > 1) {\r\n      return { \r\n        success: true, \r\n        bookingIds,\r\n        totalAmount,\r\n        bookingId // Keep for backward compatibility\r\n      };\r\n    }\r\n\r\n    return { \r\n      success: true, \r\n      bookingId,\r\n      bookingIds,\r\n      totalAmount\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error creating booking draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize payment for booking(s)\r\n * Accepts either a single bookingId or an array of bookingIds\r\n */\r\nexport async function initializePaymentForBooking(\r\n  bookingIdOrIds: string | string[]\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const bookingIds = Array.isArray(bookingIdOrIds) ? bookingIdOrIds : [bookingIdOrIds];\r\n\r\n    // Get all booking details\r\n    const { data: bookings, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (fetchError || !bookings || bookings.length === 0) {\r\n      return { success: false, error: 'Booking(s) not found' };\r\n    }\r\n\r\n    // Check if all bookings are in pending status\r\n    const nonPendingBookings = bookings.filter(b => b.payment_status !== 'pending');\r\n    if (nonPendingBookings.length > 0) {\r\n      return { success: false, error: 'Some bookings are not in pending payment status' };\r\n    }\r\n\r\n    // Calculate total amount from all bookings (including tip)\r\n    // Note: total_amount in database now includes tip for new bookings\r\n    // For backward compatibility with existing bookings that might not have tip in total_amount, \r\n    // we check and add tip_amount if it's missing\r\n    const totalAmount = bookings.reduce((sum, booking) => {\r\n      const bookingTotal = Number(booking.total_amount) || 0;\r\n      const tipAmount = Number(booking.tip_amount) || 0;\r\n      const baseTotal = Number(booking.subtotal || 0) + Number(booking.service_fee || 0);\r\n      \r\n      // Check if tip is already included in total_amount\r\n      // If total_amount equals baseTotal exactly, then tip is not included, so add it\r\n      // Otherwise, total_amount already includes tip\r\n      if (tipAmount > 0 && Math.abs(bookingTotal - baseTotal) < 0.01) {\r\n        // Tip is not included in total_amount (backward compatibility case)\r\n        return sum + bookingTotal + tipAmount;\r\n      }\r\n      // Tip is already included in total_amount (new bookings)\r\n      return sum + bookingTotal;\r\n    }, 0);\r\n    \r\n    // Use the first booking's email and details for payment\r\n    const firstBooking = bookings[0];\r\n    const reference = firstBooking.paystack_reference || `${firstBooking.booking_number}${Date.now()}`;\r\n    \r\n    // Initialize Paystack payment with total amount\r\n    const paymentResponse = await initializePayment(\r\n      firstBooking.customer_email,\r\n      totalAmount,\r\n      reference,\r\n      {\r\n        booking_ids: bookingIds,\r\n        booking_id: firstBooking.id, // Keep for backward compatibility\r\n        booking_number: firstBooking.booking_number,\r\n        customer_email: firstBooking.customer_email,\r\n      }\r\n    );\r\n\r\n    if (!paymentResponse.status) {\r\n      return { success: false, error: paymentResponse.message || 'Failed to initialize payment' };\r\n    }\r\n\r\n    // Update all bookings with the same Paystack reference\r\n    const { error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        paystack_reference: reference,\r\n      })\r\n      .in('id', bookingIds);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating bookings with Paystack reference:', updateError);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentResponse.data.authorization_url,\r\n      reference: paymentResponse.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing payment:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get booking by ID\r\n */\r\nexport async function getBooking(bookingId: string): Promise<{\r\n  success: boolean;\r\n  booking?: any;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners for selection\r\n * Optionally filter by service area/suburb\r\n */\r\nexport async function getAvailableCleaners(serviceSuburb?: string): Promise<{\r\n  success: boolean;\r\n  cleaners?: any[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Build query - only filter by is_available if the column exists\r\n    // First, try to get all active cleaners\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = data || [];\r\n\r\n    // Filter by is_available if the column exists (client-side filter as fallback)\r\n    cleaners = cleaners.filter((cleaner) => {\r\n      // If is_available column doesn't exist or is null/undefined, include the cleaner\r\n      // Otherwise, only include if is_available is true\r\n      return cleaner.is_available !== false;\r\n    });\r\n\r\n    // Filter by area if suburb is provided\r\n    // Since PostgreSQL array contains is complex in Supabase, we filter client-side\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        // If cleaner has no areas specified, include them (they serve all areas)\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true;\r\n        }\r\n        // Check if any area matches the suburb (case-insensitive partial match)\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    return { success: true, cleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a cleaner is available for a specific day of the week\r\n * dayOfWeek: 0 = Sunday, 1 = Monday, ..., 6 = Saturday\r\n */\r\nexport async function isCleanerAvailableForDay(cleaner: any, dayOfWeek: number): Promise<boolean> {\r\n  const dayMap: Record<number, keyof typeof cleaner> = {\r\n    0: 'available_sunday',\r\n    1: 'available_monday',\r\n    2: 'available_tuesday',\r\n    3: 'available_wednesday',\r\n    4: 'available_thursday',\r\n    5: 'available_friday',\r\n    6: 'available_saturday',\r\n  };\r\n\r\n  const dayField = dayMap[dayOfWeek];\r\n  return cleaner[dayField] !== false && cleaner.is_available !== false;\r\n}\r\n\r\n/**\r\n * Check if a cleaner has a booking conflict for a specific date and time slot\r\n */\r\nexport async function checkCleanerBookingConflict(\r\n  cleanerId: string,\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Query bookings for this cleaner on the specified date\r\n    const { data: bookings, error } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration')\r\n      .eq('preferred_cleaner_id', cleanerId)\r\n      .eq('service_date', serviceDate)\r\n      .in('status', ['pending', 'confirmed']);\r\n\r\n    if (error) {\r\n      console.error('Error checking booking conflicts:', error);\r\n      return false; // Assume no conflict on error\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      return false; // No bookings, no conflict\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n\r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number'\r\n          ? booking.service_duration\r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        return true; // Conflict found\r\n      }\r\n    }\r\n\r\n    return false; // No conflicts\r\n  } catch (error) {\r\n    console.error('Unexpected error checking booking conflict:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate reliability score for a cleaner (server-side wrapper)\r\n * This calls the database function if available, otherwise calculates client-side\r\n */\r\nexport async function calculateCleanerReliabilityScore(cleanerId: string): Promise<number> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Try to call the database function\r\n    const { data, error } = await supabase.rpc('calculate_cleaner_reliability_score', {\r\n      cleaner_id: cleanerId,\r\n    });\r\n\r\n    if (!error && data !== null) {\r\n      return parseFloat(data.toString());\r\n    }\r\n\r\n    // Fallback: fetch cleaner and calculate client-side\r\n    const { data: cleaner, error: fetchError } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('id', cleanerId)\r\n      .single();\r\n\r\n    if (fetchError || !cleaner) {\r\n      return 50.0; // Default score\r\n    }\r\n\r\n    return calculateReliabilityScore(cleaner as Cleaner);\r\n  } catch (error) {\r\n    console.error('Error calculating reliability score:', error);\r\n    return 50.0; // Default score on error\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners with enhanced filtering criteria\r\n * Filters by: Location, Availability, Booking conflicts\r\n * Sorts by: Reliability Score, Rating\r\n */\r\nexport async function getAvailableCleanersWithCriteria(params: {\r\n  serviceSuburb?: string;\r\n  serviceDate?: string;\r\n  serviceTime?: string;\r\n  serviceDuration?: number;\r\n  minRating?: number;\r\n  minReliabilityScore?: number;\r\n}): Promise<{\r\n  success: boolean;\r\n  cleaners?: CleanerWithAvailability[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const {\r\n      serviceSuburb,\r\n      serviceDate,\r\n      serviceTime,\r\n      serviceDuration = 3,\r\n      minRating = 0,\r\n      minReliabilityScore = 0,\r\n    } = params;\r\n\r\n    // Build base query\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query.order('reliability_score', { ascending: false, nullsFirst: false })\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = (data || []) as Cleaner[];\r\n\r\n    // Filter by is_available\r\n    cleaners = cleaners.filter((cleaner) => cleaner.is_available !== false);\r\n\r\n    // Filter by location (suburb)\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true; // Serve all areas\r\n        }\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Filter by day of week availability if date is provided\r\n    if (serviceDate) {\r\n      const date = new Date(serviceDate);\r\n      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        const dayMap: Record<number, keyof Cleaner> = {\r\n          0: 'available_sunday',\r\n          1: 'available_monday',\r\n          2: 'available_tuesday',\r\n          3: 'available_wednesday',\r\n          4: 'available_thursday',\r\n          5: 'available_friday',\r\n          6: 'available_saturday',\r\n        };\r\n        const dayField = dayMap[dayOfWeek];\r\n        return cleaner[dayField] !== false;\r\n      });\r\n    }\r\n\r\n    // Filter by minimum rating\r\n    if (minRating > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.rating || 0) >= minRating);\r\n    }\r\n\r\n    // Filter by minimum reliability score\r\n    if (minReliabilityScore > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.reliability_score || 0) >= minReliabilityScore);\r\n    }\r\n\r\n    // Enrich cleaners with availability and booking conflict information\r\n    const enrichedCleaners: CleanerWithAvailability[] = await Promise.all(\r\n      cleaners.map(async (cleaner) => {\r\n        let isAvailableForSlot = true;\r\n        let bookingConflict = false;\r\n\r\n        // Check booking conflict if date and time are provided\r\n        if (serviceDate && serviceTime && serviceDuration) {\r\n          bookingConflict = await checkCleanerBookingConflict(\r\n            cleaner.id,\r\n            serviceDate,\r\n            serviceTime,\r\n            serviceDuration\r\n          );\r\n          isAvailableForSlot = !bookingConflict;\r\n        }\r\n\r\n        // Calculate reliability score if not present\r\n        const reliabilityScore = cleaner.reliability_score ?? calculateReliabilityScore(cleaner);\r\n\r\n        return {\r\n          ...cleaner,\r\n          reliability_score: reliabilityScore,\r\n          isAvailableForSlot,\r\n          bookingConflict,\r\n          completionRate: calculateCompletionRate(cleaner),\r\n          onTimeRate: calculateOnTimeRate(cleaner),\r\n        };\r\n      })\r\n    );\r\n\r\n    // Sort by reliability score and rating (already sorted by query, but ensure consistency)\r\n    enrichedCleaners.sort((a, b) => {\r\n      const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n      const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n\r\n    return { success: true, cleaners: enrichedCleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners with criteria:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAmTsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,sDAAA"}},
    {"offset": {"line": 1679, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/book/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { BookingFormData, BookingCreateInput, WorkingHour, TimeSlotAvailability, Cleaner, CleanerWithAvailability } from '@/types/booking';\r\nimport { calculatePrice } from '@/lib/pricing/calculator';\r\nimport { generateBookingNumber } from '@/lib/utils/booking-number';\r\nimport { initializePayment } from '@/lib/paystack/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { calculateReliabilityScore, calculateCompletionRate, calculateOnTimeRate } from '@/lib/utils/cleaner-utils';\r\nimport { calculateBookingDatesForMonth, calculateNextBookingDate, formatDateForDB } from '@/lib/utils/recurring-dates';\r\nimport { isValidFrequencyForService } from '@/lib/utils/service-validation';\r\n\r\n/**\r\n * Get available working hours (30-minute interval start times)\r\n */\r\nexport async function getWorkingHours(): Promise<WorkingHour[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('working_hours')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as WorkingHour[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get working hours from home_detail_options (backward compatibility)\r\n */\r\nexport async function getWorkingHoursFromOptions(): Promise<Array<{ value: string; label: string }>> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('value, label')\r\n      .eq('option_type', 'working_hours')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours from options:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []).map((item) => ({\r\n      value: item.value,\r\n      label: item.label,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours from options:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check cleaner availability for a specific date and time slot\r\n * Returns availability status and count of available cleaners\r\n */\r\nexport async function checkCleanerAvailabilityForSlot(\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<TimeSlotAvailability> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, check if any active cleaners exist in the system\r\n    const { data: activeCleaners, error: cleanersError } = await supabase\r\n      .from('cleaners')\r\n      .select('id')\r\n      .eq('is_active', true);\r\n\r\n    if (cleanersError) {\r\n      console.error('Error checking active cleaners:', cleanersError);\r\n      // If we can't check cleaners, assume unavailable for safety\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    // If no active cleaners exist, no slots are available\r\n    if (!activeCleaners || activeCleaners.length === 0) {\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    const totalCleaners = activeCleaners.length;\r\n\r\n    // Query bookings for the specified date that might overlap\r\n    // We need to check for bookings where:\r\n    // (booking_start_time < new_end_time) AND (booking_end_time > new_start_time)\r\n    // Only consider pending or confirmed bookings (exclude cancelled/completed)\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration, preferred_cleaner_id, preferred_cleaner_ids, number_of_cleaners')\r\n      .eq('service_date', serviceDate)\r\n      .in('status', ['pending', 'confirmed']);\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking bookings:', bookingsError);\r\n      // If we can't check bookings, assume available (optimistic approach)\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      // No bookings for this date, all cleaners are available\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Track which cleaners are booked (by ID)\r\n    const bookedCleanerIds = new Set<string>();\r\n    \r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n      \r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number' \r\n          ? booking.service_duration \r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        // There's an overlap\r\n        // Check preferred_cleaner_ids first (new multi-cleaner support)\r\n        if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n          // Multiple cleaners are assigned\r\n          booking.preferred_cleaner_ids.forEach((cleanerId: string) => {\r\n            if (cleanerId) bookedCleanerIds.add(cleanerId);\r\n          });\r\n        } else if (booking.preferred_cleaner_id) {\r\n          // Single cleaner assigned (backward compatibility)\r\n          bookedCleanerIds.add(booking.preferred_cleaner_id);\r\n        } else {\r\n          // If no preferred cleaner, use number_of_cleaners to count generic cleaner slots\r\n          // This handles bookings without specific cleaner assignments\r\n          const numCleaners = booking.number_of_cleaners || 1;\r\n          // We don't add specific IDs here, but count them in bookingsWithoutPreferredCleaner\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate available cleaners\r\n    // Count bookings without preferred cleaners (generic assignments)\r\n    // These use number_of_cleaners to determine how many cleaner slots are taken\r\n    const bookingsWithoutPreferredCleaner = bookings.filter(\r\n      (b) => {\r\n        const hasPreferredCleaners = (b.preferred_cleaner_ids && Array.isArray(b.preferred_cleaner_ids) && b.preferred_cleaner_ids.length > 0) || b.preferred_cleaner_id;\r\n        if (hasPreferredCleaners) return false;\r\n        \r\n        // Check for time overlap\r\n        const [hours, mins] = b.service_time.split(':').slice(0, 2).map(Number);\r\n        const start = hours * 60 + mins;\r\n        const duration = Math.round((typeof b.service_duration === 'number' ? b.service_duration : parseFloat(b.service_duration || '0')) * 60);\r\n        const end = start + duration;\r\n        return newStartTimeMinutes < end && newEndTimeMinutes > start;\r\n      }\r\n    ).reduce((sum, b) => {\r\n      // Sum up the number_of_cleaners for bookings without preferred cleaners\r\n      return sum + (b.number_of_cleaners || 1);\r\n    }, 0);\r\n\r\n    const unavailableCleaners = bookedCleanerIds.size + bookingsWithoutPreferredCleaner;\r\n    const availableCleanersCount = Math.max(0, totalCleaners - unavailableCleaners);\r\n\r\n    return {\r\n      available: availableCleanersCount > 0,\r\n      availableCleanersCount,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking cleaner availability:', error);\r\n    // On error, assume unavailable for safety\r\n    return { available: false, availableCleanersCount: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Check availability for all time slots for a given date\r\n */\r\nexport async function checkAvailabilityForAllSlots(\r\n  serviceDate: string,\r\n  workingHours: WorkingHour[],\r\n  serviceDuration: number\r\n): Promise<Record<string, TimeSlotAvailability>> {\r\n  const availability: Record<string, TimeSlotAvailability> = {};\r\n\r\n  // Check availability for each time slot in parallel\r\n  // Use the service duration provided (either from form data or calculated)\r\n  const promises = workingHours.map(async (hour) => {\r\n    // Use the provided service duration, not the working hour's duration\r\n    // The working hour duration is just the slot length, but the actual booking\r\n    // will use the service duration from the form\r\n    const slotAvailability = await checkCleanerAvailabilityForSlot(\r\n      serviceDate,\r\n      hour.start_time,\r\n      serviceDuration\r\n    );\r\n    return { time: hour.start_time, availability: slotAvailability };\r\n  });\r\n\r\n  const results = await Promise.all(promises);\r\n  \r\n  results.forEach(({ time, availability: avail }) => {\r\n    availability[time] = avail;\r\n  });\r\n\r\n  return availability;\r\n}\r\n\r\n/**\r\n * Validate discount code\r\n */\r\nexport async function validateDiscountCode(code: string, subtotal: number): Promise<{\r\n  valid: boolean;\r\n  discountAmount: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (!code || !code.trim()) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('discount_codes')\r\n      .select('*')\r\n      .eq('code', code.trim().toUpperCase())\r\n      .eq('is_active', true)\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      return { valid: false, discountAmount: 0, error: 'Invalid discount code' };\r\n    }\r\n\r\n    // Check validity dates\r\n    const now = new Date();\r\n    const validFrom = new Date(data.valid_from);\r\n    const validUntil = new Date(data.valid_until);\r\n\r\n    if (now < validFrom || now > validUntil) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has expired' };\r\n    }\r\n\r\n    // Check max uses\r\n    if (data.max_uses && data.used_count >= data.max_uses) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has reached maximum uses' };\r\n    }\r\n\r\n    // Check min purchase amount\r\n    if (data.min_purchase_amount && subtotal < data.min_purchase_amount) {\r\n      return { \r\n        valid: false, \r\n        discountAmount: 0, \r\n        error: `Minimum purchase amount of R${data.min_purchase_amount} required` \r\n      };\r\n    }\r\n\r\n    // Calculate discount amount\r\n    let discountAmount = 0;\r\n    if (data.discount_type === 'percentage') {\r\n      discountAmount = (subtotal * data.discount_value) / 100;\r\n      if (data.max_discount_amount && discountAmount > data.max_discount_amount) {\r\n        discountAmount = data.max_discount_amount;\r\n      }\r\n    } else {\r\n      discountAmount = data.discount_value;\r\n    }\r\n\r\n    // Ensure discount doesn't exceed subtotal\r\n    discountAmount = Math.min(discountAmount, subtotal);\r\n\r\n    return { valid: true, discountAmount };\r\n  } catch (error) {\r\n    console.error('Error validating discount code:', error);\r\n    return { valid: false, discountAmount: 0, error: 'Error validating discount code' };\r\n  }\r\n}\r\n\r\n/**\r\n * Create booking draft (before payment)\r\n */\r\nexport async function createBookingDraft(formData: BookingFormData): Promise<{\r\n  success: boolean;\r\n  bookingId?: string;\r\n  bookingIds?: string[];\r\n  totalAmount?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current user if logged in\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n    const userId = user?.id || null;\r\n\r\n    // Get service name\r\n    const { data: service } = await supabase\r\n      .from('services')\r\n      .select('name')\r\n      .eq('id', formData.serviceId)\r\n      .single();\r\n\r\n    if (!service) {\r\n      return { success: false, error: 'Service not found' };\r\n    }\r\n\r\n    // Validate that the selected frequency is valid for this service\r\n    if (!isValidFrequencyForService(service.name, formData.cleaningFrequency)) {\r\n      return { \r\n        success: false, \r\n        error: `Recurring bookings are only available for Standard Cleaning and Airbnb Cleaning services. Selected service: ${service.name}` \r\n      };\r\n    }\r\n\r\n    // Calculate pricing\r\n    const priceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount: 0, // Will calculate discount in next step\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Apply discount code if provided\r\n    let discountAmount = 0;\r\n    if (formData.discountCode) {\r\n      const discountValidation = await validateDiscountCode(\r\n        formData.discountCode,\r\n        priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount\r\n      );\r\n      if (discountValidation.valid) {\r\n        discountAmount = discountValidation.discountAmount;\r\n      }\r\n    }\r\n\r\n    // Recalculate with discount\r\n    const finalPriceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount,\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Determine if this is a recurring booking\r\n    const isRecurring = formData.cleaningFrequency !== 'one-time';\r\n\r\n    // Calculate booking dates based on frequency\r\n    const startDate = new Date(formData.serviceDate);\r\n    const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n\r\n    // Calculate next booking date for recurring bookings\r\n    let nextBookingDate: Date | null = null;\r\n    if (isRecurring && bookingDates.length > 0) {\r\n      const lastDate = bookingDates[bookingDates.length - 1];\r\n      nextBookingDate = calculateNextBookingDate(lastDate, formData.cleaningFrequency);\r\n    }\r\n\r\n    // Create bookings for all dates\r\n    const bookingsToCreate: BookingCreateInput[] = [];\r\n\r\n    for (let i = 0; i < bookingDates.length; i++) {\r\n      const bookingDate = bookingDates[i];\r\n      const bookingNumber = generateBookingNumber();\r\n\r\n      // Tip is only applied to the first booking in a recurring series (one-time payment)\r\n      const tipAmount = (i === 0) ? (formData.tipAmount || 0) : 0;\r\n      \r\n      const bookingInput: BookingCreateInput = {\r\n        booking_number: bookingNumber,\r\n        customer_first_name: formData.customerFirstName,\r\n        customer_last_name: formData.customerLastName,\r\n        customer_email: formData.customerEmail,\r\n        customer_phone: formData.customerPhone,\r\n        service_id: formData.serviceId,\r\n        service_type: service.name,\r\n        bedrooms: formData.bedrooms,\r\n        bathrooms: formData.bathrooms,\r\n        additional_services: formData.additionalServices,\r\n        cleaning_equipment: formData.cleaningEquipment,\r\n        preferred_cleaner_ids: formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n          ? formData.preferredCleanerIds \r\n          : null,\r\n        preferred_cleaner_id: formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n          ? formData.preferredCleanerIds[0] \r\n          : null, // Backward compatibility: set to first cleaner\r\n        cleaning_frequency: formData.cleaningFrequency,\r\n        service_date: formatDateForDB(bookingDate),\r\n        service_time: formData.serviceTime,\r\n        service_duration: formData.serviceDuration,\r\n        service_address: formData.serviceAddress,\r\n        service_apt_unit: formData.serviceAptUnit || null,\r\n        service_suburb: formData.serviceSuburb,\r\n        service_city: formData.serviceCity,\r\n        special_instructions: formData.specialInstructions || null,\r\n        tip_amount: tipAmount,\r\n        base_price: finalPriceBreakdown.basePrice,\r\n        additional_services_price: finalPriceBreakdown.additionalServicesPrice,\r\n        equipment_supply_price: finalPriceBreakdown.equipmentSupplyPrice,\r\n        number_of_cleaners: formData.numberOfCleaners || 1,\r\n        additional_cleaners_price: finalPriceBreakdown.additionalCleanersPrice,\r\n        frequency_discount_percent: finalPriceBreakdown.frequencyDiscountPercent,\r\n        frequency_discount_amount: finalPriceBreakdown.frequencyDiscountAmount,\r\n        subtotal: finalPriceBreakdown.subtotal,\r\n        service_fee: finalPriceBreakdown.serviceFee,\r\n        total_amount: finalPriceBreakdown.totalAmount + tipAmount,\r\n        discount_code: formData.discountCode || null,\r\n        discount_amount: discountAmount,\r\n        referral_code: formData.referralCode || null,\r\n        amount_paid: 0,\r\n        payment_status: 'pending',\r\n        status: 'pending',\r\n        user_id: userId,\r\n        parent_booking_id: null, // Will be updated after first booking is created\r\n        is_recurring: isRecurring,\r\n        recurrence_status: isRecurring ? 'active' : undefined,\r\n        next_booking_date: i === 0 && isRecurring && nextBookingDate ? formatDateForDB(nextBookingDate) : null,\r\n      };\r\n\r\n      bookingsToCreate.push(bookingInput);\r\n    }\r\n\r\n    // Insert all bookings\r\n    const { data: insertedBookings, error } = await supabase\r\n      .from('bookings')\r\n      .insert(bookingsToCreate)\r\n      .select('id, total_amount');\r\n\r\n    if (error) {\r\n      console.error('Error creating booking drafts:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!insertedBookings || insertedBookings.length === 0) {\r\n      return { success: false, error: 'Failed to create bookings' };\r\n    }\r\n\r\n    // Update parent_booking_id for subsequent bookings if there are multiple\r\n    if (insertedBookings.length > 1 && isRecurring) {\r\n      const firstBookingId = insertedBookings[0].id;\r\n      const subsequentBookingIds = insertedBookings.slice(1).map(b => b.id);\r\n      \r\n      // Update all subsequent bookings to reference the first one\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({ parent_booking_id: firstBookingId })\r\n        .in('id', subsequentBookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating parent_booking_id:', updateError);\r\n        // Don't fail, but log the error\r\n      }\r\n    }\r\n\r\n    // Calculate total amount\r\n    const totalAmount = insertedBookings.reduce((sum, booking) => sum + Number(booking.total_amount), 0);\r\n    const bookingIds = insertedBookings.map(booking => booking.id);\r\n\r\n    // For backward compatibility, also return single bookingId\r\n    const bookingId = bookingIds[0];\r\n\r\n    // If multiple bookings, return array; otherwise return single ID for backward compatibility\r\n    if (bookingIds.length > 1) {\r\n      return { \r\n        success: true, \r\n        bookingIds,\r\n        totalAmount,\r\n        bookingId // Keep for backward compatibility\r\n      };\r\n    }\r\n\r\n    return { \r\n      success: true, \r\n      bookingId,\r\n      bookingIds,\r\n      totalAmount\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error creating booking draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize payment for booking(s)\r\n * Accepts either a single bookingId or an array of bookingIds\r\n */\r\nexport async function initializePaymentForBooking(\r\n  bookingIdOrIds: string | string[]\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const bookingIds = Array.isArray(bookingIdOrIds) ? bookingIdOrIds : [bookingIdOrIds];\r\n\r\n    // Get all booking details\r\n    const { data: bookings, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (fetchError || !bookings || bookings.length === 0) {\r\n      return { success: false, error: 'Booking(s) not found' };\r\n    }\r\n\r\n    // Check if all bookings are in pending status\r\n    const nonPendingBookings = bookings.filter(b => b.payment_status !== 'pending');\r\n    if (nonPendingBookings.length > 0) {\r\n      return { success: false, error: 'Some bookings are not in pending payment status' };\r\n    }\r\n\r\n    // Calculate total amount from all bookings (including tip)\r\n    // Note: total_amount in database now includes tip for new bookings\r\n    // For backward compatibility with existing bookings that might not have tip in total_amount, \r\n    // we check and add tip_amount if it's missing\r\n    const totalAmount = bookings.reduce((sum, booking) => {\r\n      const bookingTotal = Number(booking.total_amount) || 0;\r\n      const tipAmount = Number(booking.tip_amount) || 0;\r\n      const baseTotal = Number(booking.subtotal || 0) + Number(booking.service_fee || 0);\r\n      \r\n      // Check if tip is already included in total_amount\r\n      // If total_amount equals baseTotal exactly, then tip is not included, so add it\r\n      // Otherwise, total_amount already includes tip\r\n      if (tipAmount > 0 && Math.abs(bookingTotal - baseTotal) < 0.01) {\r\n        // Tip is not included in total_amount (backward compatibility case)\r\n        return sum + bookingTotal + tipAmount;\r\n      }\r\n      // Tip is already included in total_amount (new bookings)\r\n      return sum + bookingTotal;\r\n    }, 0);\r\n    \r\n    // Use the first booking's email and details for payment\r\n    const firstBooking = bookings[0];\r\n    const reference = firstBooking.paystack_reference || `${firstBooking.booking_number}${Date.now()}`;\r\n    \r\n    // Initialize Paystack payment with total amount\r\n    const paymentResponse = await initializePayment(\r\n      firstBooking.customer_email,\r\n      totalAmount,\r\n      reference,\r\n      {\r\n        booking_ids: bookingIds,\r\n        booking_id: firstBooking.id, // Keep for backward compatibility\r\n        booking_number: firstBooking.booking_number,\r\n        customer_email: firstBooking.customer_email,\r\n      }\r\n    );\r\n\r\n    if (!paymentResponse.status) {\r\n      return { success: false, error: paymentResponse.message || 'Failed to initialize payment' };\r\n    }\r\n\r\n    // Update all bookings with the same Paystack reference\r\n    const { error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        paystack_reference: reference,\r\n      })\r\n      .in('id', bookingIds);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating bookings with Paystack reference:', updateError);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentResponse.data.authorization_url,\r\n      reference: paymentResponse.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing payment:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get booking by ID\r\n */\r\nexport async function getBooking(bookingId: string): Promise<{\r\n  success: boolean;\r\n  booking?: any;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners for selection\r\n * Optionally filter by service area/suburb\r\n */\r\nexport async function getAvailableCleaners(serviceSuburb?: string): Promise<{\r\n  success: boolean;\r\n  cleaners?: any[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Build query - only filter by is_available if the column exists\r\n    // First, try to get all active cleaners\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = data || [];\r\n\r\n    // Filter by is_available if the column exists (client-side filter as fallback)\r\n    cleaners = cleaners.filter((cleaner) => {\r\n      // If is_available column doesn't exist or is null/undefined, include the cleaner\r\n      // Otherwise, only include if is_available is true\r\n      return cleaner.is_available !== false;\r\n    });\r\n\r\n    // Filter by area if suburb is provided\r\n    // Since PostgreSQL array contains is complex in Supabase, we filter client-side\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        // If cleaner has no areas specified, include them (they serve all areas)\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true;\r\n        }\r\n        // Check if any area matches the suburb (case-insensitive partial match)\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    return { success: true, cleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a cleaner is available for a specific day of the week\r\n * dayOfWeek: 0 = Sunday, 1 = Monday, ..., 6 = Saturday\r\n */\r\nexport async function isCleanerAvailableForDay(cleaner: any, dayOfWeek: number): Promise<boolean> {\r\n  const dayMap: Record<number, keyof typeof cleaner> = {\r\n    0: 'available_sunday',\r\n    1: 'available_monday',\r\n    2: 'available_tuesday',\r\n    3: 'available_wednesday',\r\n    4: 'available_thursday',\r\n    5: 'available_friday',\r\n    6: 'available_saturday',\r\n  };\r\n\r\n  const dayField = dayMap[dayOfWeek];\r\n  return cleaner[dayField] !== false && cleaner.is_available !== false;\r\n}\r\n\r\n/**\r\n * Check if a cleaner has a booking conflict for a specific date and time slot\r\n */\r\nexport async function checkCleanerBookingConflict(\r\n  cleanerId: string,\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Query bookings for this cleaner on the specified date\r\n    const { data: bookings, error } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration')\r\n      .eq('preferred_cleaner_id', cleanerId)\r\n      .eq('service_date', serviceDate)\r\n      .in('status', ['pending', 'confirmed']);\r\n\r\n    if (error) {\r\n      console.error('Error checking booking conflicts:', error);\r\n      return false; // Assume no conflict on error\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      return false; // No bookings, no conflict\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n\r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number'\r\n          ? booking.service_duration\r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        return true; // Conflict found\r\n      }\r\n    }\r\n\r\n    return false; // No conflicts\r\n  } catch (error) {\r\n    console.error('Unexpected error checking booking conflict:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate reliability score for a cleaner (server-side wrapper)\r\n * This calls the database function if available, otherwise calculates client-side\r\n */\r\nexport async function calculateCleanerReliabilityScore(cleanerId: string): Promise<number> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Try to call the database function\r\n    const { data, error } = await supabase.rpc('calculate_cleaner_reliability_score', {\r\n      cleaner_id: cleanerId,\r\n    });\r\n\r\n    if (!error && data !== null) {\r\n      return parseFloat(data.toString());\r\n    }\r\n\r\n    // Fallback: fetch cleaner and calculate client-side\r\n    const { data: cleaner, error: fetchError } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('id', cleanerId)\r\n      .single();\r\n\r\n    if (fetchError || !cleaner) {\r\n      return 50.0; // Default score\r\n    }\r\n\r\n    return calculateReliabilityScore(cleaner as Cleaner);\r\n  } catch (error) {\r\n    console.error('Error calculating reliability score:', error);\r\n    return 50.0; // Default score on error\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners with enhanced filtering criteria\r\n * Filters by: Location, Availability, Booking conflicts\r\n * Sorts by: Reliability Score, Rating\r\n */\r\nexport async function getAvailableCleanersWithCriteria(params: {\r\n  serviceSuburb?: string;\r\n  serviceDate?: string;\r\n  serviceTime?: string;\r\n  serviceDuration?: number;\r\n  minRating?: number;\r\n  minReliabilityScore?: number;\r\n}): Promise<{\r\n  success: boolean;\r\n  cleaners?: CleanerWithAvailability[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const {\r\n      serviceSuburb,\r\n      serviceDate,\r\n      serviceTime,\r\n      serviceDuration = 3,\r\n      minRating = 0,\r\n      minReliabilityScore = 0,\r\n    } = params;\r\n\r\n    // Build base query\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query.order('reliability_score', { ascending: false, nullsFirst: false })\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = (data || []) as Cleaner[];\r\n\r\n    // Filter by is_available\r\n    cleaners = cleaners.filter((cleaner) => cleaner.is_available !== false);\r\n\r\n    // Filter by location (suburb)\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true; // Serve all areas\r\n        }\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Filter by day of week availability if date is provided\r\n    if (serviceDate) {\r\n      const date = new Date(serviceDate);\r\n      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        const dayMap: Record<number, keyof Cleaner> = {\r\n          0: 'available_sunday',\r\n          1: 'available_monday',\r\n          2: 'available_tuesday',\r\n          3: 'available_wednesday',\r\n          4: 'available_thursday',\r\n          5: 'available_friday',\r\n          6: 'available_saturday',\r\n        };\r\n        const dayField = dayMap[dayOfWeek];\r\n        return cleaner[dayField] !== false;\r\n      });\r\n    }\r\n\r\n    // Filter by minimum rating\r\n    if (minRating > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.rating || 0) >= minRating);\r\n    }\r\n\r\n    // Filter by minimum reliability score\r\n    if (minReliabilityScore > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.reliability_score || 0) >= minReliabilityScore);\r\n    }\r\n\r\n    // Enrich cleaners with availability and booking conflict information\r\n    const enrichedCleaners: CleanerWithAvailability[] = await Promise.all(\r\n      cleaners.map(async (cleaner) => {\r\n        let isAvailableForSlot = true;\r\n        let bookingConflict = false;\r\n\r\n        // Check booking conflict if date and time are provided\r\n        if (serviceDate && serviceTime && serviceDuration) {\r\n          bookingConflict = await checkCleanerBookingConflict(\r\n            cleaner.id,\r\n            serviceDate,\r\n            serviceTime,\r\n            serviceDuration\r\n          );\r\n          isAvailableForSlot = !bookingConflict;\r\n        }\r\n\r\n        // Calculate reliability score if not present\r\n        const reliabilityScore = cleaner.reliability_score ?? calculateReliabilityScore(cleaner);\r\n\r\n        return {\r\n          ...cleaner,\r\n          reliability_score: reliabilityScore,\r\n          isAvailableForSlot,\r\n          bookingConflict,\r\n          completionRate: calculateCompletionRate(cleaner),\r\n          onTimeRate: calculateOnTimeRate(cleaner),\r\n        };\r\n      })\r\n    );\r\n\r\n    // Sort by reliability score and rating (already sorted by query, but ensure consistency)\r\n    enrichedCleaners.sort((a, b) => {\r\n      const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n      const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n\r\n    return { success: true, cleaners: enrichedCleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners with criteria:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MA4gBsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 1696, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/book/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { BookingFormData, BookingCreateInput, WorkingHour, TimeSlotAvailability, Cleaner, CleanerWithAvailability } from '@/types/booking';\r\nimport { calculatePrice } from '@/lib/pricing/calculator';\r\nimport { generateBookingNumber } from '@/lib/utils/booking-number';\r\nimport { initializePayment } from '@/lib/paystack/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { calculateReliabilityScore, calculateCompletionRate, calculateOnTimeRate } from '@/lib/utils/cleaner-utils';\r\nimport { calculateBookingDatesForMonth, calculateNextBookingDate, formatDateForDB } from '@/lib/utils/recurring-dates';\r\nimport { isValidFrequencyForService } from '@/lib/utils/service-validation';\r\n\r\n/**\r\n * Get available working hours (30-minute interval start times)\r\n */\r\nexport async function getWorkingHours(): Promise<WorkingHour[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('working_hours')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as WorkingHour[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get working hours from home_detail_options (backward compatibility)\r\n */\r\nexport async function getWorkingHoursFromOptions(): Promise<Array<{ value: string; label: string }>> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('value, label')\r\n      .eq('option_type', 'working_hours')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours from options:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []).map((item) => ({\r\n      value: item.value,\r\n      label: item.label,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours from options:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check cleaner availability for a specific date and time slot\r\n * Returns availability status and count of available cleaners\r\n */\r\nexport async function checkCleanerAvailabilityForSlot(\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<TimeSlotAvailability> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, check if any active cleaners exist in the system\r\n    const { data: activeCleaners, error: cleanersError } = await supabase\r\n      .from('cleaners')\r\n      .select('id')\r\n      .eq('is_active', true);\r\n\r\n    if (cleanersError) {\r\n      console.error('Error checking active cleaners:', cleanersError);\r\n      // If we can't check cleaners, assume unavailable for safety\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    // If no active cleaners exist, no slots are available\r\n    if (!activeCleaners || activeCleaners.length === 0) {\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    const totalCleaners = activeCleaners.length;\r\n\r\n    // Query bookings for the specified date that might overlap\r\n    // We need to check for bookings where:\r\n    // (booking_start_time < new_end_time) AND (booking_end_time > new_start_time)\r\n    // Only consider pending or confirmed bookings (exclude cancelled/completed)\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration, preferred_cleaner_id, preferred_cleaner_ids, number_of_cleaners')\r\n      .eq('service_date', serviceDate)\r\n      .in('status', ['pending', 'confirmed']);\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking bookings:', bookingsError);\r\n      // If we can't check bookings, assume available (optimistic approach)\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      // No bookings for this date, all cleaners are available\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Track which cleaners are booked (by ID)\r\n    const bookedCleanerIds = new Set<string>();\r\n    \r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n      \r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number' \r\n          ? booking.service_duration \r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        // There's an overlap\r\n        // Check preferred_cleaner_ids first (new multi-cleaner support)\r\n        if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n          // Multiple cleaners are assigned\r\n          booking.preferred_cleaner_ids.forEach((cleanerId: string) => {\r\n            if (cleanerId) bookedCleanerIds.add(cleanerId);\r\n          });\r\n        } else if (booking.preferred_cleaner_id) {\r\n          // Single cleaner assigned (backward compatibility)\r\n          bookedCleanerIds.add(booking.preferred_cleaner_id);\r\n        } else {\r\n          // If no preferred cleaner, use number_of_cleaners to count generic cleaner slots\r\n          // This handles bookings without specific cleaner assignments\r\n          const numCleaners = booking.number_of_cleaners || 1;\r\n          // We don't add specific IDs here, but count them in bookingsWithoutPreferredCleaner\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate available cleaners\r\n    // Count bookings without preferred cleaners (generic assignments)\r\n    // These use number_of_cleaners to determine how many cleaner slots are taken\r\n    const bookingsWithoutPreferredCleaner = bookings.filter(\r\n      (b) => {\r\n        const hasPreferredCleaners = (b.preferred_cleaner_ids && Array.isArray(b.preferred_cleaner_ids) && b.preferred_cleaner_ids.length > 0) || b.preferred_cleaner_id;\r\n        if (hasPreferredCleaners) return false;\r\n        \r\n        // Check for time overlap\r\n        const [hours, mins] = b.service_time.split(':').slice(0, 2).map(Number);\r\n        const start = hours * 60 + mins;\r\n        const duration = Math.round((typeof b.service_duration === 'number' ? b.service_duration : parseFloat(b.service_duration || '0')) * 60);\r\n        const end = start + duration;\r\n        return newStartTimeMinutes < end && newEndTimeMinutes > start;\r\n      }\r\n    ).reduce((sum, b) => {\r\n      // Sum up the number_of_cleaners for bookings without preferred cleaners\r\n      return sum + (b.number_of_cleaners || 1);\r\n    }, 0);\r\n\r\n    const unavailableCleaners = bookedCleanerIds.size + bookingsWithoutPreferredCleaner;\r\n    const availableCleanersCount = Math.max(0, totalCleaners - unavailableCleaners);\r\n\r\n    return {\r\n      available: availableCleanersCount > 0,\r\n      availableCleanersCount,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking cleaner availability:', error);\r\n    // On error, assume unavailable for safety\r\n    return { available: false, availableCleanersCount: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Check availability for all time slots for a given date\r\n */\r\nexport async function checkAvailabilityForAllSlots(\r\n  serviceDate: string,\r\n  workingHours: WorkingHour[],\r\n  serviceDuration: number\r\n): Promise<Record<string, TimeSlotAvailability>> {\r\n  const availability: Record<string, TimeSlotAvailability> = {};\r\n\r\n  // Check availability for each time slot in parallel\r\n  // Use the service duration provided (either from form data or calculated)\r\n  const promises = workingHours.map(async (hour) => {\r\n    // Use the provided service duration, not the working hour's duration\r\n    // The working hour duration is just the slot length, but the actual booking\r\n    // will use the service duration from the form\r\n    const slotAvailability = await checkCleanerAvailabilityForSlot(\r\n      serviceDate,\r\n      hour.start_time,\r\n      serviceDuration\r\n    );\r\n    return { time: hour.start_time, availability: slotAvailability };\r\n  });\r\n\r\n  const results = await Promise.all(promises);\r\n  \r\n  results.forEach(({ time, availability: avail }) => {\r\n    availability[time] = avail;\r\n  });\r\n\r\n  return availability;\r\n}\r\n\r\n/**\r\n * Validate discount code\r\n */\r\nexport async function validateDiscountCode(code: string, subtotal: number): Promise<{\r\n  valid: boolean;\r\n  discountAmount: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (!code || !code.trim()) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('discount_codes')\r\n      .select('*')\r\n      .eq('code', code.trim().toUpperCase())\r\n      .eq('is_active', true)\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      return { valid: false, discountAmount: 0, error: 'Invalid discount code' };\r\n    }\r\n\r\n    // Check validity dates\r\n    const now = new Date();\r\n    const validFrom = new Date(data.valid_from);\r\n    const validUntil = new Date(data.valid_until);\r\n\r\n    if (now < validFrom || now > validUntil) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has expired' };\r\n    }\r\n\r\n    // Check max uses\r\n    if (data.max_uses && data.used_count >= data.max_uses) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has reached maximum uses' };\r\n    }\r\n\r\n    // Check min purchase amount\r\n    if (data.min_purchase_amount && subtotal < data.min_purchase_amount) {\r\n      return { \r\n        valid: false, \r\n        discountAmount: 0, \r\n        error: `Minimum purchase amount of R${data.min_purchase_amount} required` \r\n      };\r\n    }\r\n\r\n    // Calculate discount amount\r\n    let discountAmount = 0;\r\n    if (data.discount_type === 'percentage') {\r\n      discountAmount = (subtotal * data.discount_value) / 100;\r\n      if (data.max_discount_amount && discountAmount > data.max_discount_amount) {\r\n        discountAmount = data.max_discount_amount;\r\n      }\r\n    } else {\r\n      discountAmount = data.discount_value;\r\n    }\r\n\r\n    // Ensure discount doesn't exceed subtotal\r\n    discountAmount = Math.min(discountAmount, subtotal);\r\n\r\n    return { valid: true, discountAmount };\r\n  } catch (error) {\r\n    console.error('Error validating discount code:', error);\r\n    return { valid: false, discountAmount: 0, error: 'Error validating discount code' };\r\n  }\r\n}\r\n\r\n/**\r\n * Create booking draft (before payment)\r\n */\r\nexport async function createBookingDraft(formData: BookingFormData): Promise<{\r\n  success: boolean;\r\n  bookingId?: string;\r\n  bookingIds?: string[];\r\n  totalAmount?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current user if logged in\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n    const userId = user?.id || null;\r\n\r\n    // Get service name\r\n    const { data: service } = await supabase\r\n      .from('services')\r\n      .select('name')\r\n      .eq('id', formData.serviceId)\r\n      .single();\r\n\r\n    if (!service) {\r\n      return { success: false, error: 'Service not found' };\r\n    }\r\n\r\n    // Validate that the selected frequency is valid for this service\r\n    if (!isValidFrequencyForService(service.name, formData.cleaningFrequency)) {\r\n      return { \r\n        success: false, \r\n        error: `Recurring bookings are only available for Standard Cleaning and Airbnb Cleaning services. Selected service: ${service.name}` \r\n      };\r\n    }\r\n\r\n    // Calculate pricing\r\n    const priceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount: 0, // Will calculate discount in next step\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Apply discount code if provided\r\n    let discountAmount = 0;\r\n    if (formData.discountCode) {\r\n      const discountValidation = await validateDiscountCode(\r\n        formData.discountCode,\r\n        priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount\r\n      );\r\n      if (discountValidation.valid) {\r\n        discountAmount = discountValidation.discountAmount;\r\n      }\r\n    }\r\n\r\n    // Recalculate with discount\r\n    const finalPriceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount,\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Determine if this is a recurring booking\r\n    const isRecurring = formData.cleaningFrequency !== 'one-time';\r\n\r\n    // Calculate booking dates based on frequency\r\n    const startDate = new Date(formData.serviceDate);\r\n    const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n\r\n    // Calculate next booking date for recurring bookings\r\n    let nextBookingDate: Date | null = null;\r\n    if (isRecurring && bookingDates.length > 0) {\r\n      const lastDate = bookingDates[bookingDates.length - 1];\r\n      nextBookingDate = calculateNextBookingDate(lastDate, formData.cleaningFrequency);\r\n    }\r\n\r\n    // Create bookings for all dates\r\n    const bookingsToCreate: BookingCreateInput[] = [];\r\n\r\n    for (let i = 0; i < bookingDates.length; i++) {\r\n      const bookingDate = bookingDates[i];\r\n      const bookingNumber = generateBookingNumber();\r\n\r\n      // Tip is only applied to the first booking in a recurring series (one-time payment)\r\n      const tipAmount = (i === 0) ? (formData.tipAmount || 0) : 0;\r\n      \r\n      const bookingInput: BookingCreateInput = {\r\n        booking_number: bookingNumber,\r\n        customer_first_name: formData.customerFirstName,\r\n        customer_last_name: formData.customerLastName,\r\n        customer_email: formData.customerEmail,\r\n        customer_phone: formData.customerPhone,\r\n        service_id: formData.serviceId,\r\n        service_type: service.name,\r\n        bedrooms: formData.bedrooms,\r\n        bathrooms: formData.bathrooms,\r\n        additional_services: formData.additionalServices,\r\n        cleaning_equipment: formData.cleaningEquipment,\r\n        preferred_cleaner_ids: formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n          ? formData.preferredCleanerIds \r\n          : null,\r\n        preferred_cleaner_id: formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n          ? formData.preferredCleanerIds[0] \r\n          : null, // Backward compatibility: set to first cleaner\r\n        cleaning_frequency: formData.cleaningFrequency,\r\n        service_date: formatDateForDB(bookingDate),\r\n        service_time: formData.serviceTime,\r\n        service_duration: formData.serviceDuration,\r\n        service_address: formData.serviceAddress,\r\n        service_apt_unit: formData.serviceAptUnit || null,\r\n        service_suburb: formData.serviceSuburb,\r\n        service_city: formData.serviceCity,\r\n        special_instructions: formData.specialInstructions || null,\r\n        tip_amount: tipAmount,\r\n        base_price: finalPriceBreakdown.basePrice,\r\n        additional_services_price: finalPriceBreakdown.additionalServicesPrice,\r\n        equipment_supply_price: finalPriceBreakdown.equipmentSupplyPrice,\r\n        number_of_cleaners: formData.numberOfCleaners || 1,\r\n        additional_cleaners_price: finalPriceBreakdown.additionalCleanersPrice,\r\n        frequency_discount_percent: finalPriceBreakdown.frequencyDiscountPercent,\r\n        frequency_discount_amount: finalPriceBreakdown.frequencyDiscountAmount,\r\n        subtotal: finalPriceBreakdown.subtotal,\r\n        service_fee: finalPriceBreakdown.serviceFee,\r\n        total_amount: finalPriceBreakdown.totalAmount + tipAmount,\r\n        discount_code: formData.discountCode || null,\r\n        discount_amount: discountAmount,\r\n        referral_code: formData.referralCode || null,\r\n        amount_paid: 0,\r\n        payment_status: 'pending',\r\n        status: 'pending',\r\n        user_id: userId,\r\n        parent_booking_id: null, // Will be updated after first booking is created\r\n        is_recurring: isRecurring,\r\n        recurrence_status: isRecurring ? 'active' : undefined,\r\n        next_booking_date: i === 0 && isRecurring && nextBookingDate ? formatDateForDB(nextBookingDate) : null,\r\n      };\r\n\r\n      bookingsToCreate.push(bookingInput);\r\n    }\r\n\r\n    // Insert all bookings\r\n    const { data: insertedBookings, error } = await supabase\r\n      .from('bookings')\r\n      .insert(bookingsToCreate)\r\n      .select('id, total_amount');\r\n\r\n    if (error) {\r\n      console.error('Error creating booking drafts:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!insertedBookings || insertedBookings.length === 0) {\r\n      return { success: false, error: 'Failed to create bookings' };\r\n    }\r\n\r\n    // Update parent_booking_id for subsequent bookings if there are multiple\r\n    if (insertedBookings.length > 1 && isRecurring) {\r\n      const firstBookingId = insertedBookings[0].id;\r\n      const subsequentBookingIds = insertedBookings.slice(1).map(b => b.id);\r\n      \r\n      // Update all subsequent bookings to reference the first one\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({ parent_booking_id: firstBookingId })\r\n        .in('id', subsequentBookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating parent_booking_id:', updateError);\r\n        // Don't fail, but log the error\r\n      }\r\n    }\r\n\r\n    // Calculate total amount\r\n    const totalAmount = insertedBookings.reduce((sum, booking) => sum + Number(booking.total_amount), 0);\r\n    const bookingIds = insertedBookings.map(booking => booking.id);\r\n\r\n    // For backward compatibility, also return single bookingId\r\n    const bookingId = bookingIds[0];\r\n\r\n    // If multiple bookings, return array; otherwise return single ID for backward compatibility\r\n    if (bookingIds.length > 1) {\r\n      return { \r\n        success: true, \r\n        bookingIds,\r\n        totalAmount,\r\n        bookingId // Keep for backward compatibility\r\n      };\r\n    }\r\n\r\n    return { \r\n      success: true, \r\n      bookingId,\r\n      bookingIds,\r\n      totalAmount\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error creating booking draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize payment for booking(s)\r\n * Accepts either a single bookingId or an array of bookingIds\r\n */\r\nexport async function initializePaymentForBooking(\r\n  bookingIdOrIds: string | string[]\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const bookingIds = Array.isArray(bookingIdOrIds) ? bookingIdOrIds : [bookingIdOrIds];\r\n\r\n    // Get all booking details\r\n    const { data: bookings, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (fetchError || !bookings || bookings.length === 0) {\r\n      return { success: false, error: 'Booking(s) not found' };\r\n    }\r\n\r\n    // Check if all bookings are in pending status\r\n    const nonPendingBookings = bookings.filter(b => b.payment_status !== 'pending');\r\n    if (nonPendingBookings.length > 0) {\r\n      return { success: false, error: 'Some bookings are not in pending payment status' };\r\n    }\r\n\r\n    // Calculate total amount from all bookings (including tip)\r\n    // Note: total_amount in database now includes tip for new bookings\r\n    // For backward compatibility with existing bookings that might not have tip in total_amount, \r\n    // we check and add tip_amount if it's missing\r\n    const totalAmount = bookings.reduce((sum, booking) => {\r\n      const bookingTotal = Number(booking.total_amount) || 0;\r\n      const tipAmount = Number(booking.tip_amount) || 0;\r\n      const baseTotal = Number(booking.subtotal || 0) + Number(booking.service_fee || 0);\r\n      \r\n      // Check if tip is already included in total_amount\r\n      // If total_amount equals baseTotal exactly, then tip is not included, so add it\r\n      // Otherwise, total_amount already includes tip\r\n      if (tipAmount > 0 && Math.abs(bookingTotal - baseTotal) < 0.01) {\r\n        // Tip is not included in total_amount (backward compatibility case)\r\n        return sum + bookingTotal + tipAmount;\r\n      }\r\n      // Tip is already included in total_amount (new bookings)\r\n      return sum + bookingTotal;\r\n    }, 0);\r\n    \r\n    // Use the first booking's email and details for payment\r\n    const firstBooking = bookings[0];\r\n    const reference = firstBooking.paystack_reference || `${firstBooking.booking_number}${Date.now()}`;\r\n    \r\n    // Initialize Paystack payment with total amount\r\n    const paymentResponse = await initializePayment(\r\n      firstBooking.customer_email,\r\n      totalAmount,\r\n      reference,\r\n      {\r\n        booking_ids: bookingIds,\r\n        booking_id: firstBooking.id, // Keep for backward compatibility\r\n        booking_number: firstBooking.booking_number,\r\n        customer_email: firstBooking.customer_email,\r\n      }\r\n    );\r\n\r\n    if (!paymentResponse.status) {\r\n      return { success: false, error: paymentResponse.message || 'Failed to initialize payment' };\r\n    }\r\n\r\n    // Update all bookings with the same Paystack reference\r\n    const { error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        paystack_reference: reference,\r\n      })\r\n      .in('id', bookingIds);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating bookings with Paystack reference:', updateError);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentResponse.data.authorization_url,\r\n      reference: paymentResponse.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing payment:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get booking by ID\r\n */\r\nexport async function getBooking(bookingId: string): Promise<{\r\n  success: boolean;\r\n  booking?: any;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners for selection\r\n * Optionally filter by service area/suburb\r\n */\r\nexport async function getAvailableCleaners(serviceSuburb?: string): Promise<{\r\n  success: boolean;\r\n  cleaners?: any[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Build query - only filter by is_available if the column exists\r\n    // First, try to get all active cleaners\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = data || [];\r\n\r\n    // Filter by is_available if the column exists (client-side filter as fallback)\r\n    cleaners = cleaners.filter((cleaner) => {\r\n      // If is_available column doesn't exist or is null/undefined, include the cleaner\r\n      // Otherwise, only include if is_available is true\r\n      return cleaner.is_available !== false;\r\n    });\r\n\r\n    // Filter by area if suburb is provided\r\n    // Since PostgreSQL array contains is complex in Supabase, we filter client-side\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        // If cleaner has no areas specified, include them (they serve all areas)\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true;\r\n        }\r\n        // Check if any area matches the suburb (case-insensitive partial match)\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    return { success: true, cleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a cleaner is available for a specific day of the week\r\n * dayOfWeek: 0 = Sunday, 1 = Monday, ..., 6 = Saturday\r\n */\r\nexport async function isCleanerAvailableForDay(cleaner: any, dayOfWeek: number): Promise<boolean> {\r\n  const dayMap: Record<number, keyof typeof cleaner> = {\r\n    0: 'available_sunday',\r\n    1: 'available_monday',\r\n    2: 'available_tuesday',\r\n    3: 'available_wednesday',\r\n    4: 'available_thursday',\r\n    5: 'available_friday',\r\n    6: 'available_saturday',\r\n  };\r\n\r\n  const dayField = dayMap[dayOfWeek];\r\n  return cleaner[dayField] !== false && cleaner.is_available !== false;\r\n}\r\n\r\n/**\r\n * Check if a cleaner has a booking conflict for a specific date and time slot\r\n */\r\nexport async function checkCleanerBookingConflict(\r\n  cleanerId: string,\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Query bookings for this cleaner on the specified date\r\n    const { data: bookings, error } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration')\r\n      .eq('preferred_cleaner_id', cleanerId)\r\n      .eq('service_date', serviceDate)\r\n      .in('status', ['pending', 'confirmed']);\r\n\r\n    if (error) {\r\n      console.error('Error checking booking conflicts:', error);\r\n      return false; // Assume no conflict on error\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      return false; // No bookings, no conflict\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n\r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number'\r\n          ? booking.service_duration\r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        return true; // Conflict found\r\n      }\r\n    }\r\n\r\n    return false; // No conflicts\r\n  } catch (error) {\r\n    console.error('Unexpected error checking booking conflict:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate reliability score for a cleaner (server-side wrapper)\r\n * This calls the database function if available, otherwise calculates client-side\r\n */\r\nexport async function calculateCleanerReliabilityScore(cleanerId: string): Promise<number> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Try to call the database function\r\n    const { data, error } = await supabase.rpc('calculate_cleaner_reliability_score', {\r\n      cleaner_id: cleanerId,\r\n    });\r\n\r\n    if (!error && data !== null) {\r\n      return parseFloat(data.toString());\r\n    }\r\n\r\n    // Fallback: fetch cleaner and calculate client-side\r\n    const { data: cleaner, error: fetchError } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('id', cleanerId)\r\n      .single();\r\n\r\n    if (fetchError || !cleaner) {\r\n      return 50.0; // Default score\r\n    }\r\n\r\n    return calculateReliabilityScore(cleaner as Cleaner);\r\n  } catch (error) {\r\n    console.error('Error calculating reliability score:', error);\r\n    return 50.0; // Default score on error\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners with enhanced filtering criteria\r\n * Filters by: Location, Availability, Booking conflicts\r\n * Sorts by: Reliability Score, Rating\r\n */\r\nexport async function getAvailableCleanersWithCriteria(params: {\r\n  serviceSuburb?: string;\r\n  serviceDate?: string;\r\n  serviceTime?: string;\r\n  serviceDuration?: number;\r\n  minRating?: number;\r\n  minReliabilityScore?: number;\r\n}): Promise<{\r\n  success: boolean;\r\n  cleaners?: CleanerWithAvailability[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const {\r\n      serviceSuburb,\r\n      serviceDate,\r\n      serviceTime,\r\n      serviceDuration = 3,\r\n      minRating = 0,\r\n      minReliabilityScore = 0,\r\n    } = params;\r\n\r\n    // Build base query\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query.order('reliability_score', { ascending: false, nullsFirst: false })\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = (data || []) as Cleaner[];\r\n\r\n    // Filter by is_available\r\n    cleaners = cleaners.filter((cleaner) => cleaner.is_available !== false);\r\n\r\n    // Filter by location (suburb)\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true; // Serve all areas\r\n        }\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Filter by day of week availability if date is provided\r\n    if (serviceDate) {\r\n      const date = new Date(serviceDate);\r\n      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        const dayMap: Record<number, keyof Cleaner> = {\r\n          0: 'available_sunday',\r\n          1: 'available_monday',\r\n          2: 'available_tuesday',\r\n          3: 'available_wednesday',\r\n          4: 'available_thursday',\r\n          5: 'available_friday',\r\n          6: 'available_saturday',\r\n        };\r\n        const dayField = dayMap[dayOfWeek];\r\n        return cleaner[dayField] !== false;\r\n      });\r\n    }\r\n\r\n    // Filter by minimum rating\r\n    if (minRating > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.rating || 0) >= minRating);\r\n    }\r\n\r\n    // Filter by minimum reliability score\r\n    if (minReliabilityScore > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.reliability_score || 0) >= minReliabilityScore);\r\n    }\r\n\r\n    // Enrich cleaners with availability and booking conflict information\r\n    const enrichedCleaners: CleanerWithAvailability[] = await Promise.all(\r\n      cleaners.map(async (cleaner) => {\r\n        let isAvailableForSlot = true;\r\n        let bookingConflict = false;\r\n\r\n        // Check booking conflict if date and time are provided\r\n        if (serviceDate && serviceTime && serviceDuration) {\r\n          bookingConflict = await checkCleanerBookingConflict(\r\n            cleaner.id,\r\n            serviceDate,\r\n            serviceTime,\r\n            serviceDuration\r\n          );\r\n          isAvailableForSlot = !bookingConflict;\r\n        }\r\n\r\n        // Calculate reliability score if not present\r\n        const reliabilityScore = cleaner.reliability_score ?? calculateReliabilityScore(cleaner);\r\n\r\n        return {\r\n          ...cleaner,\r\n          reliability_score: reliabilityScore,\r\n          isAvailableForSlot,\r\n          bookingConflict,\r\n          completionRate: calculateCompletionRate(cleaner),\r\n          onTimeRate: calculateOnTimeRate(cleaner),\r\n        };\r\n      })\r\n    );\r\n\r\n    // Sort by reliability score and rating (already sorted by query, but ensure consistency)\r\n    enrichedCleaners.sort((a, b) => {\r\n      const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n      const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n\r\n    return { success: true, cleaners: enrichedCleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners with criteria:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MA6OsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 1713, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/submit/%5BserviceSlug%5D/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useParams, useRouter, useSearchParams } from 'next/navigation';\r\nimport { useState, useMemo, useEffect, useRef, Suspense } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { Button } from '@/components/ui/button';\r\nimport { ArrowLeft } from 'lucide-react';\r\nimport { useBookingFormContext } from '../../book/context/BookingFormContext';\r\nimport { Step3ContactReview } from '../../book/components/Step3ContactReview';\r\nimport { createBookingDraft, initializePaymentForBooking, validateDiscountCode } from '../../book/actions';\r\nimport { getServices, getAdditionalServices } from '../../quote/actions';\r\nimport { getPricingRulesClient } from '../../book/actions-client';\r\nimport { calculatePriceBreakdownClient } from '@/lib/pricing/calculator-client';\r\nimport { findServiceBySlug } from '@/lib/utils/slug';\r\nimport { toast } from 'sonner';\r\nimport { PriceBreakdown } from '@/types/booking';\r\n\r\nfunction BookingSubmitPageWithSlugContent() {\r\n  const params = useParams();\r\n  const router = useRouter();\r\n  const searchParams = useSearchParams();\r\n  const serviceSlug = params.serviceSlug as string;\r\n  \r\n  const {\r\n    formData,\r\n    updateFormData,\r\n    validateCurrentStep,\r\n    previousStep,\r\n    getDiscountAmount,\r\n    setDiscountAmount: setDiscountAmountStorage,\r\n    setServicesForSlug,\r\n  } = useBookingFormContext();\r\n\r\n  // Initialize to 0 to match server render and prevent hydration mismatch\r\n  const [discountAmount, setDiscountAmount] = useState<number>(0);\r\n  const [isProcessing, setIsProcessing] = useState(false);\r\n  const [currentBookingId, setCurrentBookingId] = useState<string | null>(null);\r\n\r\n  // Track previous serviceId to detect changes\r\n  const previousServiceIdRef = useRef<string | undefined>(formData.serviceId);\r\n\r\n  // Fetch services to validate slug\r\n  const { data: services = [] } = useQuery({\r\n    queryKey: ['services'],\r\n    queryFn: getServices,\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Set services in hook for slug generation\r\n  useEffect(() => {\r\n    if (services.length > 0) {\r\n      setServicesForSlug(services);\r\n    }\r\n  }, [services, setServicesForSlug]);\r\n\r\n  // Read and store referral code from URL parameter\r\n  useEffect(() => {\r\n    const refCode = searchParams.get('ref');\r\n    if (refCode && !formData.referralCode) {\r\n      // Store referral code in form data\r\n      updateFormData({ referralCode: refCode });\r\n      // Also store in localStorage for persistence\r\n      if (typeof window !== 'undefined') {\r\n        localStorage.setItem('shalean_referral_code', refCode);\r\n      }\r\n    }\r\n  }, [searchParams, formData.referralCode, updateFormData]);\r\n\r\n  // Validate service slug and set service in form data\r\n  useEffect(() => {\r\n    if (services.length > 0) {\r\n      if (!serviceSlug) {\r\n        // No slug, redirect to details\r\n        router.replace('/booking/details');\r\n        return;\r\n      }\r\n      \r\n      const service = findServiceBySlug(services, serviceSlug);\r\n      if (!service) {\r\n        // Invalid slug, redirect to details\r\n        toast.error('Invalid service selected');\r\n        router.replace('/booking/details');\r\n        return;\r\n      }\r\n\r\n      // Ensure service is set in form data (don't redirect if not set - it will be set)\r\n      if (!formData.serviceId || formData.serviceId !== service.id) {\r\n        updateFormData({ serviceId: service.id });\r\n      }\r\n    }\r\n    // Only run when services load or slug changes, not on every formData change\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [serviceSlug, services.length]);\r\n\r\n  // Sync discount amount from localStorage after mount to prevent hydration mismatch\r\n  useEffect(() => {\r\n    const updateDiscount = () => {\r\n      setDiscountAmount(getDiscountAmount());\r\n    };\r\n    // Listen for custom event when discount is updated\r\n    window.addEventListener('discountUpdated', updateDiscount);\r\n    // Initial load - read from localStorage after mount\r\n    updateDiscount();\r\n    return () => {\r\n      window.removeEventListener('discountUpdated', updateDiscount);\r\n    };\r\n  }, [getDiscountAmount]);\r\n\r\n  // Reset service-specific fields when service changes\r\n  useEffect(() => {\r\n    const previousServiceId = previousServiceIdRef.current;\r\n    const currentServiceId = formData.serviceId;\r\n\r\n    // Only reset if service actually changed (not on initial load)\r\n    if (previousServiceId && previousServiceId !== currentServiceId) {\r\n      updateFormData({\r\n        additionalServices: [],\r\n        bedrooms: '0',\r\n        bathrooms: '1',\r\n        carpetTypes: [],\r\n        roomStatus: '',\r\n        numberOfFittedRooms: '',\r\n        numberOfLooseCarpets: '',\r\n        cleaningEquipment: '',\r\n        serviceDate: '',\r\n        serviceTime: '',\r\n        serviceDuration: 3.5,\r\n        discountCode: '',\r\n      });\r\n      setDiscountAmount(0);\r\n    }\r\n\r\n    // Update the ref for next comparison\r\n    previousServiceIdRef.current = currentServiceId;\r\n  }, [formData.serviceId, updateFormData]);\r\n\r\n  // Fetch and cache pricing rules\r\n  const { data: pricingRules = [] } = useQuery({\r\n    queryKey: ['pricing-rules'],\r\n    queryFn: getPricingRulesClient,\r\n    staleTime: 10 * 60 * 1000,\r\n  });\r\n\r\n  // Fetch additional services based on selected service\r\n  const { data: additionalServices = [] } = useQuery({\r\n    queryKey: ['additional-services', formData.serviceId],\r\n    queryFn: () => getAdditionalServices(formData.serviceId || undefined),\r\n    enabled: true,\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  const selectedService = services.find((s) => s.id === formData.serviceId);\r\n\r\n  // Check if selected service is carpet cleaning\r\n  const isCarpetCleaning = selectedService?.name.toLowerCase().includes('carpet') ?? false;\r\n\r\n  // Calculate price breakdown instantly using cached pricing rules\r\n  // This is memoized and recalculates automatically when dependencies change\r\n  // Updates in real-time when cleaningFrequency changes (weekly, bi-weekly, monthly, one-time)\r\n  const priceBreakdown = useMemo<PriceBreakdown>(() => {\r\n    const hasRequiredData = isCarpetCleaning\r\n      ? formData.serviceId && pricingRules.length > 0\r\n      : formData.serviceId && formData.bedrooms && formData.bathrooms && pricingRules.length > 0;\r\n\r\n    if (!hasRequiredData) {\r\n      return {\r\n        basePrice: 0,\r\n        bedroomsPrice: 0,\r\n        bathroomsPrice: 0,\r\n        fittedRoomsPrice: 0,\r\n        looseCarpetsPrice: 0,\r\n        additionalServicesPrice: 0,\r\n        equipmentSupplyPrice: 0,\r\n        subtotal: 0,\r\n        frequencyDiscountPercent: 0,\r\n        frequencyDiscountAmount: 0,\r\n        discountAmount,\r\n        serviceFee: 0,\r\n        totalAmount: 0,\r\n      };\r\n    }\r\n\r\n    const relevantAdditionalServiceIds = formData.additionalServices.filter(serviceId =>\r\n      additionalServices.some(s => s.id === serviceId)\r\n    );\r\n\r\n    return calculatePriceBreakdownClient(\r\n      pricingRules,\r\n      formData.serviceId,\r\n      formData.bedrooms || '0',\r\n      formData.bathrooms || '1',\r\n      relevantAdditionalServiceIds,\r\n      formData.cleaningFrequency,\r\n      discountAmount,\r\n      formData.numberOfFittedRooms || '',\r\n      formData.numberOfLooseCarpets || '',\r\n      isCarpetCleaning,\r\n      selectedService?.name,\r\n      formData.cleaningEquipment,\r\n      formData.numberOfCleaners || 1\r\n    );\r\n  }, [\r\n    pricingRules,\r\n    formData.serviceId,\r\n    formData.bedrooms,\r\n    formData.bathrooms,\r\n    // Use JSON.stringify for array dependency to ensure proper change detection\r\n    JSON.stringify(formData.additionalServices),\r\n    formData.cleaningFrequency,\r\n    formData.numberOfFittedRooms,\r\n    formData.numberOfLooseCarpets,\r\n    formData.cleaningEquipment, // Track equipment selection for price updates\r\n    formData.numberOfCleaners, // Track number of cleaners for price updates\r\n    discountAmount,\r\n    isCarpetCleaning,\r\n    additionalServices,\r\n    selectedService?.name,\r\n  ]);\r\n\r\n  const handleValidateDiscountCode = async (code: string) => {\r\n    if (!code.trim()) {\r\n      toast.error('Please enter a discount code');\r\n      return;\r\n    }\r\n\r\n    const subtotal = priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount;\r\n    const result = await validateDiscountCode(code, subtotal);\r\n\r\n    if (result.valid) {\r\n      updateFormData({ discountCode: code });\r\n      setDiscountAmount(result.discountAmount);\r\n      setDiscountAmountStorage(result.discountAmount);\r\n      window.dispatchEvent(new Event('discountUpdated'));\r\n      toast.success('Discount code applied successfully!');\r\n    } else {\r\n      toast.error(result.error || 'Invalid discount code');\r\n    }\r\n  };\r\n\r\n  const handleProceedToPayment = async () => {\r\n    const validation = validateCurrentStep();\r\n    if (!validation.valid) {\r\n      validation.errors.forEach((error) => toast.error(error));\r\n      return;\r\n    }\r\n\r\n    setIsProcessing(true);\r\n\r\n    try {\r\n      const draftResult = await createBookingDraft(formData);\r\n\r\n      if (!draftResult.success || (!draftResult.bookingId && !draftResult.bookingIds)) {\r\n        toast.error(draftResult.error || 'Failed to create booking');\r\n        setIsProcessing(false);\r\n        return;\r\n      }\r\n\r\n      // Use bookingIds if available (for recurring bookings), otherwise use single bookingId\r\n      const bookingIds = draftResult.bookingIds || (draftResult.bookingId ? [draftResult.bookingId] : []);\r\n      setCurrentBookingId(bookingIds[0]);\r\n\r\n      // Initialize payment (pass array or single ID)\r\n      const paymentResult = await initializePaymentForBooking(bookingIds.length > 1 ? bookingIds : bookingIds[0]);\r\n\r\n      if (!paymentResult.success || !paymentResult.authorizationUrl) {\r\n        toast.error(paymentResult.error || 'Failed to initialize payment');\r\n        setIsProcessing(false);\r\n        return;\r\n      }\r\n\r\n      window.location.href = paymentResult.authorizationUrl;\r\n    } catch (error) {\r\n      console.error('Error processing payment:', error);\r\n      toast.error('An unexpected error occurred. Please try again.');\r\n      setIsProcessing(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className=\"bg-white rounded-xl p-6 max-w-[576px] mx-auto\">\r\n        <Step3ContactReview\r\n          formData={formData}\r\n          priceBreakdown={priceBreakdown}\r\n          updateFormData={updateFormData}\r\n          onValidateDiscountCode={handleValidateDiscountCode}\r\n          onProceedToPayment={handleProceedToPayment}\r\n          isProcessing={isProcessing}\r\n        />\r\n      </div>\r\n\r\n      {/* Navigation Buttons */}\r\n      <div className=\"flex justify-between max-w-[576px] mx-auto mt-6\">\r\n        <Button \r\n          variant=\"outline\" \r\n          onClick={() => {\r\n            if (serviceSlug) {\r\n              const refCode = formData.referralCode || searchParams.get('ref');\r\n              const backUrl = refCode \r\n                ? `/booking/worker/${serviceSlug}?ref=${refCode}`\r\n                : `/booking/worker/${serviceSlug}`;\r\n              router.push(backUrl);\r\n            } else {\r\n              previousStep();\r\n            }\r\n          }}\r\n        >\r\n          <ArrowLeft className=\"w-4 h-4 mr-2\" />\r\n          Back\r\n        </Button>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default function BookingSubmitPageWithSlug() {\r\n  return (\r\n    <Suspense fallback={\r\n      <div className=\"flex items-center justify-center py-8\">\r\n        <div className=\"text-center\">\r\n          <p className=\"text-muted-foreground\">Loading...</p>\r\n        </div>\r\n      </div>\r\n    }>\r\n      <BookingSubmitPageWithSlugContent />\r\n    </Suspense>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":"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"}}]
}