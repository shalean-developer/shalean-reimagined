{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (\r\n  <div ref={ref} className={cn(\"rounded-lg border bg-card text-card-foreground shadow-sm\", className)} {...props} />\r\n));\r\nCard.displayName = \"Card\";\r\n\r\nconst CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex flex-col space-y-1.5 p-6\", className)} {...props} />\r\n  ),\r\n);\r\nCardHeader.displayName = \"CardHeader\";\r\n\r\nconst CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <h3 ref={ref} className={cn(\"text-2xl font-semibold leading-none tracking-tight\", className)} {...props} />\r\n  ),\r\n);\r\nCardTitle.displayName = \"CardTitle\";\r\n\r\nconst CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <p ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\r\n  ),\r\n);\r\nCardDescription.displayName = \"CardDescription\";\r\n\r\nconst CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />,\r\n);\r\nCardContent.displayName = \"CardContent\";\r\n\r\nconst CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex items-center p-6 pt-0\", className)} {...props} />\r\n  ),\r\n);\r\nCardFooter.displayName = \"CardFooter\";\r\n\r\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,2KAAgB,MAAuD,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC5G,6LAAC;QAAI,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,4DAA4D;QAAa,GAAG,KAAK;;;;;;;AAEhH,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,2KAAgB,OACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,6LAAC;QAAI,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;;AAGvF,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,2KAAgB,OAChC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,6LAAC;QAAG,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,sDAAsD;QAAa,GAAG,KAAK;;;;;;;AAG3G,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,2KAAgB,OACtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,6LAAC;QAAE,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;;AAGrF,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,2KAAgB,OAClC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAAQ,6LAAC;QAAI,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,YAAY;QAAa,GAAG,KAAK;;;;;;;AAElG,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,2KAAgB,QACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,6LAAC;QAAI,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,8BAA8B;QAAa,GAAG,KAAK;;;;;;;AAGpF,WAAW,WAAW,GAAG"}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/label.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as LabelPrimitive from \"@radix-ui/react-label\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst labelVariants = cva(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\");\r\n\r\nconst Label = React.forwardRef<\r\n  React.ElementRef<typeof LabelPrimitive.Root>,\r\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>\r\n>(({ className, ...props }, ref) => (\r\n  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />\r\n));\r\nLabel.displayName = LabelPrimitive.Root.displayName;\r\n\r\nexport { Label };\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,gBAAgB,IAAA,0KAAG,EAAC;AAE1B,MAAM,sBAAQ,2KAAgB,MAG5B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,4KAAmB;QAAC,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,iBAAiB;QAAa,GAAG,KAAK;;;;;;;AAErF,MAAM,WAAW,GAAG,4KAAmB,CAAC,WAAW"}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function uploadProfilePicture(\r\n  email: string,\r\n  fileData: string, // base64 encoded string\r\n  fileName: string,\r\n  fileType: string\r\n): Promise<{\r\n  success: boolean;\r\n  url?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate file type\r\n    const validImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\r\n    if (!validImageTypes.includes(fileType)) {\r\n      return { success: false, error: 'Invalid file type. Please upload a JPEG, PNG, or WebP image.' };\r\n    }\r\n\r\n    // Decode base64 data\r\n    const base64Data = fileData.replace(/^data:image\\/\\w+;base64,/, '');\r\n    const buffer = Buffer.from(base64Data, 'base64');\r\n\r\n    // Validate file size (max 5MB)\r\n    const maxSize = 5 * 1024 * 1024; // 5MB in bytes\r\n    if (buffer.length > maxSize) {\r\n      return { success: false, error: 'File size too large. Please upload an image smaller than 5MB.' };\r\n    }\r\n\r\n    // Generate unique filename using email and timestamp\r\n    const fileExt = fileName.split('.').pop() || 'jpg';\r\n    const sanitizedEmail = email.replace(/[^a-zA-Z0-9]/g, '_');\r\n    const uniqueFileName = `${sanitizedEmail}_${Date.now()}.${fileExt}`;\r\n    const filePath = `avatars/${uniqueFileName}`;\r\n\r\n    // Upload to Supabase Storage\r\n    const { data: uploadData, error: uploadError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .upload(filePath, buffer, {\r\n        contentType: fileType,\r\n        upsert: false,\r\n      });\r\n\r\n    if (uploadError) {\r\n      console.error('Error uploading file:', uploadError);\r\n      // If bucket doesn't exist, return helpful error\r\n      if (uploadError.message.includes('not found') || uploadError.message.includes('Bucket')) {\r\n        return { \r\n          success: false, \r\n          error: 'Storage bucket not configured. Please create a \"profile-pictures\" bucket in Supabase Storage.' \r\n        };\r\n      }\r\n      return { success: false, error: uploadError.message };\r\n    }\r\n\r\n    // Get public URL\r\n    const { data: urlData } = supabase.storage\r\n      .from('profile-pictures')\r\n      .getPublicUrl(filePath);\r\n\r\n    return { success: true, url: urlData.publicUrl };\r\n  } catch (error) {\r\n    console.error('Error in uploadProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to upload profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteProfilePicture(email: string, avatarUrl: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Extract file path from URL\r\n    const urlParts = avatarUrl.split('/profile-pictures/');\r\n    if (urlParts.length < 2) {\r\n      return { success: false, error: 'Invalid avatar URL' };\r\n    }\r\n\r\n    const filePath = `avatars/${urlParts[1].split('/').pop()}`;\r\n\r\n    // Delete from storage\r\n    const { error: deleteError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .remove([filePath]);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting file:', deleteError);\r\n      // Don't fail if file doesn't exist\r\n      if (deleteError.message.includes('not found')) {\r\n        return { success: true };\r\n      }\r\n      return { success: false, error: deleteError.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    // If avatar_url is being removed, delete the old file\r\n    if (existingProfile?.avatar_url && data.avatar_url === null) {\r\n      await deleteProfilePicture(email, existingProfile.avatar_url);\r\n    }\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const updateData: any = {\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      // Only update avatar_url if it's provided\r\n      if (data.avatar_url !== undefined) {\r\n        updateData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update(updateData)\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const insertData: any = {\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n      };\r\n\r\n      // Only set avatar_url if it's provided\r\n      if (data.avatar_url) {\r\n        insertData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert(insertData)\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAgyBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function uploadProfilePicture(\r\n  email: string,\r\n  fileData: string, // base64 encoded string\r\n  fileName: string,\r\n  fileType: string\r\n): Promise<{\r\n  success: boolean;\r\n  url?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate file type\r\n    const validImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\r\n    if (!validImageTypes.includes(fileType)) {\r\n      return { success: false, error: 'Invalid file type. Please upload a JPEG, PNG, or WebP image.' };\r\n    }\r\n\r\n    // Decode base64 data\r\n    const base64Data = fileData.replace(/^data:image\\/\\w+;base64,/, '');\r\n    const buffer = Buffer.from(base64Data, 'base64');\r\n\r\n    // Validate file size (max 5MB)\r\n    const maxSize = 5 * 1024 * 1024; // 5MB in bytes\r\n    if (buffer.length > maxSize) {\r\n      return { success: false, error: 'File size too large. Please upload an image smaller than 5MB.' };\r\n    }\r\n\r\n    // Generate unique filename using email and timestamp\r\n    const fileExt = fileName.split('.').pop() || 'jpg';\r\n    const sanitizedEmail = email.replace(/[^a-zA-Z0-9]/g, '_');\r\n    const uniqueFileName = `${sanitizedEmail}_${Date.now()}.${fileExt}`;\r\n    const filePath = `avatars/${uniqueFileName}`;\r\n\r\n    // Upload to Supabase Storage\r\n    const { data: uploadData, error: uploadError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .upload(filePath, buffer, {\r\n        contentType: fileType,\r\n        upsert: false,\r\n      });\r\n\r\n    if (uploadError) {\r\n      console.error('Error uploading file:', uploadError);\r\n      // If bucket doesn't exist, return helpful error\r\n      if (uploadError.message.includes('not found') || uploadError.message.includes('Bucket')) {\r\n        return { \r\n          success: false, \r\n          error: 'Storage bucket not configured. Please create a \"profile-pictures\" bucket in Supabase Storage.' \r\n        };\r\n      }\r\n      return { success: false, error: uploadError.message };\r\n    }\r\n\r\n    // Get public URL\r\n    const { data: urlData } = supabase.storage\r\n      .from('profile-pictures')\r\n      .getPublicUrl(filePath);\r\n\r\n    return { success: true, url: urlData.publicUrl };\r\n  } catch (error) {\r\n    console.error('Error in uploadProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to upload profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteProfilePicture(email: string, avatarUrl: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Extract file path from URL\r\n    const urlParts = avatarUrl.split('/profile-pictures/');\r\n    if (urlParts.length < 2) {\r\n      return { success: false, error: 'Invalid avatar URL' };\r\n    }\r\n\r\n    const filePath = `avatars/${urlParts[1].split('/').pop()}`;\r\n\r\n    // Delete from storage\r\n    const { error: deleteError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .remove([filePath]);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting file:', deleteError);\r\n      // Don't fail if file doesn't exist\r\n      if (deleteError.message.includes('not found')) {\r\n        return { success: true };\r\n      }\r\n      return { success: false, error: deleteError.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    // If avatar_url is being removed, delete the old file\r\n    if (existingProfile?.avatar_url && data.avatar_url === null) {\r\n      await deleteProfilePicture(email, existingProfile.avatar_url);\r\n    }\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const updateData: any = {\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      // Only update avatar_url if it's provided\r\n      if (data.avatar_url !== undefined) {\r\n        updateData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update(updateData)\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const insertData: any = {\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n      };\r\n\r\n      // Only set avatar_url if it's provided\r\n      if (data.avatar_url) {\r\n        insertData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert(insertData)\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MA68BsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 182, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function uploadProfilePicture(\r\n  email: string,\r\n  fileData: string, // base64 encoded string\r\n  fileName: string,\r\n  fileType: string\r\n): Promise<{\r\n  success: boolean;\r\n  url?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate file type\r\n    const validImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\r\n    if (!validImageTypes.includes(fileType)) {\r\n      return { success: false, error: 'Invalid file type. Please upload a JPEG, PNG, or WebP image.' };\r\n    }\r\n\r\n    // Decode base64 data\r\n    const base64Data = fileData.replace(/^data:image\\/\\w+;base64,/, '');\r\n    const buffer = Buffer.from(base64Data, 'base64');\r\n\r\n    // Validate file size (max 5MB)\r\n    const maxSize = 5 * 1024 * 1024; // 5MB in bytes\r\n    if (buffer.length > maxSize) {\r\n      return { success: false, error: 'File size too large. Please upload an image smaller than 5MB.' };\r\n    }\r\n\r\n    // Generate unique filename using email and timestamp\r\n    const fileExt = fileName.split('.').pop() || 'jpg';\r\n    const sanitizedEmail = email.replace(/[^a-zA-Z0-9]/g, '_');\r\n    const uniqueFileName = `${sanitizedEmail}_${Date.now()}.${fileExt}`;\r\n    const filePath = `avatars/${uniqueFileName}`;\r\n\r\n    // Upload to Supabase Storage\r\n    const { data: uploadData, error: uploadError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .upload(filePath, buffer, {\r\n        contentType: fileType,\r\n        upsert: false,\r\n      });\r\n\r\n    if (uploadError) {\r\n      console.error('Error uploading file:', uploadError);\r\n      // If bucket doesn't exist, return helpful error\r\n      if (uploadError.message.includes('not found') || uploadError.message.includes('Bucket')) {\r\n        return { \r\n          success: false, \r\n          error: 'Storage bucket not configured. Please create a \"profile-pictures\" bucket in Supabase Storage.' \r\n        };\r\n      }\r\n      return { success: false, error: uploadError.message };\r\n    }\r\n\r\n    // Get public URL\r\n    const { data: urlData } = supabase.storage\r\n      .from('profile-pictures')\r\n      .getPublicUrl(filePath);\r\n\r\n    return { success: true, url: urlData.publicUrl };\r\n  } catch (error) {\r\n    console.error('Error in uploadProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to upload profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteProfilePicture(email: string, avatarUrl: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Extract file path from URL\r\n    const urlParts = avatarUrl.split('/profile-pictures/');\r\n    if (urlParts.length < 2) {\r\n      return { success: false, error: 'Invalid avatar URL' };\r\n    }\r\n\r\n    const filePath = `avatars/${urlParts[1].split('/').pop()}`;\r\n\r\n    // Delete from storage\r\n    const { error: deleteError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .remove([filePath]);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting file:', deleteError);\r\n      // Don't fail if file doesn't exist\r\n      if (deleteError.message.includes('not found')) {\r\n        return { success: true };\r\n      }\r\n      return { success: false, error: deleteError.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    // If avatar_url is being removed, delete the old file\r\n    if (existingProfile?.avatar_url && data.avatar_url === null) {\r\n      await deleteProfilePicture(email, existingProfile.avatar_url);\r\n    }\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const updateData: any = {\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      // Only update avatar_url if it's provided\r\n      if (data.avatar_url !== undefined) {\r\n        updateData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update(updateData)\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const insertData: any = {\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n      };\r\n\r\n      // Only set avatar_url if it's provided\r\n      if (data.avatar_url) {\r\n        insertData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert(insertData)\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAshCsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { Booking } from '@/types/booking';\r\nimport { Profile, ProfileUpdateInput } from '@/types/profile';\r\nimport { Location, LocationCreateInput, LocationUpdateInput } from '@/types/location';\r\n\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  success: boolean;\r\n  email?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    return { success: true, email: user.email || undefined };\r\n  } catch (error) {\r\n    console.error('Error in getAuthenticatedUser:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get user',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookings(\r\n  email: string,\r\n  phone?: string,\r\n  filter?: 'all' | 'upcoming' | 'completed' | 'cancelled'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .order('service_date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    // Apply status filter\r\n    if (filter && filter !== 'all') {\r\n      if (filter === 'upcoming') {\r\n        query = query.in('status', ['pending', 'confirmed']);\r\n      } else {\r\n        query = query.eq('status', filter);\r\n      }\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, bookings: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerBookingStats(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    total: number;\r\n    upcoming: number;\r\n    completed: number;\r\n    cancelled: number;\r\n    totalSpent: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('bookings')\r\n      .select('status, total_amount, payment_status');\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      total: data?.length || 0,\r\n      upcoming: data?.filter((b) => b.status === 'pending' || b.status === 'confirmed').length || 0,\r\n      completed: data?.filter((b) => b.status === 'completed').length || 0,\r\n      cancelled: data?.filter((b) => b.status === 'cancelled').length || 0,\r\n      totalSpent: data\r\n        ?.filter((b) => b.payment_status === 'paid')\r\n        .reduce((sum, b) => sum + (b.total_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getBookingById(id: string): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerProfile(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, try to get profile from profiles table\r\n    let query = supabase.from('profiles').select('*');\r\n\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data: profileData, error: profileError } = await query.maybeSingle();\r\n\r\n    // If profile exists, return it\r\n    if (profileData && !profileError) {\r\n      return { success: true, profile: profileData };\r\n    }\r\n\r\n    // If no profile exists, derive from most recent booking\r\n    let bookingQuery = supabase\r\n      .from('bookings')\r\n      .select('customer_first_name, customer_last_name, customer_email, customer_phone')\r\n      .order('created_at', { ascending: false })\r\n      .limit(1);\r\n\r\n    if (email && phone) {\r\n      bookingQuery = bookingQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      bookingQuery = bookingQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      bookingQuery = bookingQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    const { data: bookingData, error: bookingError } = await bookingQuery.maybeSingle();\r\n\r\n    if (bookingError || !bookingData) {\r\n      return {\r\n        success: false,\r\n        error: 'No profile or booking found. Please create a booking first.',\r\n      };\r\n    }\r\n\r\n    // Create a profile object from booking data\r\n    const derivedProfile: Profile = {\r\n      id: '', // Will be generated when saved\r\n      email: bookingData.customer_email,\r\n      phone: bookingData.customer_phone || null,\r\n      first_name: bookingData.customer_first_name,\r\n      last_name: bookingData.customer_last_name,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    return { success: true, profile: derivedProfile };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function uploadProfilePicture(\r\n  email: string,\r\n  fileData: string, // base64 encoded string\r\n  fileName: string,\r\n  fileType: string\r\n): Promise<{\r\n  success: boolean;\r\n  url?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate file type\r\n    const validImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\r\n    if (!validImageTypes.includes(fileType)) {\r\n      return { success: false, error: 'Invalid file type. Please upload a JPEG, PNG, or WebP image.' };\r\n    }\r\n\r\n    // Decode base64 data\r\n    const base64Data = fileData.replace(/^data:image\\/\\w+;base64,/, '');\r\n    const buffer = Buffer.from(base64Data, 'base64');\r\n\r\n    // Validate file size (max 5MB)\r\n    const maxSize = 5 * 1024 * 1024; // 5MB in bytes\r\n    if (buffer.length > maxSize) {\r\n      return { success: false, error: 'File size too large. Please upload an image smaller than 5MB.' };\r\n    }\r\n\r\n    // Generate unique filename using email and timestamp\r\n    const fileExt = fileName.split('.').pop() || 'jpg';\r\n    const sanitizedEmail = email.replace(/[^a-zA-Z0-9]/g, '_');\r\n    const uniqueFileName = `${sanitizedEmail}_${Date.now()}.${fileExt}`;\r\n    const filePath = `avatars/${uniqueFileName}`;\r\n\r\n    // Upload to Supabase Storage\r\n    const { data: uploadData, error: uploadError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .upload(filePath, buffer, {\r\n        contentType: fileType,\r\n        upsert: false,\r\n      });\r\n\r\n    if (uploadError) {\r\n      console.error('Error uploading file:', uploadError);\r\n      // If bucket doesn't exist, return helpful error\r\n      if (uploadError.message.includes('not found') || uploadError.message.includes('Bucket')) {\r\n        return { \r\n          success: false, \r\n          error: 'Storage bucket not configured. Please create a \"profile-pictures\" bucket in Supabase Storage.' \r\n        };\r\n      }\r\n      return { success: false, error: uploadError.message };\r\n    }\r\n\r\n    // Get public URL\r\n    const { data: urlData } = supabase.storage\r\n      .from('profile-pictures')\r\n      .getPublicUrl(filePath);\r\n\r\n    return { success: true, url: urlData.publicUrl };\r\n  } catch (error) {\r\n    console.error('Error in uploadProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to upload profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteProfilePicture(email: string, avatarUrl: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Extract file path from URL\r\n    const urlParts = avatarUrl.split('/profile-pictures/');\r\n    if (urlParts.length < 2) {\r\n      return { success: false, error: 'Invalid avatar URL' };\r\n    }\r\n\r\n    const filePath = `avatars/${urlParts[1].split('/').pop()}`;\r\n\r\n    // Delete from storage\r\n    const { error: deleteError } = await supabase.storage\r\n      .from('profile-pictures')\r\n      .remove([filePath]);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting file:', deleteError);\r\n      // Don't fail if file doesn't exist\r\n      if (deleteError.message.includes('not found')) {\r\n        return { success: true };\r\n      }\r\n      return { success: false, error: deleteError.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteProfilePicture:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete profile picture',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateCustomerProfile(\r\n  email: string,\r\n  data: ProfileUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  profile?: Profile;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!data.first_name?.trim()) {\r\n      return { success: false, error: 'First name is required' };\r\n    }\r\n    if (!data.last_name?.trim()) {\r\n      return { success: false, error: 'Last name is required' };\r\n    }\r\n    if (!data.email?.trim()) {\r\n      return { success: false, error: 'Email is required' };\r\n    }\r\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\r\n      return { success: false, error: 'Invalid email format' };\r\n    }\r\n\r\n    // Check if profile exists\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    // If avatar_url is being removed, delete the old file\r\n    if (existingProfile?.avatar_url && data.avatar_url === null) {\r\n      await deleteProfilePicture(email, existingProfile.avatar_url);\r\n    }\r\n\r\n    let result;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      // If email changed, we need to handle it carefully\r\n      if (data.email !== email) {\r\n        // Check if new email already exists\r\n        const { data: emailCheck } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('email', data.email)\r\n          .maybeSingle();\r\n\r\n        if (emailCheck) {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n      }\r\n\r\n      const updateData: any = {\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      // Only update avatar_url if it's provided\r\n      if (data.avatar_url !== undefined) {\r\n        updateData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: updatedProfile, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update(updateData)\r\n        .eq('email', email)\r\n        .select()\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating profile:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n\r\n      result = updatedProfile;\r\n    } else {\r\n      // Create new profile\r\n      const insertData: any = {\r\n        email: data.email.trim(),\r\n        phone: data.phone?.trim() || null,\r\n        first_name: data.first_name.trim(),\r\n        last_name: data.last_name.trim(),\r\n      };\r\n\r\n      // Only set avatar_url if it's provided\r\n      if (data.avatar_url) {\r\n        insertData.avatar_url = data.avatar_url;\r\n      }\r\n\r\n      const { data: newProfile, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert(insertData)\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating profile:', insertError);\r\n        // Check if it's a unique constraint violation\r\n        if (insertError.code === '23505') {\r\n          return { success: false, error: 'Email already exists' };\r\n        }\r\n        return { success: false, error: insertError.message };\r\n      }\r\n\r\n      result = newProfile;\r\n    }\r\n\r\n    return { success: true, profile: result };\r\n  } catch (error) {\r\n    console.error('Error in updateCustomerProfile:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update profile',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getCustomerLocations(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  locations?: Location[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('locations')\r\n      .select('*')\r\n      .order('is_default', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    if (email && phone) {\r\n      query = query.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      query = query.eq('customer_email', email);\r\n    } else if (phone) {\r\n      query = query.eq('customer_phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching locations:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, locations: data || [] };\r\n  } catch (error) {\r\n    console.error('Error in getCustomerLocations:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch locations',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function createLocation(\r\n  email: string,\r\n  phone: string | undefined,\r\n  locationData: LocationCreateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input\r\n    if (!locationData.nickname?.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (!locationData.address?.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (!locationData.suburb?.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (!locationData.city?.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (email && phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n      } else if (email) {\r\n        updateQuery = updateQuery.eq('customer_email', email);\r\n      } else if (phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', phone);\r\n      }\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    const { data: newLocation, error: insertError } = await supabase\r\n      .from('locations')\r\n      .insert({\r\n        customer_email: email,\r\n        customer_phone: phone || null,\r\n        nickname: locationData.nickname.trim(),\r\n        address: locationData.address.trim(),\r\n        apt_unit: locationData.apt_unit?.trim() || null,\r\n        suburb: locationData.suburb.trim(),\r\n        city: locationData.city.trim(),\r\n        postal_code: locationData.postal_code?.trim() || null,\r\n        is_default: locationData.is_default || false,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (insertError) {\r\n      console.error('Error creating location:', insertError);\r\n      return { success: false, error: insertError.message };\r\n    }\r\n\r\n    return { success: true, location: newLocation };\r\n  } catch (error) {\r\n    console.error('Error in createLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to create location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function updateLocation(\r\n  locationId: string,\r\n  locationData: LocationUpdateInput\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate input if provided\r\n    if (locationData.nickname !== undefined && !locationData.nickname.trim()) {\r\n      return { success: false, error: 'Nickname is required' };\r\n    }\r\n    if (locationData.address !== undefined && !locationData.address.trim()) {\r\n      return { success: false, error: 'Address is required' };\r\n    }\r\n    if (locationData.suburb !== undefined && !locationData.suburb.trim()) {\r\n      return { success: false, error: 'Suburb is required' };\r\n    }\r\n    if (locationData.city !== undefined && !locationData.city.trim()) {\r\n      return { success: false, error: 'City is required' };\r\n    }\r\n\r\n    // Get current location to check customer email\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // If setting as default, unset all other defaults for this customer\r\n    if (locationData.is_default) {\r\n      let updateQuery = supabase\r\n        .from('locations')\r\n        .update({ is_default: false });\r\n\r\n      if (currentLocation.customer_email && currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.or(`customer_email.eq.${currentLocation.customer_email},customer_phone.eq.${currentLocation.customer_phone}`);\r\n      } else if (currentLocation.customer_email) {\r\n        updateQuery = updateQuery.eq('customer_email', currentLocation.customer_email);\r\n      } else if (currentLocation.customer_phone) {\r\n        updateQuery = updateQuery.eq('customer_phone', currentLocation.customer_phone);\r\n      }\r\n\r\n      // Don't unset the current location\r\n      updateQuery = updateQuery.neq('id', locationId);\r\n\r\n      await updateQuery;\r\n    }\r\n\r\n    // Build update object with only provided fields\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (locationData.nickname !== undefined) {\r\n      updateData.nickname = locationData.nickname.trim();\r\n    }\r\n    if (locationData.address !== undefined) {\r\n      updateData.address = locationData.address.trim();\r\n    }\r\n    if (locationData.apt_unit !== undefined) {\r\n      updateData.apt_unit = locationData.apt_unit?.trim() || null;\r\n    }\r\n    if (locationData.suburb !== undefined) {\r\n      updateData.suburb = locationData.suburb.trim();\r\n    }\r\n    if (locationData.city !== undefined) {\r\n      updateData.city = locationData.city.trim();\r\n    }\r\n    if (locationData.postal_code !== undefined) {\r\n      updateData.postal_code = locationData.postal_code?.trim() || null;\r\n    }\r\n    if (locationData.is_default !== undefined) {\r\n      updateData.is_default = locationData.is_default;\r\n    }\r\n\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update(updateData)\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in updateLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function deleteLocation(locationId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from('locations')\r\n      .delete()\r\n      .eq('id', locationId);\r\n\r\n    if (error) {\r\n      console.error('Error deleting location:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error in deleteLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to delete location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function setDefaultLocation(\r\n  locationId: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  location?: Location;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current location to verify ownership\r\n    const { data: currentLocation, error: fetchError } = await supabase\r\n      .from('locations')\r\n      .select('customer_email, customer_phone')\r\n      .eq('id', locationId)\r\n      .single();\r\n\r\n    if (fetchError || !currentLocation) {\r\n      return { success: false, error: 'Location not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    const isOwner = \r\n      currentLocation.customer_email === email ||\r\n      (phone && currentLocation.customer_phone === phone);\r\n\r\n    if (!isOwner) {\r\n      return { success: false, error: 'Unauthorized' };\r\n    }\r\n\r\n    // Unset all other defaults for this customer\r\n    let updateQuery = supabase\r\n      .from('locations')\r\n      .update({ is_default: false });\r\n\r\n    if (email && phone) {\r\n      updateQuery = updateQuery.or(`customer_email.eq.${email},customer_phone.eq.${phone}`);\r\n    } else if (email) {\r\n      updateQuery = updateQuery.eq('customer_email', email);\r\n    } else if (phone) {\r\n      updateQuery = updateQuery.eq('customer_phone', phone);\r\n    }\r\n\r\n    // Don't unset the current location\r\n    updateQuery = updateQuery.neq('id', locationId);\r\n\r\n    await updateQuery;\r\n\r\n    // Set this location as default\r\n    const { data: updatedLocation, error: updateError } = await supabase\r\n      .from('locations')\r\n      .update({ is_default: true })\r\n      .eq('id', locationId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error setting default location:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, location: updatedLocation };\r\n  } catch (error) {\r\n    console.error('Error in setDefaultLocation:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to set default location',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getOrCreateReferralCode(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  referralCode?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Check if profile exists and has a referral code\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('referral_code')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (profileError && profileError.code !== 'PGRST116') {\r\n      console.error('Error fetching profile:', profileError);\r\n      return { success: false, error: profileError.message };\r\n    }\r\n\r\n    // If profile exists and has a referral code, return it\r\n    if (profile?.referral_code) {\r\n      return { success: true, referralCode: profile.referral_code };\r\n    }\r\n\r\n    // Generate a new referral code\r\n    // Try using the database function first, but fallback to client-side generation\r\n    let generatedCode: string | null = null;\r\n    \r\n    try {\r\n      const { data: dbCode, error: codeError } = await supabase\r\n        .rpc('generate_referral_code');\r\n      \r\n      if (!codeError && dbCode) {\r\n        generatedCode = dbCode;\r\n      }\r\n    } catch (rpcError) {\r\n      // RPC function might not exist yet, that's okay\r\n      console.log('RPC function not available, using fallback');\r\n    }\r\n\r\n    if (!generatedCode) {\r\n      // Fallback: generate code client-side style\r\n      const fallbackCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n      \r\n      // Check if fallback code exists, retry if it does\r\n      let finalCode = fallbackCode;\r\n      let attempts = 0;\r\n      const maxAttempts = 5;\r\n\r\n      while (attempts < maxAttempts) {\r\n        const { data: existing } = await supabase\r\n          .from('profiles')\r\n          .select('id')\r\n          .eq('referral_code', finalCode)\r\n          .maybeSingle();\r\n\r\n        if (!existing) {\r\n          break; // Code is unique\r\n        }\r\n\r\n        // Generate a new code\r\n        finalCode = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n        attempts++;\r\n      }\r\n\r\n      // Update or insert profile with referral code\r\n      // First, try to update existing profile\r\n      const { data: existingProfile } = await supabase\r\n        .from('profiles')\r\n        .select('id, first_name, last_name')\r\n        .eq('email', email)\r\n        .maybeSingle();\r\n\r\n      let updatedProfile;\r\n      if (existingProfile) {\r\n        // Update existing profile\r\n        const { data: updated, error: updateError } = await supabase\r\n          .from('profiles')\r\n          .update({\r\n            referral_code: finalCode,\r\n            updated_at: new Date().toISOString(),\r\n          })\r\n          .eq('email', email)\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (updateError) {\r\n          console.error('Error updating referral code:', updateError);\r\n          return { success: false, error: updateError.message };\r\n        }\r\n        updatedProfile = updated;\r\n      } else {\r\n        // Insert new profile with referral code\r\n        const { data: inserted, error: insertError } = await supabase\r\n          .from('profiles')\r\n          .insert({\r\n            email,\r\n            referral_code: finalCode,\r\n            first_name: email.split('@')[0],\r\n            last_name: '',\r\n          })\r\n          .select('referral_code')\r\n          .single();\r\n\r\n        if (insertError) {\r\n          console.error('Error creating referral code:', insertError);\r\n          return { success: false, error: insertError.message };\r\n        }\r\n        updatedProfile = inserted;\r\n      }\r\n\r\n      return { success: true, referralCode: updatedProfile?.referral_code || finalCode };\r\n    }\r\n\r\n    // Use the generated code from database function\r\n    // Update or insert profile with generated code\r\n    const { data: existingProfile } = await supabase\r\n      .from('profiles')\r\n      .select('id, first_name, last_name')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    let updatedProfile;\r\n    if (existingProfile) {\r\n      // Update existing profile\r\n      const { data: updated, error: updateError } = await supabase\r\n        .from('profiles')\r\n        .update({\r\n          referral_code: generatedCode,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('email', email)\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (updateError) {\r\n        console.error('Error updating referral code:', updateError);\r\n        return { success: false, error: updateError.message };\r\n      }\r\n      updatedProfile = updated;\r\n    } else {\r\n      // Insert new profile with referral code\r\n      const { data: inserted, error: insertError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          referral_code: generatedCode,\r\n          first_name: email.split('@')[0],\r\n          last_name: '',\r\n        })\r\n        .select('referral_code')\r\n        .single();\r\n\r\n      if (insertError) {\r\n        console.error('Error creating referral code:', insertError);\r\n        return { success: false, error: insertError.message };\r\n      }\r\n      updatedProfile = inserted;\r\n    }\r\n\r\n    return { success: true, referralCode: updatedProfile?.referral_code || generatedCode };\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateReferralCode:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get referral code',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function sendReferralInvites(\r\n  email: string,\r\n  inviteEmails: string[],\r\n  referralCode: string\r\n): Promise<{\r\n  success: boolean;\r\n  sent?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Validate email addresses\r\n    const validEmails = inviteEmails\r\n      .map((e) => e.trim())\r\n      .filter((e) => {\r\n        if (!e) return false;\r\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(e);\r\n      });\r\n\r\n    if (validEmails.length === 0) {\r\n      return { success: false, error: 'No valid email addresses provided' };\r\n    }\r\n\r\n    // Create referral records for tracking\r\n    const referralRecords = validEmails.map((referredEmail) => ({\r\n      referrer_email: email,\r\n      referred_email: referredEmail,\r\n      referral_code: referralCode,\r\n      status: 'pending',\r\n    }));\r\n\r\n    const { error: insertError } = await supabase\r\n      .from('referrals')\r\n      .insert(referralRecords);\r\n\r\n    if (insertError) {\r\n      console.error('Error creating referral records:', insertError);\r\n      // Continue even if insert fails - we still want to send emails\r\n    }\r\n\r\n    // Generate referral link\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    // TODO: Implement actual email sending using your email service (Resend, SendGrid, etc.)\r\n    // For now, we'll just log the emails that would be sent\r\n    console.log('Referral invites to send:', {\r\n      from: email,\r\n      to: validEmails,\r\n      referralCode,\r\n      referralLink,\r\n    });\r\n\r\n    // In a real implementation, you would send emails here\r\n    // Example with Resend:\r\n    // await resend.emails.send({\r\n    //   from: 'Shalean <noreply@shalean.co.za>',\r\n    //   to: validEmails,\r\n    //   subject: 'You\\'ve been invited to try Shalean Cleaning Services!',\r\n    //   html: `<p>Your friend has invited you to try Shalean. Use code ${referralCode} to get R150 off your first booking!</p><p><a href=\"${referralLink}\">Book Now</a></p>`,\r\n    // });\r\n\r\n    return { success: true, sent: validEmails.length };\r\n  } catch (error) {\r\n    console.error('Error in sendReferralInvites:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to send invites',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getReferralStats(\r\n  email: string\r\n): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data: referrals, error } = await supabase\r\n      .from('referrals')\r\n      .select('status, referrer_reward_amount, referrer_reward_status')\r\n      .eq('referrer_email', email);\r\n\r\n    if (error) {\r\n      console.error('Error fetching referral stats:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    const stats = {\r\n      totalReferrals: referrals?.length || 0,\r\n      completedReferrals:\r\n        referrals?.filter((r) => r.status === 'completed').length || 0,\r\n      pendingRewards:\r\n        referrals?.filter((r) => r.referrer_reward_status === 'pending').length || 0,\r\n      totalRewards:\r\n        referrals\r\n          ?.filter((r) => r.referrer_reward_status === 'credited')\r\n          .reduce((sum, r) => sum + (r.referrer_reward_amount || 0), 0) || 0,\r\n    };\r\n\r\n    return { success: true, stats };\r\n  } catch (error) {\r\n    console.error('Error in getReferralStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch referral stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize a credit purchase with Paystack\r\n */\r\nexport async function initializeCreditPurchase(\r\n  email: string,\r\n  amount: number,\r\n  paymentMethod: 'credit_card' | 'eft'\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (amount < 20 || amount > 5000) {\r\n      return {\r\n        success: false,\r\n        error: 'Amount must be between R20 and R5000',\r\n      };\r\n    }\r\n\r\n    // Generate a unique reference for this credit purchase\r\n    const reference = `CREDIT_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Create a pending credit transaction\r\n    const supabase = await createClient();\r\n    \r\n    // Get or create profile\r\n    let { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('id, credit_balance')\r\n      .eq('email', email)\r\n      .maybeSingle();\r\n\r\n    if (!profile) {\r\n      // Create a basic profile if it doesn't exist\r\n      const { data: newProfile, error: createError } = await supabase\r\n        .from('profiles')\r\n        .insert({\r\n          email,\r\n          credit_balance: 0,\r\n          first_name: '',\r\n          last_name: '',\r\n        })\r\n        .select('id, credit_balance')\r\n        .single();\r\n\r\n      if (createError || !newProfile) {\r\n        return {\r\n          success: false,\r\n          error: 'Failed to create profile',\r\n        };\r\n      }\r\n      profile = newProfile;\r\n    }\r\n\r\n    // Create pending credit transaction\r\n    const { error: transactionError } = await supabase\r\n      .from('credit_transactions')\r\n      .insert({\r\n        profile_id: profile.id,\r\n        email,\r\n        transaction_type: 'purchase',\r\n        amount,\r\n        balance_before: profile.credit_balance || 0,\r\n        balance_after: profile.credit_balance || 0, // Won't update until payment succeeds\r\n        payment_method: paymentMethod,\r\n        paystack_reference: reference,\r\n        payment_status: 'pending',\r\n        description: `Purchase of R${amount} ShaleanCred`,\r\n      });\r\n\r\n    if (transactionError) {\r\n      console.error('Error creating credit transaction:', transactionError);\r\n      return {\r\n        success: false,\r\n        error: 'Failed to create transaction record',\r\n      };\r\n    }\r\n\r\n    // Initialize Paystack payment\r\n    const response = await fetch('/api/paystack/initialize', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        email,\r\n        amount,\r\n        reference,\r\n        metadata: {\r\n          transaction_type: 'credit_purchase',\r\n          payment_method: paymentMethod,\r\n        },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      return {\r\n        success: false,\r\n        error: error.error || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    const paymentData = await response.json();\r\n\r\n    if (!paymentData.status) {\r\n      return {\r\n        success: false,\r\n        error: paymentData.message || 'Failed to initialize payment',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentData.data.authorization_url,\r\n      reference: paymentData.data.reference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing credit purchase:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\nexport interface VoucherRedemption {\r\n  id: string;\r\n  voucher_code: string;\r\n  amount: number;\r\n  redeemed_at: string;\r\n  booking_id?: string;\r\n}\r\n\r\nexport async function redeemVoucher(\r\n  code: string,\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  amount?: number;\r\n  newBalance?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Call the database function to redeem the voucher\r\n    const { data, error } = await supabase.rpc('redeem_voucher', {\r\n      p_code: code.trim().toUpperCase(),\r\n      p_email: email.trim(),\r\n      p_phone: phone?.trim() || null,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Error redeeming voucher:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Failed to redeem voucher',\r\n      };\r\n    }\r\n\r\n    // Parse the result from the function (handle both object and string JSONB)\r\n    let result = data;\r\n    if (typeof data === 'string') {\r\n      try {\r\n        result = JSON.parse(data);\r\n      } catch (parseError) {\r\n        console.error('Error parsing voucher redemption result:', parseError);\r\n        return {\r\n          success: false,\r\n          error: 'Invalid response from server',\r\n        };\r\n      }\r\n    }\r\n\r\n    if (result && typeof result === 'object' && 'success' in result) {\r\n      if (result.success === false) {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to redeem voucher',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        amount: result.amount,\r\n        newBalance: result.new_balance,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Unexpected response from server',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in redeemVoucher:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to redeem voucher',\r\n    };\r\n  }\r\n}\r\n\r\nexport async function getVoucherRedemptions(\r\n  email: string,\r\n  phone?: string\r\n): Promise<{\r\n  success: boolean;\r\n  redemptions?: VoucherRedemption[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from('voucher_redemptions')\r\n      .select('id, voucher_code, amount, redeemed_at, booking_id')\r\n      .order('redeemed_at', { ascending: false });\r\n\r\n    // Build query for email/phone lookup\r\n    // Prioritize email as it's the primary identifier to prevent cross-account visibility\r\n    if (email) {\r\n      query = query.eq('email', email);\r\n      // If phone is also provided, we can optionally filter by both for extra security\r\n      // but email alone should be sufficient since it's unique\r\n    } else if (phone) {\r\n      query = query.eq('phone', phone);\r\n    } else {\r\n      return { success: false, error: 'Email or phone is required' };\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error('Error fetching voucher redemptions:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    // Transform the data to match the interface\r\n    const redemptions: VoucherRedemption[] = (data || []).map((redemption) => ({\r\n      id: redemption.id,\r\n      voucher_code: redemption.voucher_code,\r\n      amount: redemption.amount,\r\n      redeemed_at: redemption.redeemed_at,\r\n      booking_id: redemption.booking_id || undefined,\r\n    }));\r\n\r\n    return { success: true, redemptions };\r\n  } catch (error) {\r\n    console.error('Error in getVoucherRedemptions:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch voucher redemptions',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAOsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 216, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/dashboard/refer/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useEffect, useState } from 'react';\r\nimport { useSearchParams } from 'next/navigation';\r\nimport { Card, CardContent } from '@/components/ui/card';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Loader2, Share2, Gift, Ticket, Copy, Check } from 'lucide-react';\r\nimport { toast } from 'sonner';\r\nimport {\r\n  getOrCreateReferralCode,\r\n  sendReferralInvites,\r\n  getReferralStats,\r\n  getAuthenticatedUser,\r\n} from '../actions';\r\n\r\nexport default function ReferPage() {\r\n  const searchParams = useSearchParams();\r\n  const [loading, setLoading] = useState(true);\r\n  const [sending, setSending] = useState(false);\r\n  const [referralCode, setReferralCode] = useState('');\r\n  const [inviteEmails, setInviteEmails] = useState('');\r\n  const [copied, setCopied] = useState(false);\r\n  const [stats, setStats] = useState<{\r\n    totalReferrals: number;\r\n    completedReferrals: number;\r\n    pendingRewards: number;\r\n    totalRewards: number;\r\n  } | null>(null);\r\n  const [email, setEmail] = useState<string>('');\r\n\r\n  useEffect(() => {\r\n    const loadReferralCode = async () => {\r\n      try {\r\n        setLoading(true);\r\n\r\n        // Get authenticated user's email\r\n        const authResult = await getAuthenticatedUser();\r\n        \r\n        if (!authResult.success || !authResult.email) {\r\n          setLoading(false);\r\n          return;\r\n        }\r\n\r\n        const userEmail = authResult.email;\r\n        setEmail(userEmail);\r\n\r\n        // Get or create referral code\r\n        const result = await getOrCreateReferralCode(userEmail);\r\n\r\n        if (result.success && result.referralCode) {\r\n          setReferralCode(result.referralCode);\r\n        } else {\r\n          toast.error(result.error || 'Failed to load referral code');\r\n        }\r\n\r\n        // Load referral stats\r\n        const statsResult = await getReferralStats(userEmail);\r\n        if (statsResult.success && statsResult.stats) {\r\n          setStats(statsResult.stats);\r\n        }\r\n      } catch (error) {\r\n        console.error('Error loading referral code:', error);\r\n        toast.error('An unexpected error occurred');\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    loadReferralCode();\r\n  }, []);\r\n\r\n  const handleCopyLink = async () => {\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n\r\n    try {\r\n      await navigator.clipboard.writeText(referralLink);\r\n      setCopied(true);\r\n      toast.success('Referral link copied to clipboard!');\r\n      setTimeout(() => setCopied(false), 2000);\r\n    } catch (error) {\r\n      console.error('Failed to copy:', error);\r\n      toast.error('Failed to copy link');\r\n    }\r\n  };\r\n\r\n  const handleShare = (platform: 'facebook' | 'messenger' | 'twitter' | 'whatsapp') => {\r\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shalean.co.za';\r\n    const referralLink = `${baseUrl}/booking/details?ref=${referralCode}`;\r\n    const shareText = `Join me on Shalean Cleaning Services! Use my referral code ${referralCode} to get R150 off your first booking. ${referralLink}`;\r\n\r\n    let shareUrl = '';\r\n\r\n    switch (platform) {\r\n      case 'facebook':\r\n        shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(referralLink)}`;\r\n        break;\r\n      case 'messenger':\r\n        shareUrl = `https://www.facebook.com/dialog/send?link=${encodeURIComponent(referralLink)}&app_id=${process.env.NEXT_PUBLIC_FACEBOOK_APP_ID || ''}`;\r\n        break;\r\n      case 'twitter':\r\n        shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}`;\r\n        break;\r\n      case 'whatsapp':\r\n        shareUrl = `https://wa.me/?text=${encodeURIComponent(shareText)}`;\r\n        break;\r\n    }\r\n\r\n    if (shareUrl) {\r\n      window.open(shareUrl, '_blank', 'width=600,height=400');\r\n    }\r\n  };\r\n\r\n  const handleSendInvites = async () => {\r\n    if (!inviteEmails.trim()) {\r\n      toast.error('Please enter at least one email address');\r\n      return;\r\n    }\r\n\r\n    const emailList = inviteEmails\r\n      .split(',')\r\n      .map((e) => e.trim())\r\n      .filter((e) => e);\r\n\r\n    if (emailList.length === 0) {\r\n      toast.error('Please enter valid email addresses');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setSending(true);\r\n\r\n      if (!email) {\r\n        toast.error('Please access the dashboard first');\r\n        return;\r\n      }\r\n\r\n      const result = await sendReferralInvites(email, emailList, referralCode);\r\n\r\n      if (result.success) {\r\n        toast.success(`Invitations sent to ${result.sent} friend${result.sent !== 1 ? 's' : ''}!`);\r\n        setInviteEmails('');\r\n      } else {\r\n        toast.error(result.error || 'Failed to send invitations');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error sending invites:', error);\r\n      toast.error('An unexpected error occurred');\r\n    } finally {\r\n      setSending(false);\r\n    }\r\n  };\r\n\r\n  if (loading) {\r\n    return (\r\n      <div className=\"space-y-4 sm:space-y-6 w-full max-w-full overflow-x-hidden\">\r\n        <div>\r\n          <h1 className=\"text-2xl sm:text-3xl md:text-4xl font-bold\">Refer & Earn</h1>\r\n          <p className=\"text-muted-foreground mt-2\">Earn R150 ShaleanCred per friend referral</p>\r\n        </div>\r\n        <Card>\r\n          <CardContent className=\"flex items-center justify-center py-12\">\r\n            <Loader2 className=\"w-8 h-8 animate-spin text-muted-foreground\" />\r\n          </CardContent>\r\n        </Card>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!email) {\r\n    return (\r\n      <div className=\"space-y-4 sm:space-y-6 w-full max-w-full overflow-x-hidden\">\r\n        <div>\r\n          <h1 className=\"text-2xl sm:text-3xl md:text-4xl font-bold\">Refer & Earn</h1>\r\n          <p className=\"text-muted-foreground mt-2\">Earn R150 ShaleanCred per friend referral</p>\r\n        </div>\r\n        <Card>\r\n          <CardContent className=\"p-4 sm:p-6\">\r\n            <p className=\"text-muted-foreground mb-4\">\r\n              Please log in to access the Refer & Earn program.\r\n            </p>\r\n            <Button\r\n              onClick={() => window.location.href = '/login?redirect=/dashboard/refer'}\r\n              className=\"bg-primary hover:bg-primary/90 text-primary-foreground\"\r\n            >\r\n              Log In\r\n            </Button>\r\n          </CardContent>\r\n        </Card>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-4 sm:space-y-6 w-full max-w-full overflow-x-hidden\">\r\n      {/* Page Header */}\r\n      <div>\r\n        <h1 className=\"text-2xl sm:text-3xl md:text-4xl font-bold\">Refer & Earn</h1>\r\n        <p className=\"text-muted-foreground mt-2\">Earn R150 ShaleanCred per friend referral</p>\r\n      </div>\r\n\r\n      {/* Share Your Unique Code Section */}\r\n      <Card className=\"border-border\">\r\n        <CardContent className=\"p-4 sm:p-6 space-y-4\">\r\n          <div>\r\n            <Label htmlFor=\"referral-code\" className=\"text-base font-medium\">\r\n              Your Code:\r\n            </Label>\r\n            <div className=\"flex gap-2 mt-2\">\r\n              <Input\r\n                id=\"referral-code\"\r\n                value={referralCode}\r\n                readOnly\r\n                className=\"bg-muted font-mono text-lg\"\r\n              />\r\n              <Button\r\n                onClick={handleCopyLink}\r\n                className=\"bg-primary hover:bg-primary/90 text-primary-foreground\"\r\n              >\r\n                {copied ? (\r\n                  <>\r\n                    <Check className=\"w-4 h-4 mr-2\" />\r\n                    Copied\r\n                  </>\r\n                ) : (\r\n                  <>\r\n                    <Copy className=\"w-4 h-4 mr-2\" />\r\n                    Copy Link\r\n                  </>\r\n                )}\r\n              </Button>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Social Sharing Buttons */}\r\n          <div className=\"flex flex-wrap gap-2 pt-2\">\r\n            <Button\r\n              onClick={() => handleShare('facebook')}\r\n              className=\"bg-[#1877F2] hover:bg-[#1877F2]/90 text-white\"\r\n              size=\"sm\"\r\n            >\r\n              Facebook\r\n            </Button>\r\n            <Button\r\n              onClick={() => handleShare('messenger')}\r\n              className=\"bg-[#0084FF] hover:bg-[#0084FF]/90 text-white\"\r\n              size=\"sm\"\r\n            >\r\n              Messenger\r\n            </Button>\r\n            <Button\r\n              onClick={() => handleShare('twitter')}\r\n              className=\"bg-black hover:bg-black/90 text-white\"\r\n              size=\"sm\"\r\n            >\r\n              X\r\n            </Button>\r\n            <Button\r\n              onClick={() => handleShare('whatsapp')}\r\n              className=\"bg-[#25D366] hover:bg-[#25D366]/90 text-white\"\r\n              size=\"sm\"\r\n            >\r\n              WhatsApp\r\n            </Button>\r\n          </div>\r\n        </CardContent>\r\n      </Card>\r\n\r\n      {/* Invite Your Friends Section */}\r\n      <Card className=\"border-border\">\r\n        <CardContent className=\"p-4 sm:p-6 space-y-4\">\r\n          <div>\r\n            <Label htmlFor=\"invite-emails\" className=\"text-base font-medium\">\r\n              Add email addresses:\r\n            </Label>\r\n            <div className=\"flex gap-2 mt-2\">\r\n              <Input\r\n                id=\"invite-emails\"\r\n                type=\"text\"\r\n                placeholder=\"comma separated: friend1@mail.com,friend2@mail.com\"\r\n                value={inviteEmails}\r\n                onChange={(e) => setInviteEmails(e.target.value)}\r\n                className=\"flex-1\"\r\n              />\r\n              <Button\r\n                onClick={handleSendInvites}\r\n                disabled={sending || !inviteEmails.trim()}\r\n                className=\"bg-primary hover:bg-primary/90 text-primary-foreground\"\r\n              >\r\n                {sending ? (\r\n                  <>\r\n                    <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" />\r\n                    Sending...\r\n                  </>\r\n                ) : (\r\n                  'Send Invites'\r\n                )}\r\n              </Button>\r\n            </div>\r\n          </div>\r\n        </CardContent>\r\n      </Card>\r\n\r\n      {/* How It Works Section */}\r\n      <Card className=\"border-border\">\r\n        <CardContent className=\"p-4 sm:p-6 space-y-4\">\r\n          <h2 className=\"text-xl font-bold\">How it works</h2>\r\n          <div className=\"space-y-4\">\r\n            {/* Step 1 */}\r\n            <div className=\"flex gap-4\">\r\n              <div className=\"flex-shrink-0 mt-1\">\r\n                <Share2 className=\"w-6 h-6 text-primary\" />\r\n              </div>\r\n              <div>\r\n                <p className=\"text-sm sm:text-base\">\r\n                  Spread the word with your unique code:{' '}\r\n                  <span className=\"font-mono font-semibold text-primary\">{referralCode}</span>\r\n                </p>\r\n              </div>\r\n            </div>\r\n\r\n            {/* Step 2 */}\r\n            <div className=\"flex gap-4\">\r\n              <div className=\"flex-shrink-0 mt-1\">\r\n                <Gift className=\"w-6 h-6 text-primary\" />\r\n              </div>\r\n              <div>\r\n                <p className=\"text-sm sm:text-base\">\r\n                  Each friend that books their first Shalean clean gets R150 off\r\n                </p>\r\n              </div>\r\n            </div>\r\n\r\n            {/* Step 3 */}\r\n            <div className=\"flex gap-4\">\r\n              <div className=\"flex-shrink-0 mt-1\">\r\n                <Ticket className=\"w-6 h-6 text-primary\" />\r\n              </div>\r\n              <div>\r\n                <p className=\"text-sm sm:text-base\">\r\n                  For each referral you earn R150 ShaleanCred\r\n                </p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Terms & Conditions Link */}\r\n          <div className=\"pt-2\">\r\n            <a\r\n              href=\"/terms\"\r\n              className=\"text-sm text-primary hover:underline\"\r\n            >\r\n              T&C's apply.\r\n            </a>\r\n          </div>\r\n        </CardContent>\r\n      </Card>\r\n    </div>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":";;;;AA0EoB;;AAxEpB;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;;;AAVA;;;;;;;;;;AAiBe,SAAS;;IACtB,MAAM,eAAe,IAAA,wJAAe;IACpC,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IACvC,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IACvC,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,yKAAQ,EAAC;IACjD,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,yKAAQ,EAAC;IACjD,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,yKAAQ,EAAC;IACrC,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAKxB;IACV,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAS;IAE3C,IAAA,0KAAS;+BAAC;YACR,MAAM;wDAAmB;oBACvB,IAAI;wBACF,WAAW;wBAEX,iCAAiC;wBACjC,MAAM,aAAa,MAAM,IAAA,mLAAoB;wBAE7C,IAAI,CAAC,WAAW,OAAO,IAAI,CAAC,WAAW,KAAK,EAAE;4BAC5C,WAAW;4BACX;wBACF;wBAEA,MAAM,YAAY,WAAW,KAAK;wBAClC,SAAS;wBAET,8BAA8B;wBAC9B,MAAM,SAAS,MAAM,IAAA,sLAAuB,EAAC;wBAE7C,IAAI,OAAO,OAAO,IAAI,OAAO,YAAY,EAAE;4BACzC,gBAAgB,OAAO,YAAY;wBACrC,OAAO;4BACL,oJAAK,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;wBAC9B;wBAEA,sBAAsB;wBACtB,MAAM,cAAc,MAAM,IAAA,+KAAgB,EAAC;wBAC3C,IAAI,YAAY,OAAO,IAAI,YAAY,KAAK,EAAE;4BAC5C,SAAS,YAAY,KAAK;wBAC5B;oBACF,EAAE,OAAO,OAAO;wBACd,QAAQ,KAAK,CAAC,gCAAgC;wBAC9C,oJAAK,CAAC,KAAK,CAAC;oBACd,SAAU;wBACR,WAAW;oBACb;gBACF;;YAEA;QACF;8BAAG,EAAE;IAEL,MAAM,iBAAiB;QACrB,MAAM,UAAU,2KAAO,CAAC,GAAG,CAAC,oBAAoB,IAAI;QACpD,MAAM,eAAe,GAAG,QAAQ,qBAAqB,EAAE,cAAc;QAErE,IAAI;YACF,MAAM,UAAU,SAAS,CAAC,SAAS,CAAC;YACpC,UAAU;YACV,oJAAK,CAAC,OAAO,CAAC;YACd,WAAW,IAAM,UAAU,QAAQ;QACrC,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,mBAAmB;YACjC,oJAAK,CAAC,KAAK,CAAC;QACd;IACF;IAEA,MAAM,cAAc,CAAC;QACnB,MAAM,UAAU,2KAAO,CAAC,GAAG,CAAC,oBAAoB,IAAI;QACpD,MAAM,eAAe,GAAG,QAAQ,qBAAqB,EAAE,cAAc;QACrE,MAAM,YAAY,CAAC,2DAA2D,EAAE,aAAa,qCAAqC,EAAE,cAAc;QAElJ,IAAI,WAAW;QAEf,OAAQ;YACN,KAAK;gBACH,WAAW,CAAC,6CAA6C,EAAE,mBAAmB,eAAe;gBAC7F;YACF,KAAK;gBACH,WAAW,CAAC,0CAA0C,EAAE,mBAAmB,cAAc,QAAQ,EAAE,2KAAO,CAAC,GAAG,CAAC,2BAA2B,IAAI,IAAI;gBAClJ;YACF,KAAK;gBACH,WAAW,CAAC,sCAAsC,EAAE,mBAAmB,YAAY;gBACnF;YACF,KAAK;gBACH,WAAW,CAAC,oBAAoB,EAAE,mBAAmB,YAAY;gBACjE;QACJ;QAEA,IAAI,UAAU;YACZ,OAAO,IAAI,CAAC,UAAU,UAAU;QAClC;IACF;IAEA,MAAM,oBAAoB;QACxB,IAAI,CAAC,aAAa,IAAI,IAAI;YACxB,oJAAK,CAAC,KAAK,CAAC;YACZ;QACF;QAEA,MAAM,YAAY,aACf,KAAK,CAAC,KACN,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI,IACjB,MAAM,CAAC,CAAC,IAAM;QAEjB,IAAI,UAAU,MAAM,KAAK,GAAG;YAC1B,oJAAK,CAAC,KAAK,CAAC;YACZ;QACF;QAEA,IAAI;YACF,WAAW;YAEX,IAAI,CAAC,OAAO;gBACV,oJAAK,CAAC,KAAK,CAAC;gBACZ;YACF;YAEA,MAAM,SAAS,MAAM,IAAA,kLAAmB,EAAC,OAAO,WAAW;YAE3D,IAAI,OAAO,OAAO,EAAE;gBAClB,oJAAK,CAAC,OAAO,CAAC,CAAC,oBAAoB,EAAE,OAAO,IAAI,CAAC,OAAO,EAAE,OAAO,IAAI,KAAK,IAAI,MAAM,GAAG,CAAC,CAAC;gBACzF,gBAAgB;YAClB,OAAO;gBACL,oJAAK,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;YAC9B;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,0BAA0B;YACxC,oJAAK,CAAC,KAAK,CAAC;QACd,SAAU;YACR,WAAW;QACb;IACF;IAEA,IAAI,SAAS;QACX,qBACE,6LAAC;YAAI,WAAU;;8BACb,6LAAC;;sCACC,6LAAC;4BAAG,WAAU;sCAA6C;;;;;;sCAC3D,6LAAC;4BAAE,WAAU;sCAA6B;;;;;;;;;;;;8BAE5C,6LAAC,2IAAI;8BACH,cAAA,6LAAC,kJAAW;wBAAC,WAAU;kCACrB,cAAA,6LAAC,+NAAO;4BAAC,WAAU;;;;;;;;;;;;;;;;;;;;;;IAK7B;IAEA,IAAI,CAAC,OAAO;QACV,qBACE,6LAAC;YAAI,WAAU;;8BACb,6LAAC;;sCACC,6LAAC;4BAAG,WAAU;sCAA6C;;;;;;sCAC3D,6LAAC;4BAAE,WAAU;sCAA6B;;;;;;;;;;;;8BAE5C,6LAAC,2IAAI;8BACH,cAAA,6LAAC,kJAAW;wBAAC,WAAU;;0CACrB,6LAAC;gCAAE,WAAU;0CAA6B;;;;;;0CAG1C,6LAAC,+IAAM;gCACL,SAAS,IAAM,OAAO,QAAQ,CAAC,IAAI,GAAG;gCACtC,WAAU;0CACX;;;;;;;;;;;;;;;;;;;;;;;IAOX;IAEA,qBACE,6LAAC;QAAI,WAAU;;0BAEb,6LAAC;;kCACC,6LAAC;wBAAG,WAAU;kCAA6C;;;;;;kCAC3D,6LAAC;wBAAE,WAAU;kCAA6B;;;;;;;;;;;;0BAI5C,6LAAC,2IAAI;gBAAC,WAAU;0BACd,cAAA,6LAAC,kJAAW;oBAAC,WAAU;;sCACrB,6LAAC;;8CACC,6LAAC,6IAAK;oCAAC,SAAQ;oCAAgB,WAAU;8CAAwB;;;;;;8CAGjE,6LAAC;oCAAI,WAAU;;sDACb,6LAAC,6IAAK;4CACJ,IAAG;4CACH,OAAO;4CACP,QAAQ;4CACR,WAAU;;;;;;sDAEZ,6LAAC,+IAAM;4CACL,SAAS;4CACT,WAAU;sDAET,uBACC;;kEACE,6LAAC,gNAAK;wDAAC,WAAU;;;;;;oDAAiB;;6EAIpC;;kEACE,6LAAC,6MAAI;wDAAC,WAAU;;;;;;oDAAiB;;;;;;;;;;;;;;;;;;;;sCAS3C,6LAAC;4BAAI,WAAU;;8CACb,6LAAC,+IAAM;oCACL,SAAS,IAAM,YAAY;oCAC3B,WAAU;oCACV,MAAK;8CACN;;;;;;8CAGD,6LAAC,+IAAM;oCACL,SAAS,IAAM,YAAY;oCAC3B,WAAU;oCACV,MAAK;8CACN;;;;;;8CAGD,6LAAC,+IAAM;oCACL,SAAS,IAAM,YAAY;oCAC3B,WAAU;oCACV,MAAK;8CACN;;;;;;8CAGD,6LAAC,+IAAM;oCACL,SAAS,IAAM,YAAY;oCAC3B,WAAU;oCACV,MAAK;8CACN;;;;;;;;;;;;;;;;;;;;;;;0BAQP,6LAAC,2IAAI;gBAAC,WAAU;0BACd,cAAA,6LAAC,kJAAW;oBAAC,WAAU;8BACrB,cAAA,6LAAC;;0CACC,6LAAC,6IAAK;gCAAC,SAAQ;gCAAgB,WAAU;0CAAwB;;;;;;0CAGjE,6LAAC;gCAAI,WAAU;;kDACb,6LAAC,6IAAK;wCACJ,IAAG;wCACH,MAAK;wCACL,aAAY;wCACZ,OAAO;wCACP,UAAU,CAAC,IAAM,gBAAgB,EAAE,MAAM,CAAC,KAAK;wCAC/C,WAAU;;;;;;kDAEZ,6LAAC,+IAAM;wCACL,SAAS;wCACT,UAAU,WAAW,CAAC,aAAa,IAAI;wCACvC,WAAU;kDAET,wBACC;;8DACE,6LAAC,+NAAO;oDAAC,WAAU;;;;;;gDAA8B;;2DAInD;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BASZ,6LAAC,2IAAI;gBAAC,WAAU;0BACd,cAAA,6LAAC,kJAAW;oBAAC,WAAU;;sCACrB,6LAAC;4BAAG,WAAU;sCAAoB;;;;;;sCAClC,6LAAC;4BAAI,WAAU;;8CAEb,6LAAC;oCAAI,WAAU;;sDACb,6LAAC;4CAAI,WAAU;sDACb,cAAA,6LAAC,uNAAM;gDAAC,WAAU;;;;;;;;;;;sDAEpB,6LAAC;sDACC,cAAA,6LAAC;gDAAE,WAAU;;oDAAuB;oDACK;kEACvC,6LAAC;wDAAK,WAAU;kEAAwC;;;;;;;;;;;;;;;;;;;;;;;8CAM9D,6LAAC;oCAAI,WAAU;;sDACb,6LAAC;4CAAI,WAAU;sDACb,cAAA,6LAAC,6MAAI;gDAAC,WAAU;;;;;;;;;;;sDAElB,6LAAC;sDACC,cAAA,6LAAC;gDAAE,WAAU;0DAAuB;;;;;;;;;;;;;;;;;8CAOxC,6LAAC;oCAAI,WAAU;;sDACb,6LAAC;4CAAI,WAAU;sDACb,cAAA,6LAAC,mNAAM;gDAAC,WAAU;;;;;;;;;;;sDAEpB,6LAAC;sDACC,cAAA,6LAAC;gDAAE,WAAU;0DAAuB;;;;;;;;;;;;;;;;;;;;;;;sCAQ1C,6LAAC;4BAAI,WAAU;sCACb,cAAA,6LAAC;gCACC,MAAK;gCACL,WAAU;0CACX;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQb;GAxVwB;;QACD,wJAAe;;;KADd"}}]
}