{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { createAdminClient } from '@/lib/supabase/server-admin';\r\nimport { Booking } from '@/types/booking';\r\nimport { Cleaner } from '@/types/booking';\r\nimport {\r\n  calculateCleanerTenure,\r\n  calculateTotalHours,\r\n  getEarningsPercentage,\r\n  calculateTotalEarningsFromBooking,\r\n  calculateCleanerEarnings,\r\n  calculateTipPerCleaner,\r\n} from '@/lib/utils/cleaner-earnings';\r\n\r\n/**\r\n * Get cleaner by phone number\r\n */\r\nexport async function getCleanerByPhone(phone: string): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    \r\n    // Normalize phone number (remove spaces, dashes, etc.)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    \r\n    const { data, error } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .or(`phone.eq.${normalizedPhone},phone.eq.+${normalizedPhone}`)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaner by phone:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!data) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: data as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerByPhone:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Authenticate cleaner with phone and password\r\n * Uses Supabase Auth - expects email format: {phone}@cleaners.shalean.local\r\n * Admin should create auth accounts with this email format when creating cleaner accounts\r\n */\r\nexport async function authenticateCleaner(\r\n  phone: string,\r\n  password: string\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // First, find the cleaner by phone to verify they exist\r\n    const cleanerResult = await getCleanerByPhone(phone);\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    const cleaner = cleanerResult.cleaner;\r\n\r\n    // Use phone-based email format for login\r\n    // Format: {phone}@cleaners.shalean.local\r\n    // Normalize phone (remove spaces, keep + if present)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    const authEmail = `${normalizedPhone}@cleaners.shalean.local`;\r\n\r\n    // Authenticate with Supabase Auth using client-side (this should be called from client)\r\n    // Note: This function should ideally be called from a client component\r\n    // For server-side, we'll return the cleaner info and let client handle auth\r\n    const supabase = await createClient();\r\n    \r\n    // Try to authenticate\r\n    const { data, error } = await supabase.auth.signInWithPassword({\r\n      email: authEmail,\r\n      password,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Authentication error:', error);\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Authentication failed' };\r\n    }\r\n\r\n    // Update cleaner's auth_user_id if not set\r\n    if (!cleaner.auth_user_id) {\r\n      try {\r\n        const adminSupabase = createAdminClient();\r\n        await adminSupabase\r\n          .from('cleaners')\r\n          .update({ auth_user_id: data.user.id })\r\n          .eq('id', cleaner.id);\r\n      } catch (updateError) {\r\n        // Log but don't fail - auth_user_id update is optional\r\n        console.warn('Could not update auth_user_id:', updateError);\r\n      }\r\n    }\r\n\r\n    return { success: true, cleaner };\r\n  } catch (error) {\r\n    console.error('Error in authenticateCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Authentication failed',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get current authenticated cleaner\r\n */\r\nexport async function getCurrentCleaner(): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    // Try to find cleaner by auth_user_id first\r\n    let cleanerQuery = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('auth_user_id', user.id)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    let { data: cleaner, error: cleanerError } = await cleanerQuery;\r\n\r\n    // If not found by auth_user_id, try to match by phone from email\r\n    if (!cleaner && !cleanerError && user.email) {\r\n      // Extract phone from email format: {phone}@cleaners.shalean.local\r\n      const phoneMatch = user.email.match(/^(.+)@cleaners\\.shalean\\.local$/);\r\n      if (phoneMatch) {\r\n        const phone = phoneMatch[1];\r\n        const phoneResult = await getCleanerByPhone(phone);\r\n        if (phoneResult.success && phoneResult.cleaner) {\r\n          cleaner = phoneResult.cleaner;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner profile not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: cleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCurrentCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get bookings assigned to the authenticated cleaner\r\n */\r\nexport async function getCleanerBookings(\r\n  filter?: 'all' | 'today' | 'upcoming' | 'past' | 'on_my_way' | 'started'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n    \r\n    // Fetch bookings where cleaner is assigned via preferred_cleaner_id (single)\r\n    let singleQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter\r\n    let arrayQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Apply filters to both queries\r\n    if (filter && filter !== 'all') {\r\n      const today = new Date().toISOString().split('T')[0];\r\n      \r\n      switch (filter) {\r\n        case 'today':\r\n          singleQuery = singleQuery.eq('service_date', today);\r\n          arrayQuery = arrayQuery.eq('service_date', today);\r\n          break;\r\n        case 'upcoming':\r\n          singleQuery = singleQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          arrayQuery = arrayQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          break;\r\n        case 'past':\r\n          singleQuery = singleQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          arrayQuery = arrayQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          break;\r\n        case 'on_my_way':\r\n          singleQuery = singleQuery.eq('status', 'on_my_way');\r\n          arrayQuery = arrayQuery.eq('status', 'on_my_way');\r\n          break;\r\n        case 'started':\r\n          singleQuery = singleQuery.eq('status', 'started');\r\n          arrayQuery = arrayQuery.eq('status', 'started');\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Execute both queries\r\n    const [singleResult, arrayResult] = await Promise.all([\r\n      singleQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true }),\r\n      arrayQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true })\r\n    ]);\r\n\r\n    if (singleResult.error) {\r\n      console.error('Error fetching cleaner bookings (single):', singleResult.error);\r\n      return { success: false, error: singleResult.error.message };\r\n    }\r\n\r\n    if (arrayResult.error) {\r\n      console.error('Error fetching cleaner bookings (array):', arrayResult.error);\r\n      return { success: false, error: arrayResult.error.message };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerBookings] Fetched bookings:', {\r\n      cleanerId,\r\n      filter,\r\n      singleBookingsCount: singleResult.data?.length || 0,\r\n      arrayBookingsCount: arrayResult.data?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const filteredArrayBookings = (arrayResult.data || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine results and remove duplicates\r\n    const allBookings = [\r\n      ...(singleResult.data || []),\r\n      ...filteredArrayBookings\r\n    ];\r\n\r\n    // Remove duplicates by booking ID\r\n    const uniqueBookingsMap = new Map<string, Booking>();\r\n    allBookings.forEach((booking: any) => {\r\n      if (booking.id && !uniqueBookingsMap.has(booking.id)) {\r\n        uniqueBookingsMap.set(booking.id, booking as Booking);\r\n      }\r\n    });\r\n\r\n    const bookings = Array.from(uniqueBookingsMap.values());\r\n\r\n    // Sort by service_date and service_time\r\n    bookings.sort((a, b) => {\r\n      const dateCompare = a.service_date.localeCompare(b.service_date);\r\n      if (dateCompare !== 0) return dateCompare;\r\n      return a.service_time.localeCompare(b.service_time);\r\n    });\r\n\r\n    return { success: true, bookings };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate cleaner earnings for a specific booking\r\n * This helper function is used to display earnings on booking details page\r\n */\r\nexport async function calculateBookingEarnings(bookingId: string): Promise<{\r\n  success: boolean;\r\n  earnings?: {\r\n    baseEarnings: number;\r\n    tipAmount: number;\r\n    totalEarnings: number;\r\n    earningsPercentage: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get the booking\r\n    const { data: booking, error: bookingError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (bookingError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Calculate tenure and total hours to determine percentage\r\n    // For single booking display, we need all paid completed bookings to calculate hours\r\n    // Use the same approach as getCleanerStats\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate base earnings\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const baseEarnings = calculateCleanerEarnings(\r\n      {\r\n        service_type: booking.service_type || '',\r\n        total_amount: Number(booking.total_amount) || 0,\r\n        service_fee: Number(booking.service_fee) || 0,\r\n        equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n        additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n        preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n        preferred_cleaner_id: booking.preferred_cleaner_id,\r\n      },\r\n      cleanerId,\r\n      earningsPercentage,\r\n      booking.preferred_cleaner_ids\r\n    );\r\n\r\n    // Calculate tip per cleaner\r\n    const tipAmount = calculateTipPerCleaner(\r\n      Number(booking.tip_amount) || 0,\r\n      booking.preferred_cleaner_ids,\r\n      booking.preferred_cleaner_id\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      earnings: {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n        earningsPercentage,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error calculating booking earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get a specific booking by ID (only if assigned to authenticated cleaner)\r\n */\r\nexport async function getCleanerBookingById(\r\n  bookingId: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Fetch the booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError) {\r\n      console.error('Error fetching booking:', fetchError);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    if (!booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Verify the cleaner is assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    // Check single cleaner assignment\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    // Check multiple cleaner assignment\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    if (!isAssignedSingle && !isAssignedMultiple) {\r\n      return { \r\n        success: false, \r\n        error: 'Unauthorized: You are not assigned to this booking' \r\n      };\r\n    }\r\n\r\n    return { success: true, booking: booking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookingById:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch booking',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update booking status (with authorization check for authenticated cleaner)\r\n */\r\nexport async function updateBookingStatus(\r\n  bookingId: string,\r\n  status: Booking['status']\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // First, verify the cleaner is assigned to this booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Validate status transition\r\n    const validTransitions: Record<string, string[]> = {\r\n      'pending': ['confirmed', 'cancelled'],\r\n      'confirmed': ['on_my_way', 'cancelled'],\r\n      'on_my_way': ['started', 'cancelled'],\r\n      'started': ['completed', 'cancelled'],\r\n      'completed': [],\r\n      'cancelled': [],\r\n    };\r\n\r\n    const currentStatus = booking.status;\r\n    const allowedStatuses = validTransitions[currentStatus] || [];\r\n    \r\n    if (!allowedStatuses.includes(status) && status !== currentStatus) {\r\n      return { \r\n        success: false, \r\n        error: `Invalid status transition: cannot change from ${currentStatus} to ${status}` \r\n      };\r\n    }\r\n\r\n    // Update booking status\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({ \r\n        status,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating booking status:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in updateBookingStatus:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update booking status',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Report lateness for a booking (with authorization check for authenticated cleaner)\r\n */\r\nexport async function reportLateness(\r\n  bookingId: string,\r\n  expectedArrivalTime: string, // ISO timestamp\r\n  reason: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Verify authorization\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Update booking with lateness information\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        expected_arrival_time: expectedArrivalTime,\r\n        lateness_reason: reason,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error reporting lateness:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in reportLateness:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to report lateness',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate earnings for multiple bookings at once\r\n * This is more efficient than calculating earnings one booking at a time\r\n */\r\nexport async function calculateBookingsEarnings(bookingIds: string[]): Promise<{\r\n  success: boolean;\r\n  earnings?: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }>;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    if (bookingIds.length === 0) {\r\n      return { success: true, earnings: {} };\r\n    }\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (bookingsError || !bookings) {\r\n      return { success: false, error: 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Get all cleaner bookings to calculate hours\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    // Calculate tenure and hours\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings for each booking\r\n    const earningsRecord: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }> = {};\r\n\r\n    for (const booking of bookings) {\r\n      const baseEarnings = calculateCleanerEarnings(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage,\r\n        booking.preferred_cleaner_ids\r\n      );\r\n\r\n      const tipAmount = calculateTipPerCleaner(\r\n        Number(booking.tip_amount) || 0,\r\n        booking.preferred_cleaner_ids,\r\n        booking.preferred_cleaner_id\r\n      );\r\n\r\n      earningsRecord[booking.id] = {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n      };\r\n    }\r\n\r\n    return { success: true, earnings: earningsRecord };\r\n  } catch (error) {\r\n    console.error('Error calculating bookings earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get cleaner statistics for the authenticated cleaner\r\n */\r\nexport async function getCleanerStats(): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalBookings: number;\r\n    completedBookings: number;\r\n    upcomingBookings: number;\r\n    todayBookings: number;\r\n    totalEarnings: number;\r\n    monthlyEarnings: number;\r\n    averageRating: number;\r\n    reliabilityScore: number;\r\n    completionRate: number;\r\n    onTimeRate: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info including created_at for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('rating, reliability_score, total_bookings, completed_bookings, on_time_bookings, created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings assigned to this cleaner\r\n    // Fetch bookings with preferred_cleaner_id (single) - include all fields needed for earnings calculation\r\n    const { data: singleBookings, error: singleError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter in JS\r\n    const { data: allMultiBookings, error: multiError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_ids, preferred_cleaner_id')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    if (singleError || multiError) {\r\n      console.error('Error fetching bookings for stats:', singleError || multiError);\r\n      return { success: false, error: (singleError || multiError)?.message || 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerStats] Fetched bookings:', {\r\n      cleanerId,\r\n      singleBookingsCount: singleBookings?.length || 0,\r\n      allMultiBookingsCount: allMultiBookings?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const arrayBookings = (allMultiBookings || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates by ID\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((booking: any) => {\r\n      if (booking.id) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    arrayBookings.forEach((booking: any) => {\r\n      if (booking.id && !allBookingsMap.has(booking.id)) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    \r\n    const allBookings = Array.from(allBookingsMap.values());\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n    const now = new Date();\r\n    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];\r\n    const completedBookings = allBookings.filter(b => b.status === 'completed');\r\n    const upcomingBookings = allBookings.filter(b => \r\n      ['pending', 'confirmed', 'on_my_way', 'started'].includes(b.status) &&\r\n      b.service_date >= today\r\n    );\r\n    const todayBookings = allBookings.filter(b => b.service_date === today);\r\n    const paidBookings = allBookings.filter(b => b.payment_status === 'paid');\r\n    const monthlyPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid' && \r\n      b.service_date >= firstDayOfMonth\r\n    );\r\n    const completedPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid'\r\n    );\r\n\r\n    // Calculate cleaner tenure and total hours for eligibility determination\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(allBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings using the new system\r\n    // Only calculate earnings for paid bookings (earnings are only paid when customer has paid)\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const totalEarnings = completedPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const monthlyEarnings = monthlyPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const completionRate = cleaner.total_bookings \r\n      ? (cleaner.completed_bookings || 0) / cleaner.total_bookings * 100 \r\n      : 0;\r\n    \r\n    const onTimeRate = cleaner.completed_bookings\r\n      ? (cleaner.on_time_bookings || 0) / cleaner.completed_bookings * 100\r\n      : 0;\r\n\r\n    return {\r\n      success: true,\r\n      stats: {\r\n        totalBookings: allBookings.length,\r\n        completedBookings: completedBookings.length,\r\n        upcomingBookings: upcomingBookings.length,\r\n        todayBookings: todayBookings.length,\r\n        totalEarnings,\r\n        monthlyEarnings,\r\n        averageRating: Number(cleaner.rating) || 0,\r\n        reliabilityScore: Number(cleaner.reliability_score) || 0,\r\n        completionRate,\r\n        onTimeRate,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update cleaner availability\r\n */\r\nexport async function updateCleanerAvailability(\r\n  cleanerId: string,\r\n  updates: {\r\n    isAvailable?: boolean;\r\n    availableMonday?: boolean;\r\n    availableTuesday?: boolean;\r\n    availableWednesday?: boolean;\r\n    availableThursday?: boolean;\r\n    availableFriday?: boolean;\r\n    availableSaturday?: boolean;\r\n    availableSunday?: boolean;\r\n  }\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (updates.isAvailable !== undefined) {\r\n      updateData.is_available = updates.isAvailable;\r\n    }\r\n    if (updates.availableMonday !== undefined) {\r\n      updateData.available_monday = updates.availableMonday;\r\n    }\r\n    if (updates.availableTuesday !== undefined) {\r\n      updateData.available_tuesday = updates.availableTuesday;\r\n    }\r\n    if (updates.availableWednesday !== undefined) {\r\n      updateData.available_wednesday = updates.availableWednesday;\r\n    }\r\n    if (updates.availableThursday !== undefined) {\r\n      updateData.available_thursday = updates.availableThursday;\r\n    }\r\n    if (updates.availableFriday !== undefined) {\r\n      updateData.available_friday = updates.availableFriday;\r\n    }\r\n    if (updates.availableSaturday !== undefined) {\r\n      updateData.available_saturday = updates.availableSaturday;\r\n    }\r\n    if (updates.availableSunday !== undefined) {\r\n      updateData.available_sunday = updates.availableSunday;\r\n    }\r\n\r\n    const { data: updatedCleaner, error } = await supabase\r\n      .from('cleaners')\r\n      .update(updateData)\r\n      .eq('id', cleanerId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error updating cleaner availability:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, cleaner: updatedCleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in updateCleanerAvailability:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update availability',\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAuLsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,sDAAA"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { createAdminClient } from '@/lib/supabase/server-admin';\r\nimport { Booking } from '@/types/booking';\r\nimport { Cleaner } from '@/types/booking';\r\nimport {\r\n  calculateCleanerTenure,\r\n  calculateTotalHours,\r\n  getEarningsPercentage,\r\n  calculateTotalEarningsFromBooking,\r\n  calculateCleanerEarnings,\r\n  calculateTipPerCleaner,\r\n} from '@/lib/utils/cleaner-earnings';\r\n\r\n/**\r\n * Get cleaner by phone number\r\n */\r\nexport async function getCleanerByPhone(phone: string): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    \r\n    // Normalize phone number (remove spaces, dashes, etc.)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    \r\n    const { data, error } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .or(`phone.eq.${normalizedPhone},phone.eq.+${normalizedPhone}`)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaner by phone:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!data) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: data as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerByPhone:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Authenticate cleaner with phone and password\r\n * Uses Supabase Auth - expects email format: {phone}@cleaners.shalean.local\r\n * Admin should create auth accounts with this email format when creating cleaner accounts\r\n */\r\nexport async function authenticateCleaner(\r\n  phone: string,\r\n  password: string\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // First, find the cleaner by phone to verify they exist\r\n    const cleanerResult = await getCleanerByPhone(phone);\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    const cleaner = cleanerResult.cleaner;\r\n\r\n    // Use phone-based email format for login\r\n    // Format: {phone}@cleaners.shalean.local\r\n    // Normalize phone (remove spaces, keep + if present)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    const authEmail = `${normalizedPhone}@cleaners.shalean.local`;\r\n\r\n    // Authenticate with Supabase Auth using client-side (this should be called from client)\r\n    // Note: This function should ideally be called from a client component\r\n    // For server-side, we'll return the cleaner info and let client handle auth\r\n    const supabase = await createClient();\r\n    \r\n    // Try to authenticate\r\n    const { data, error } = await supabase.auth.signInWithPassword({\r\n      email: authEmail,\r\n      password,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Authentication error:', error);\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Authentication failed' };\r\n    }\r\n\r\n    // Update cleaner's auth_user_id if not set\r\n    if (!cleaner.auth_user_id) {\r\n      try {\r\n        const adminSupabase = createAdminClient();\r\n        await adminSupabase\r\n          .from('cleaners')\r\n          .update({ auth_user_id: data.user.id })\r\n          .eq('id', cleaner.id);\r\n      } catch (updateError) {\r\n        // Log but don't fail - auth_user_id update is optional\r\n        console.warn('Could not update auth_user_id:', updateError);\r\n      }\r\n    }\r\n\r\n    return { success: true, cleaner };\r\n  } catch (error) {\r\n    console.error('Error in authenticateCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Authentication failed',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get current authenticated cleaner\r\n */\r\nexport async function getCurrentCleaner(): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    // Try to find cleaner by auth_user_id first\r\n    let cleanerQuery = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('auth_user_id', user.id)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    let { data: cleaner, error: cleanerError } = await cleanerQuery;\r\n\r\n    // If not found by auth_user_id, try to match by phone from email\r\n    if (!cleaner && !cleanerError && user.email) {\r\n      // Extract phone from email format: {phone}@cleaners.shalean.local\r\n      const phoneMatch = user.email.match(/^(.+)@cleaners\\.shalean\\.local$/);\r\n      if (phoneMatch) {\r\n        const phone = phoneMatch[1];\r\n        const phoneResult = await getCleanerByPhone(phone);\r\n        if (phoneResult.success && phoneResult.cleaner) {\r\n          cleaner = phoneResult.cleaner;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner profile not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: cleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCurrentCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get bookings assigned to the authenticated cleaner\r\n */\r\nexport async function getCleanerBookings(\r\n  filter?: 'all' | 'today' | 'upcoming' | 'past' | 'on_my_way' | 'started'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n    \r\n    // Fetch bookings where cleaner is assigned via preferred_cleaner_id (single)\r\n    let singleQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter\r\n    let arrayQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Apply filters to both queries\r\n    if (filter && filter !== 'all') {\r\n      const today = new Date().toISOString().split('T')[0];\r\n      \r\n      switch (filter) {\r\n        case 'today':\r\n          singleQuery = singleQuery.eq('service_date', today);\r\n          arrayQuery = arrayQuery.eq('service_date', today);\r\n          break;\r\n        case 'upcoming':\r\n          singleQuery = singleQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          arrayQuery = arrayQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          break;\r\n        case 'past':\r\n          singleQuery = singleQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          arrayQuery = arrayQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          break;\r\n        case 'on_my_way':\r\n          singleQuery = singleQuery.eq('status', 'on_my_way');\r\n          arrayQuery = arrayQuery.eq('status', 'on_my_way');\r\n          break;\r\n        case 'started':\r\n          singleQuery = singleQuery.eq('status', 'started');\r\n          arrayQuery = arrayQuery.eq('status', 'started');\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Execute both queries\r\n    const [singleResult, arrayResult] = await Promise.all([\r\n      singleQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true }),\r\n      arrayQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true })\r\n    ]);\r\n\r\n    if (singleResult.error) {\r\n      console.error('Error fetching cleaner bookings (single):', singleResult.error);\r\n      return { success: false, error: singleResult.error.message };\r\n    }\r\n\r\n    if (arrayResult.error) {\r\n      console.error('Error fetching cleaner bookings (array):', arrayResult.error);\r\n      return { success: false, error: arrayResult.error.message };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerBookings] Fetched bookings:', {\r\n      cleanerId,\r\n      filter,\r\n      singleBookingsCount: singleResult.data?.length || 0,\r\n      arrayBookingsCount: arrayResult.data?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const filteredArrayBookings = (arrayResult.data || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine results and remove duplicates\r\n    const allBookings = [\r\n      ...(singleResult.data || []),\r\n      ...filteredArrayBookings\r\n    ];\r\n\r\n    // Remove duplicates by booking ID\r\n    const uniqueBookingsMap = new Map<string, Booking>();\r\n    allBookings.forEach((booking: any) => {\r\n      if (booking.id && !uniqueBookingsMap.has(booking.id)) {\r\n        uniqueBookingsMap.set(booking.id, booking as Booking);\r\n      }\r\n    });\r\n\r\n    const bookings = Array.from(uniqueBookingsMap.values());\r\n\r\n    // Sort by service_date and service_time\r\n    bookings.sort((a, b) => {\r\n      const dateCompare = a.service_date.localeCompare(b.service_date);\r\n      if (dateCompare !== 0) return dateCompare;\r\n      return a.service_time.localeCompare(b.service_time);\r\n    });\r\n\r\n    return { success: true, bookings };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate cleaner earnings for a specific booking\r\n * This helper function is used to display earnings on booking details page\r\n */\r\nexport async function calculateBookingEarnings(bookingId: string): Promise<{\r\n  success: boolean;\r\n  earnings?: {\r\n    baseEarnings: number;\r\n    tipAmount: number;\r\n    totalEarnings: number;\r\n    earningsPercentage: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get the booking\r\n    const { data: booking, error: bookingError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (bookingError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Calculate tenure and total hours to determine percentage\r\n    // For single booking display, we need all paid completed bookings to calculate hours\r\n    // Use the same approach as getCleanerStats\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate base earnings\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const baseEarnings = calculateCleanerEarnings(\r\n      {\r\n        service_type: booking.service_type || '',\r\n        total_amount: Number(booking.total_amount) || 0,\r\n        service_fee: Number(booking.service_fee) || 0,\r\n        equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n        additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n        preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n        preferred_cleaner_id: booking.preferred_cleaner_id,\r\n      },\r\n      cleanerId,\r\n      earningsPercentage,\r\n      booking.preferred_cleaner_ids\r\n    );\r\n\r\n    // Calculate tip per cleaner\r\n    const tipAmount = calculateTipPerCleaner(\r\n      Number(booking.tip_amount) || 0,\r\n      booking.preferred_cleaner_ids,\r\n      booking.preferred_cleaner_id\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      earnings: {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n        earningsPercentage,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error calculating booking earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get a specific booking by ID (only if assigned to authenticated cleaner)\r\n */\r\nexport async function getCleanerBookingById(\r\n  bookingId: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Fetch the booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError) {\r\n      console.error('Error fetching booking:', fetchError);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    if (!booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Verify the cleaner is assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    // Check single cleaner assignment\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    // Check multiple cleaner assignment\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    if (!isAssignedSingle && !isAssignedMultiple) {\r\n      return { \r\n        success: false, \r\n        error: 'Unauthorized: You are not assigned to this booking' \r\n      };\r\n    }\r\n\r\n    return { success: true, booking: booking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookingById:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch booking',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update booking status (with authorization check for authenticated cleaner)\r\n */\r\nexport async function updateBookingStatus(\r\n  bookingId: string,\r\n  status: Booking['status']\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // First, verify the cleaner is assigned to this booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Validate status transition\r\n    const validTransitions: Record<string, string[]> = {\r\n      'pending': ['confirmed', 'cancelled'],\r\n      'confirmed': ['on_my_way', 'cancelled'],\r\n      'on_my_way': ['started', 'cancelled'],\r\n      'started': ['completed', 'cancelled'],\r\n      'completed': [],\r\n      'cancelled': [],\r\n    };\r\n\r\n    const currentStatus = booking.status;\r\n    const allowedStatuses = validTransitions[currentStatus] || [];\r\n    \r\n    if (!allowedStatuses.includes(status) && status !== currentStatus) {\r\n      return { \r\n        success: false, \r\n        error: `Invalid status transition: cannot change from ${currentStatus} to ${status}` \r\n      };\r\n    }\r\n\r\n    // Update booking status\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({ \r\n        status,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating booking status:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in updateBookingStatus:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update booking status',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Report lateness for a booking (with authorization check for authenticated cleaner)\r\n */\r\nexport async function reportLateness(\r\n  bookingId: string,\r\n  expectedArrivalTime: string, // ISO timestamp\r\n  reason: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Verify authorization\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Update booking with lateness information\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        expected_arrival_time: expectedArrivalTime,\r\n        lateness_reason: reason,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error reporting lateness:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in reportLateness:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to report lateness',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate earnings for multiple bookings at once\r\n * This is more efficient than calculating earnings one booking at a time\r\n */\r\nexport async function calculateBookingsEarnings(bookingIds: string[]): Promise<{\r\n  success: boolean;\r\n  earnings?: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }>;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    if (bookingIds.length === 0) {\r\n      return { success: true, earnings: {} };\r\n    }\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (bookingsError || !bookings) {\r\n      return { success: false, error: 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Get all cleaner bookings to calculate hours\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    // Calculate tenure and hours\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings for each booking\r\n    const earningsRecord: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }> = {};\r\n\r\n    for (const booking of bookings) {\r\n      const baseEarnings = calculateCleanerEarnings(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage,\r\n        booking.preferred_cleaner_ids\r\n      );\r\n\r\n      const tipAmount = calculateTipPerCleaner(\r\n        Number(booking.tip_amount) || 0,\r\n        booking.preferred_cleaner_ids,\r\n        booking.preferred_cleaner_id\r\n      );\r\n\r\n      earningsRecord[booking.id] = {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n      };\r\n    }\r\n\r\n    return { success: true, earnings: earningsRecord };\r\n  } catch (error) {\r\n    console.error('Error calculating bookings earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get cleaner statistics for the authenticated cleaner\r\n */\r\nexport async function getCleanerStats(): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalBookings: number;\r\n    completedBookings: number;\r\n    upcomingBookings: number;\r\n    todayBookings: number;\r\n    totalEarnings: number;\r\n    monthlyEarnings: number;\r\n    averageRating: number;\r\n    reliabilityScore: number;\r\n    completionRate: number;\r\n    onTimeRate: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info including created_at for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('rating, reliability_score, total_bookings, completed_bookings, on_time_bookings, created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings assigned to this cleaner\r\n    // Fetch bookings with preferred_cleaner_id (single) - include all fields needed for earnings calculation\r\n    const { data: singleBookings, error: singleError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter in JS\r\n    const { data: allMultiBookings, error: multiError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_ids, preferred_cleaner_id')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    if (singleError || multiError) {\r\n      console.error('Error fetching bookings for stats:', singleError || multiError);\r\n      return { success: false, error: (singleError || multiError)?.message || 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerStats] Fetched bookings:', {\r\n      cleanerId,\r\n      singleBookingsCount: singleBookings?.length || 0,\r\n      allMultiBookingsCount: allMultiBookings?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const arrayBookings = (allMultiBookings || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates by ID\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((booking: any) => {\r\n      if (booking.id) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    arrayBookings.forEach((booking: any) => {\r\n      if (booking.id && !allBookingsMap.has(booking.id)) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    \r\n    const allBookings = Array.from(allBookingsMap.values());\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n    const now = new Date();\r\n    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];\r\n    const completedBookings = allBookings.filter(b => b.status === 'completed');\r\n    const upcomingBookings = allBookings.filter(b => \r\n      ['pending', 'confirmed', 'on_my_way', 'started'].includes(b.status) &&\r\n      b.service_date >= today\r\n    );\r\n    const todayBookings = allBookings.filter(b => b.service_date === today);\r\n    const paidBookings = allBookings.filter(b => b.payment_status === 'paid');\r\n    const monthlyPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid' && \r\n      b.service_date >= firstDayOfMonth\r\n    );\r\n    const completedPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid'\r\n    );\r\n\r\n    // Calculate cleaner tenure and total hours for eligibility determination\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(allBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings using the new system\r\n    // Only calculate earnings for paid bookings (earnings are only paid when customer has paid)\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const totalEarnings = completedPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const monthlyEarnings = monthlyPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const completionRate = cleaner.total_bookings \r\n      ? (cleaner.completed_bookings || 0) / cleaner.total_bookings * 100 \r\n      : 0;\r\n    \r\n    const onTimeRate = cleaner.completed_bookings\r\n      ? (cleaner.on_time_bookings || 0) / cleaner.completed_bookings * 100\r\n      : 0;\r\n\r\n    return {\r\n      success: true,\r\n      stats: {\r\n        totalBookings: allBookings.length,\r\n        completedBookings: completedBookings.length,\r\n        upcomingBookings: upcomingBookings.length,\r\n        todayBookings: todayBookings.length,\r\n        totalEarnings,\r\n        monthlyEarnings,\r\n        averageRating: Number(cleaner.rating) || 0,\r\n        reliabilityScore: Number(cleaner.reliability_score) || 0,\r\n        completionRate,\r\n        onTimeRate,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update cleaner availability\r\n */\r\nexport async function updateCleanerAvailability(\r\n  cleanerId: string,\r\n  updates: {\r\n    isAvailable?: boolean;\r\n    availableMonday?: boolean;\r\n    availableTuesday?: boolean;\r\n    availableWednesday?: boolean;\r\n    availableThursday?: boolean;\r\n    availableFriday?: boolean;\r\n    availableSaturday?: boolean;\r\n    availableSunday?: boolean;\r\n  }\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (updates.isAvailable !== undefined) {\r\n      updateData.is_available = updates.isAvailable;\r\n    }\r\n    if (updates.availableMonday !== undefined) {\r\n      updateData.available_monday = updates.availableMonday;\r\n    }\r\n    if (updates.availableTuesday !== undefined) {\r\n      updateData.available_tuesday = updates.availableTuesday;\r\n    }\r\n    if (updates.availableWednesday !== undefined) {\r\n      updateData.available_wednesday = updates.availableWednesday;\r\n    }\r\n    if (updates.availableThursday !== undefined) {\r\n      updateData.available_thursday = updates.availableThursday;\r\n    }\r\n    if (updates.availableFriday !== undefined) {\r\n      updateData.available_friday = updates.availableFriday;\r\n    }\r\n    if (updates.availableSaturday !== undefined) {\r\n      updateData.available_saturday = updates.availableSaturday;\r\n    }\r\n    if (updates.availableSunday !== undefined) {\r\n      updateData.available_sunday = updates.availableSunday;\r\n    }\r\n\r\n    const { data: updatedCleaner, error } = await supabase\r\n      .from('cleaners')\r\n      .update(updateData)\r\n      .eq('id', cleanerId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error updating cleaner availability:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, cleaner: updatedCleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in updateCleanerAvailability:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update availability',\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAm1BsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,mDAAA"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { createAdminClient } from '@/lib/supabase/server-admin';\r\nimport { Booking } from '@/types/booking';\r\nimport { Cleaner } from '@/types/booking';\r\nimport {\r\n  calculateCleanerTenure,\r\n  calculateTotalHours,\r\n  getEarningsPercentage,\r\n  calculateTotalEarningsFromBooking,\r\n  calculateCleanerEarnings,\r\n  calculateTipPerCleaner,\r\n} from '@/lib/utils/cleaner-earnings';\r\n\r\n/**\r\n * Get cleaner by phone number\r\n */\r\nexport async function getCleanerByPhone(phone: string): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    \r\n    // Normalize phone number (remove spaces, dashes, etc.)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    \r\n    const { data, error } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .or(`phone.eq.${normalizedPhone},phone.eq.+${normalizedPhone}`)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaner by phone:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!data) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: data as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerByPhone:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Authenticate cleaner with phone and password\r\n * Uses Supabase Auth - expects email format: {phone}@cleaners.shalean.local\r\n * Admin should create auth accounts with this email format when creating cleaner accounts\r\n */\r\nexport async function authenticateCleaner(\r\n  phone: string,\r\n  password: string\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // First, find the cleaner by phone to verify they exist\r\n    const cleanerResult = await getCleanerByPhone(phone);\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    const cleaner = cleanerResult.cleaner;\r\n\r\n    // Use phone-based email format for login\r\n    // Format: {phone}@cleaners.shalean.local\r\n    // Normalize phone (remove spaces, keep + if present)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    const authEmail = `${normalizedPhone}@cleaners.shalean.local`;\r\n\r\n    // Authenticate with Supabase Auth using client-side (this should be called from client)\r\n    // Note: This function should ideally be called from a client component\r\n    // For server-side, we'll return the cleaner info and let client handle auth\r\n    const supabase = await createClient();\r\n    \r\n    // Try to authenticate\r\n    const { data, error } = await supabase.auth.signInWithPassword({\r\n      email: authEmail,\r\n      password,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Authentication error:', error);\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Authentication failed' };\r\n    }\r\n\r\n    // Update cleaner's auth_user_id if not set\r\n    if (!cleaner.auth_user_id) {\r\n      try {\r\n        const adminSupabase = createAdminClient();\r\n        await adminSupabase\r\n          .from('cleaners')\r\n          .update({ auth_user_id: data.user.id })\r\n          .eq('id', cleaner.id);\r\n      } catch (updateError) {\r\n        // Log but don't fail - auth_user_id update is optional\r\n        console.warn('Could not update auth_user_id:', updateError);\r\n      }\r\n    }\r\n\r\n    return { success: true, cleaner };\r\n  } catch (error) {\r\n    console.error('Error in authenticateCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Authentication failed',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get current authenticated cleaner\r\n */\r\nexport async function getCurrentCleaner(): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    // Try to find cleaner by auth_user_id first\r\n    let cleanerQuery = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('auth_user_id', user.id)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    let { data: cleaner, error: cleanerError } = await cleanerQuery;\r\n\r\n    // If not found by auth_user_id, try to match by phone from email\r\n    if (!cleaner && !cleanerError && user.email) {\r\n      // Extract phone from email format: {phone}@cleaners.shalean.local\r\n      const phoneMatch = user.email.match(/^(.+)@cleaners\\.shalean\\.local$/);\r\n      if (phoneMatch) {\r\n        const phone = phoneMatch[1];\r\n        const phoneResult = await getCleanerByPhone(phone);\r\n        if (phoneResult.success && phoneResult.cleaner) {\r\n          cleaner = phoneResult.cleaner;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner profile not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: cleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCurrentCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get bookings assigned to the authenticated cleaner\r\n */\r\nexport async function getCleanerBookings(\r\n  filter?: 'all' | 'today' | 'upcoming' | 'past' | 'on_my_way' | 'started'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n    \r\n    // Fetch bookings where cleaner is assigned via preferred_cleaner_id (single)\r\n    let singleQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter\r\n    let arrayQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Apply filters to both queries\r\n    if (filter && filter !== 'all') {\r\n      const today = new Date().toISOString().split('T')[0];\r\n      \r\n      switch (filter) {\r\n        case 'today':\r\n          singleQuery = singleQuery.eq('service_date', today);\r\n          arrayQuery = arrayQuery.eq('service_date', today);\r\n          break;\r\n        case 'upcoming':\r\n          singleQuery = singleQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          arrayQuery = arrayQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          break;\r\n        case 'past':\r\n          singleQuery = singleQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          arrayQuery = arrayQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          break;\r\n        case 'on_my_way':\r\n          singleQuery = singleQuery.eq('status', 'on_my_way');\r\n          arrayQuery = arrayQuery.eq('status', 'on_my_way');\r\n          break;\r\n        case 'started':\r\n          singleQuery = singleQuery.eq('status', 'started');\r\n          arrayQuery = arrayQuery.eq('status', 'started');\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Execute both queries\r\n    const [singleResult, arrayResult] = await Promise.all([\r\n      singleQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true }),\r\n      arrayQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true })\r\n    ]);\r\n\r\n    if (singleResult.error) {\r\n      console.error('Error fetching cleaner bookings (single):', singleResult.error);\r\n      return { success: false, error: singleResult.error.message };\r\n    }\r\n\r\n    if (arrayResult.error) {\r\n      console.error('Error fetching cleaner bookings (array):', arrayResult.error);\r\n      return { success: false, error: arrayResult.error.message };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerBookings] Fetched bookings:', {\r\n      cleanerId,\r\n      filter,\r\n      singleBookingsCount: singleResult.data?.length || 0,\r\n      arrayBookingsCount: arrayResult.data?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const filteredArrayBookings = (arrayResult.data || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine results and remove duplicates\r\n    const allBookings = [\r\n      ...(singleResult.data || []),\r\n      ...filteredArrayBookings\r\n    ];\r\n\r\n    // Remove duplicates by booking ID\r\n    const uniqueBookingsMap = new Map<string, Booking>();\r\n    allBookings.forEach((booking: any) => {\r\n      if (booking.id && !uniqueBookingsMap.has(booking.id)) {\r\n        uniqueBookingsMap.set(booking.id, booking as Booking);\r\n      }\r\n    });\r\n\r\n    const bookings = Array.from(uniqueBookingsMap.values());\r\n\r\n    // Sort by service_date and service_time\r\n    bookings.sort((a, b) => {\r\n      const dateCompare = a.service_date.localeCompare(b.service_date);\r\n      if (dateCompare !== 0) return dateCompare;\r\n      return a.service_time.localeCompare(b.service_time);\r\n    });\r\n\r\n    return { success: true, bookings };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate cleaner earnings for a specific booking\r\n * This helper function is used to display earnings on booking details page\r\n */\r\nexport async function calculateBookingEarnings(bookingId: string): Promise<{\r\n  success: boolean;\r\n  earnings?: {\r\n    baseEarnings: number;\r\n    tipAmount: number;\r\n    totalEarnings: number;\r\n    earningsPercentage: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get the booking\r\n    const { data: booking, error: bookingError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (bookingError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Calculate tenure and total hours to determine percentage\r\n    // For single booking display, we need all paid completed bookings to calculate hours\r\n    // Use the same approach as getCleanerStats\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate base earnings\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const baseEarnings = calculateCleanerEarnings(\r\n      {\r\n        service_type: booking.service_type || '',\r\n        total_amount: Number(booking.total_amount) || 0,\r\n        service_fee: Number(booking.service_fee) || 0,\r\n        equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n        additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n        preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n        preferred_cleaner_id: booking.preferred_cleaner_id,\r\n      },\r\n      cleanerId,\r\n      earningsPercentage,\r\n      booking.preferred_cleaner_ids\r\n    );\r\n\r\n    // Calculate tip per cleaner\r\n    const tipAmount = calculateTipPerCleaner(\r\n      Number(booking.tip_amount) || 0,\r\n      booking.preferred_cleaner_ids,\r\n      booking.preferred_cleaner_id\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      earnings: {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n        earningsPercentage,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error calculating booking earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get a specific booking by ID (only if assigned to authenticated cleaner)\r\n */\r\nexport async function getCleanerBookingById(\r\n  bookingId: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Fetch the booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError) {\r\n      console.error('Error fetching booking:', fetchError);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    if (!booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Verify the cleaner is assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    // Check single cleaner assignment\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    // Check multiple cleaner assignment\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    if (!isAssignedSingle && !isAssignedMultiple) {\r\n      return { \r\n        success: false, \r\n        error: 'Unauthorized: You are not assigned to this booking' \r\n      };\r\n    }\r\n\r\n    return { success: true, booking: booking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookingById:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch booking',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update booking status (with authorization check for authenticated cleaner)\r\n */\r\nexport async function updateBookingStatus(\r\n  bookingId: string,\r\n  status: Booking['status']\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // First, verify the cleaner is assigned to this booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Validate status transition\r\n    const validTransitions: Record<string, string[]> = {\r\n      'pending': ['confirmed', 'cancelled'],\r\n      'confirmed': ['on_my_way', 'cancelled'],\r\n      'on_my_way': ['started', 'cancelled'],\r\n      'started': ['completed', 'cancelled'],\r\n      'completed': [],\r\n      'cancelled': [],\r\n    };\r\n\r\n    const currentStatus = booking.status;\r\n    const allowedStatuses = validTransitions[currentStatus] || [];\r\n    \r\n    if (!allowedStatuses.includes(status) && status !== currentStatus) {\r\n      return { \r\n        success: false, \r\n        error: `Invalid status transition: cannot change from ${currentStatus} to ${status}` \r\n      };\r\n    }\r\n\r\n    // Update booking status\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({ \r\n        status,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating booking status:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in updateBookingStatus:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update booking status',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Report lateness for a booking (with authorization check for authenticated cleaner)\r\n */\r\nexport async function reportLateness(\r\n  bookingId: string,\r\n  expectedArrivalTime: string, // ISO timestamp\r\n  reason: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Verify authorization\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Update booking with lateness information\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        expected_arrival_time: expectedArrivalTime,\r\n        lateness_reason: reason,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error reporting lateness:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in reportLateness:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to report lateness',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate earnings for multiple bookings at once\r\n * This is more efficient than calculating earnings one booking at a time\r\n */\r\nexport async function calculateBookingsEarnings(bookingIds: string[]): Promise<{\r\n  success: boolean;\r\n  earnings?: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }>;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    if (bookingIds.length === 0) {\r\n      return { success: true, earnings: {} };\r\n    }\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (bookingsError || !bookings) {\r\n      return { success: false, error: 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Get all cleaner bookings to calculate hours\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    // Calculate tenure and hours\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings for each booking\r\n    const earningsRecord: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }> = {};\r\n\r\n    for (const booking of bookings) {\r\n      const baseEarnings = calculateCleanerEarnings(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage,\r\n        booking.preferred_cleaner_ids\r\n      );\r\n\r\n      const tipAmount = calculateTipPerCleaner(\r\n        Number(booking.tip_amount) || 0,\r\n        booking.preferred_cleaner_ids,\r\n        booking.preferred_cleaner_id\r\n      );\r\n\r\n      earningsRecord[booking.id] = {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n      };\r\n    }\r\n\r\n    return { success: true, earnings: earningsRecord };\r\n  } catch (error) {\r\n    console.error('Error calculating bookings earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get cleaner statistics for the authenticated cleaner\r\n */\r\nexport async function getCleanerStats(): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalBookings: number;\r\n    completedBookings: number;\r\n    upcomingBookings: number;\r\n    todayBookings: number;\r\n    totalEarnings: number;\r\n    monthlyEarnings: number;\r\n    averageRating: number;\r\n    reliabilityScore: number;\r\n    completionRate: number;\r\n    onTimeRate: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info including created_at for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('rating, reliability_score, total_bookings, completed_bookings, on_time_bookings, created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings assigned to this cleaner\r\n    // Fetch bookings with preferred_cleaner_id (single) - include all fields needed for earnings calculation\r\n    const { data: singleBookings, error: singleError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter in JS\r\n    const { data: allMultiBookings, error: multiError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_ids, preferred_cleaner_id')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    if (singleError || multiError) {\r\n      console.error('Error fetching bookings for stats:', singleError || multiError);\r\n      return { success: false, error: (singleError || multiError)?.message || 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerStats] Fetched bookings:', {\r\n      cleanerId,\r\n      singleBookingsCount: singleBookings?.length || 0,\r\n      allMultiBookingsCount: allMultiBookings?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const arrayBookings = (allMultiBookings || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates by ID\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((booking: any) => {\r\n      if (booking.id) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    arrayBookings.forEach((booking: any) => {\r\n      if (booking.id && !allBookingsMap.has(booking.id)) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    \r\n    const allBookings = Array.from(allBookingsMap.values());\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n    const now = new Date();\r\n    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];\r\n    const completedBookings = allBookings.filter(b => b.status === 'completed');\r\n    const upcomingBookings = allBookings.filter(b => \r\n      ['pending', 'confirmed', 'on_my_way', 'started'].includes(b.status) &&\r\n      b.service_date >= today\r\n    );\r\n    const todayBookings = allBookings.filter(b => b.service_date === today);\r\n    const paidBookings = allBookings.filter(b => b.payment_status === 'paid');\r\n    const monthlyPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid' && \r\n      b.service_date >= firstDayOfMonth\r\n    );\r\n    const completedPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid'\r\n    );\r\n\r\n    // Calculate cleaner tenure and total hours for eligibility determination\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(allBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings using the new system\r\n    // Only calculate earnings for paid bookings (earnings are only paid when customer has paid)\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const totalEarnings = completedPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const monthlyEarnings = monthlyPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const completionRate = cleaner.total_bookings \r\n      ? (cleaner.completed_bookings || 0) / cleaner.total_bookings * 100 \r\n      : 0;\r\n    \r\n    const onTimeRate = cleaner.completed_bookings\r\n      ? (cleaner.on_time_bookings || 0) / cleaner.completed_bookings * 100\r\n      : 0;\r\n\r\n    return {\r\n      success: true,\r\n      stats: {\r\n        totalBookings: allBookings.length,\r\n        completedBookings: completedBookings.length,\r\n        upcomingBookings: upcomingBookings.length,\r\n        todayBookings: todayBookings.length,\r\n        totalEarnings,\r\n        monthlyEarnings,\r\n        averageRating: Number(cleaner.rating) || 0,\r\n        reliabilityScore: Number(cleaner.reliability_score) || 0,\r\n        completionRate,\r\n        onTimeRate,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update cleaner availability\r\n */\r\nexport async function updateCleanerAvailability(\r\n  cleanerId: string,\r\n  updates: {\r\n    isAvailable?: boolean;\r\n    availableMonday?: boolean;\r\n    availableTuesday?: boolean;\r\n    availableWednesday?: boolean;\r\n    availableThursday?: boolean;\r\n    availableFriday?: boolean;\r\n    availableSaturday?: boolean;\r\n    availableSunday?: boolean;\r\n  }\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (updates.isAvailable !== undefined) {\r\n      updateData.is_available = updates.isAvailable;\r\n    }\r\n    if (updates.availableMonday !== undefined) {\r\n      updateData.available_monday = updates.availableMonday;\r\n    }\r\n    if (updates.availableTuesday !== undefined) {\r\n      updateData.available_tuesday = updates.availableTuesday;\r\n    }\r\n    if (updates.availableWednesday !== undefined) {\r\n      updateData.available_wednesday = updates.availableWednesday;\r\n    }\r\n    if (updates.availableThursday !== undefined) {\r\n      updateData.available_thursday = updates.availableThursday;\r\n    }\r\n    if (updates.availableFriday !== undefined) {\r\n      updateData.available_friday = updates.availableFriday;\r\n    }\r\n    if (updates.availableSaturday !== undefined) {\r\n      updateData.available_saturday = updates.availableSaturday;\r\n    }\r\n    if (updates.availableSunday !== undefined) {\r\n      updateData.available_sunday = updates.availableSunday;\r\n    }\r\n\r\n    const { data: updatedCleaner, error } = await supabase\r\n      .from('cleaners')\r\n      .update(updateData)\r\n      .eq('id', cleanerId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error updating cleaner availability:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, cleaner: updatedCleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in updateCleanerAvailability:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update availability',\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA8sBsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (\r\n  <div ref={ref} className={cn(\"rounded-lg border bg-card text-card-foreground shadow-sm\", className)} {...props} />\r\n));\r\nCard.displayName = \"Card\";\r\n\r\nconst CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex flex-col space-y-1.5 p-6\", className)} {...props} />\r\n  ),\r\n);\r\nCardHeader.displayName = \"CardHeader\";\r\n\r\nconst CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <h3 ref={ref} className={cn(\"text-2xl font-semibold leading-none tracking-tight\", className)} {...props} />\r\n  ),\r\n);\r\nCardTitle.displayName = \"CardTitle\";\r\n\r\nconst CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <p ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\r\n  ),\r\n);\r\nCardDescription.displayName = \"CardDescription\";\r\n\r\nconst CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />,\r\n);\r\nCardContent.displayName = \"CardContent\";\r\n\r\nconst CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div ref={ref} className={cn(\"flex items-center p-6 pt-0\", className)} {...props} />\r\n  ),\r\n);\r\nCardFooter.displayName = \"CardFooter\";\r\n\r\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,2KAAgB,MAAuD,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC5G,6LAAC;QAAI,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,4DAA4D;QAAa,GAAG,KAAK;;;;;;;AAEhH,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,2KAAgB,OACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,6LAAC;QAAI,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;;AAGvF,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,2KAAgB,OAChC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,6LAAC;QAAG,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,sDAAsD;QAAa,GAAG,KAAK;;;;;;;AAG3G,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,2KAAgB,OACtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,6LAAC;QAAE,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;;AAGrF,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,2KAAgB,OAClC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAAQ,6LAAC;QAAI,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,YAAY;QAAa,GAAG,KAAK;;;;;;;AAElG,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,2KAAgB,QACjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACxB,6LAAC;QAAI,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,8BAA8B;QAAa,GAAG,KAAK;;;;;;;AAGpF,WAAW,WAAW,GAAG"}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/alert-dialog.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\nimport { buttonVariants } from \"@/components/ui/button\";\r\n\r\nconst AlertDialog = AlertDialogPrimitive.Root;\r\n\r\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger;\r\n\r\nconst AlertDialogPortal = AlertDialogPrimitive.Portal;\r\n\r\nconst AlertDialogOverlay = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Overlay\r\n    className={cn(\r\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\r\n      className,\r\n    )}\r\n    {...props}\r\n    ref={ref}\r\n  />\r\n));\r\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;\r\n\r\nconst AlertDialogContent = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPortal>\r\n    <AlertDialogOverlay />\r\n    <AlertDialogPrimitive.Content\r\n      ref={ref}\r\n      className={cn(\r\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  </AlertDialogPortal>\r\n));\r\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;\r\n\r\nconst AlertDialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div className={cn(\"flex flex-col space-y-2 text-center sm:text-left\", className)} {...props} />\r\n);\r\nAlertDialogHeader.displayName = \"AlertDialogHeader\";\r\n\r\nconst AlertDialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div className={cn(\"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\", className)} {...props} />\r\n);\r\nAlertDialogFooter.displayName = \"AlertDialogFooter\";\r\n\r\nconst AlertDialogTitle = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Title ref={ref} className={cn(\"text-lg font-semibold\", className)} {...props} />\r\n));\r\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;\r\n\r\nconst AlertDialogDescription = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Description ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\r\n));\r\nAlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName;\r\n\r\nconst AlertDialogAction = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} />\r\n));\r\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;\r\n\r\nconst AlertDialogCancel = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Cancel\r\n    ref={ref}\r\n    className={cn(buttonVariants({ variant: \"outline\" }), \"mt-2 sm:mt-0\", className)}\r\n    {...props}\r\n  />\r\n));\r\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;\r\n\r\nexport {\r\n  AlertDialog,\r\n  AlertDialogPortal,\r\n  AlertDialogOverlay,\r\n  AlertDialogTrigger,\r\n  AlertDialogContent,\r\n  AlertDialogHeader,\r\n  AlertDialogFooter,\r\n  AlertDialogTitle,\r\n  AlertDialogDescription,\r\n  AlertDialogAction,\r\n  AlertDialogCancel,\r\n};\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;;;;;;AAEA,MAAM,cAAc,sLAAyB;AAE7C,MAAM,qBAAqB,yLAA4B;AAEvD,MAAM,oBAAoB,wLAA2B;AAErD,MAAM,mCAAqB,2KAAgB,CAGzC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,yLAA4B;QAC3B,WAAW,IAAA,4HAAE,EACX,0JACA;QAED,GAAG,KAAK;QACT,KAAK;;;;;;KAVH;AAaN,mBAAmB,WAAW,GAAG,yLAA4B,CAAC,WAAW;AAEzE,MAAM,mCAAqB,2KAAgB,OAGzC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;;0BACC,6LAAC;;;;;0BACD,6LAAC,yLAA4B;gBAC3B,KAAK;gBACL,WAAW,IAAA,4HAAE,EACX,+fACA;gBAED,GAAG,KAAK;;;;;;;;;;;;;AAIf,mBAAmB,WAAW,GAAG,yLAA4B,CAAC,WAAW;AAEzE,MAAM,oBAAoB,CAAC,EAAE,SAAS,EAAE,GAAG,OAA6C,iBACtF,6LAAC;QAAI,WAAW,IAAA,4HAAE,EAAC,oDAAoD;QAAa,GAAG,KAAK;;;;;;MADxF;AAGN,kBAAkB,WAAW,GAAG;AAEhC,MAAM,oBAAoB,CAAC,EAAE,SAAS,EAAE,GAAG,OAA6C,iBACtF,6LAAC;QAAI,WAAW,IAAA,4HAAE,EAAC,iEAAiE;QAAa,GAAG,KAAK;;;;;;MADrG;AAGN,kBAAkB,WAAW,GAAG;AAEhC,MAAM,iCAAmB,2KAAgB,OAGvC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,uLAA0B;QAAC,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,yBAAyB;QAAa,GAAG,KAAK;;;;;;;AAEpG,iBAAiB,WAAW,GAAG,uLAA0B,CAAC,WAAW;AAErE,MAAM,uCAAyB,2KAAgB,OAG7C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,6LAAgC;QAAC,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;;AAElH,uBAAuB,WAAW,GAAG,6LAAgC,CAAC,WAAW;AAEjF,MAAM,kCAAoB,2KAAgB,OAGxC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,wLAA2B;QAAC,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,IAAA,uJAAc,KAAI;QAAa,GAAG,KAAK;;;;;;;AAE9F,kBAAkB,WAAW,GAAG,wLAA2B,CAAC,WAAW;AAEvE,MAAM,kCAAoB,2KAAgB,QAGxC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,wLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,IAAA,uJAAc,EAAC;YAAE,SAAS;QAAU,IAAI,gBAAgB;QACrE,GAAG,KAAK;;;;;;;AAGb,kBAAkB,WAAW,GAAG,wLAA2B,CAAC,WAAW"}},
    {"offset": {"line": 322, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/components/BookingStatusButton.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useState } from 'react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Loader2 } from 'lucide-react';\r\nimport { toast } from 'sonner';\r\nimport { Booking } from '@/types/booking';\r\nimport {\r\n  AlertDialog,\r\n  AlertDialogAction,\r\n  AlertDialogCancel,\r\n  AlertDialogContent,\r\n  AlertDialogDescription,\r\n  AlertDialogFooter,\r\n  AlertDialogHeader,\r\n  AlertDialogTitle,\r\n} from '@/components/ui/alert-dialog';\r\n\r\ninterface BookingStatusButtonProps {\r\n  booking: Booking;\r\n  onStatusUpdate: (updatedBooking: Booking) => void;\r\n}\r\n\r\nexport function BookingStatusButton({ booking, onStatusUpdate }: BookingStatusButtonProps) {\r\n  const [isUpdating, setIsUpdating] = useState(false);\r\n  const [confirmDialog, setConfirmDialog] = useState<{\r\n    open: boolean;\r\n    newStatus: Booking['status'] | null;\r\n  }>({ open: false, newStatus: null });\r\n\r\n  const updateStatus = async (newStatus: Booking['status']) => {\r\n    setIsUpdating(true);\r\n\r\n    try {\r\n      const response = await fetch('/api/cleaner/update-booking-status', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          bookingId: booking.id,\r\n          status: newStatus,\r\n        }),\r\n      });\r\n\r\n      const result = await response.json();\r\n\r\n      if (!response.ok || !result.success) {\r\n        throw new Error(result.error || 'Failed to update booking status');\r\n      }\r\n\r\n      toast.success(`Booking status updated to ${newStatus.replace('_', ' ')}`);\r\n      onStatusUpdate(result.booking);\r\n      setConfirmDialog({ open: false, newStatus: null });\r\n    } catch (error) {\r\n      console.error('Error updating booking status:', error);\r\n      toast.error(error instanceof Error ? error.message : 'Failed to update booking status');\r\n    } finally {\r\n      setIsUpdating(false);\r\n    }\r\n  };\r\n\r\n  const handleStatusClick = (newStatus: Booking['status']) => {\r\n    // Show confirmation for critical actions\r\n    if (newStatus === 'cancelled' || newStatus === 'completed') {\r\n      setConfirmDialog({ open: true, newStatus });\r\n    } else {\r\n      updateStatus(newStatus);\r\n    }\r\n  };\r\n\r\n  const getAvailableActions = (): Array<{ status: Booking['status']; label: string; variant?: 'default' | 'outline' | 'destructive' }> => {\r\n    const actions: Array<{ status: Booking['status']; label: string; variant?: 'default' | 'outline' | 'destructive' }> = [];\r\n\r\n    switch (booking.status) {\r\n      case 'pending':\r\n        actions.push({ status: 'confirmed', label: 'Confirm', variant: 'default' });\r\n        actions.push({ status: 'cancelled', label: 'Cancel', variant: 'destructive' });\r\n        break;\r\n      case 'confirmed':\r\n        actions.push({ status: 'on_my_way', label: 'On My Way', variant: 'default' });\r\n        actions.push({ status: 'cancelled', label: 'Cancel', variant: 'destructive' });\r\n        break;\r\n      case 'on_my_way':\r\n        actions.push({ status: 'started', label: 'Start Work', variant: 'default' });\r\n        actions.push({ status: 'cancelled', label: 'Cancel', variant: 'destructive' });\r\n        break;\r\n      case 'started':\r\n        actions.push({ status: 'completed', label: 'Complete', variant: 'default' });\r\n        break;\r\n      case 'completed':\r\n      case 'cancelled':\r\n        // No actions available for completed/cancelled bookings\r\n        break;\r\n    }\r\n\r\n    return actions;\r\n  };\r\n\r\n  const availableActions = getAvailableActions();\r\n\r\n  if (availableActions.length === 0) {\r\n    return (\r\n      <div className=\"text-sm text-muted-foreground\">\r\n        Status: {booking.status.replace('_', ' ').replace(/\\b\\w/g, l => l.toUpperCase())}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <div className=\"flex flex-wrap gap-2\">\r\n        {availableActions.map((action) => (\r\n          <Button\r\n            key={action.status}\r\n            variant={action.variant || 'outline'}\r\n            size=\"sm\"\r\n            onClick={() => handleStatusClick(action.status)}\r\n            disabled={isUpdating}\r\n          >\r\n            {isUpdating ? (\r\n              <>\r\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\r\n                Updating...\r\n              </>\r\n            ) : (\r\n              action.label\r\n            )}\r\n          </Button>\r\n        ))}\r\n      </div>\r\n\r\n      <AlertDialog open={confirmDialog.open} onOpenChange={(open) => setConfirmDialog({ open, newStatus: null })}>\r\n        <AlertDialogContent>\r\n          <AlertDialogHeader>\r\n            <AlertDialogTitle>Confirm Action</AlertDialogTitle>\r\n            <AlertDialogDescription>\r\n              {confirmDialog.newStatus === 'completed' \r\n                ? 'Are you sure you want to mark this booking as completed? This action cannot be undone.'\r\n                : 'Are you sure you want to cancel this booking? This action should only be used in exceptional circumstances.'}\r\n            </AlertDialogDescription>\r\n          </AlertDialogHeader>\r\n          <AlertDialogFooter>\r\n            <AlertDialogCancel disabled={isUpdating}>Cancel</AlertDialogCancel>\r\n            <AlertDialogAction\r\n              onClick={() => confirmDialog.newStatus && updateStatus(confirmDialog.newStatus)}\r\n              disabled={isUpdating}\r\n              className={confirmDialog.newStatus === 'cancelled' ? 'bg-destructive text-destructive-foreground hover:bg-destructive/90' : ''}\r\n            >\r\n              {isUpdating ? (\r\n                <>\r\n                  <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\r\n                  Processing...\r\n                </>\r\n              ) : (\r\n                'Confirm'\r\n              )}\r\n            </AlertDialogAction>\r\n          </AlertDialogFooter>\r\n        </AlertDialogContent>\r\n      </AlertDialog>\r\n    </>\r\n  );\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 577, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/cleaner/%28dashboard%29/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useEffect, useState } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { getCurrentCleaner, getCleanerBookings, getCleanerStats, calculateBookingsEarnings } from '../actions';\r\nimport { Booking } from '@/types/booking';\r\nimport { Cleaner } from '@/types/booking';\r\nimport { Loader2, Calendar, CheckCircle2, Clock, DollarSign, TrendingUp } from 'lucide-react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { format, startOfWeek, endOfWeek, isWithinInterval, isToday } from 'date-fns';\r\nimport Link from 'next/link';\r\nimport { Button } from '@/components/ui/button';\r\nimport { ArrowRight } from 'lucide-react';\r\nimport { BookingStatusButton } from '../components/BookingStatusButton';\r\n\r\nexport default function CleanerDashboardPage() {\r\n  const [cleaner, setCleaner] = useState<Cleaner | null>(null);\r\n  const [bookings, setBookings] = useState<Booking[]>([]);\r\n  const [loading, setLoading] = useState(false);\r\n  const [stats, setStats] = useState<any>(null);\r\n  const [bookingsEarnings, setBookingsEarnings] = useState<Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }>>({});\r\n\r\n  // Get current cleaner\r\n  const { data: cleanerData } = useQuery({\r\n    queryKey: ['current-cleaner'],\r\n    queryFn: async () => {\r\n      const result = await getCurrentCleaner();\r\n      if (result.success && result.cleaner) {\r\n        setCleaner(result.cleaner);\r\n        return result.cleaner;\r\n      }\r\n      return null;\r\n    },\r\n    staleTime: 5 * 60 * 1000,\r\n  });\r\n\r\n  // Get cleaner stats\r\n  useQuery({\r\n    queryKey: ['cleaner-stats'],\r\n    queryFn: async () => {\r\n      const result = await getCleanerStats();\r\n      if (result.success && result.stats) {\r\n        setStats(result.stats);\r\n        return result.stats;\r\n      }\r\n      return null;\r\n    },\r\n    enabled: !!cleaner,\r\n    staleTime: 2 * 60 * 1000,\r\n  });\r\n\r\n  // Load bookings for display (use 'all' to get all bookings, then filter client-side)\r\n  const loadBookings = async () => {\r\n    try {\r\n      setLoading(true);\r\n      // Fetch all bookings to properly calculate today/week counts\r\n      const result = await getCleanerBookings('all');\r\n      if (result.success && result.bookings) {\r\n        setBookings(result.bookings || []);\r\n        \r\n        // Calculate earnings for all bookings\r\n        const bookingIds = (result.bookings || []).map(b => b.id);\r\n        if (bookingIds.length > 0) {\r\n          const earningsResult = await calculateBookingsEarnings(bookingIds);\r\n          if (earningsResult.success && earningsResult.earnings) {\r\n            setBookingsEarnings(earningsResult.earnings);\r\n          }\r\n        }\r\n      } else if (result.error) {\r\n        console.error('Error loading bookings:', result.error);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading bookings:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (cleaner) {\r\n      loadBookings();\r\n    }\r\n  }, [cleaner]);\r\n\r\n  // Handle booking status update\r\n  const handleStatusUpdate = (bookingId: string) => (updatedBooking: Booking) => {\r\n    setBookings(prevBookings => \r\n      prevBookings.map(booking => \r\n        booking.id === bookingId ? updatedBooking : booking\r\n      )\r\n    );\r\n    // Optionally refresh stats to reflect the update\r\n    if (cleaner) {\r\n      getCleanerStats().then((result) => {\r\n        if (result.success && result.stats) {\r\n          setStats(result.stats);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  // Filter bookings for display\r\n  // Use string comparison to match server-side stats calculation (avoids timezone issues)\r\n  const today = new Date().toISOString().split('T')[0]; // Format: YYYY-MM-DD\r\n  const todayBookings = bookings.filter(booking => \r\n    booking.service_date === today\r\n  );\r\n  \r\n  const todayDate = new Date();\r\n  const weekStart = startOfWeek(todayDate, { weekStartsOn: 1 });\r\n  const weekEnd = endOfWeek(todayDate, { weekStartsOn: 1 });\r\n  const weekBookings = bookings.filter(booking => {\r\n    const bookingDate = new Date(booking.service_date);\r\n    return isWithinInterval(bookingDate, { start: weekStart, end: weekEnd });\r\n  });\r\n\r\n  const upcomingBookings = bookings.filter(booking => {\r\n    // Compare dates as strings (YYYY-MM-DD) to match server-side logic\r\n    return booking.service_date >= today && ['pending', 'confirmed', 'on_my_way', 'started'].includes(booking.status);\r\n  });\r\n\r\n  return (\r\n    <div className=\"space-y-6 md:space-y-8 w-full max-w-full overflow-x-hidden\">\r\n      {/* Welcome Section */}\r\n      <div className=\"space-y-2\">\r\n        <h1 className=\"text-2xl sm:text-3xl md:text-4xl font-bold\">\r\n          Welcome back, {cleaner?.name || 'Cleaner'}!\r\n        </h1>\r\n        <p className=\"text-muted-foreground\">\r\n          Here's your overview for today\r\n        </p>\r\n      </div>\r\n\r\n      {/* Stats Cards */}\r\n      <div className=\"grid grid-cols-4 gap-1 sm:gap-2 md:gap-4 md:grid-cols-2 lg:grid-cols-4 w-full overflow-x-hidden\">\r\n        <Card className=\"overflow-hidden\">\r\n          <CardContent className=\"px-2 pb-2 sm:px-6 sm:pb-6 pt-3 sm:pt-6 flex flex-col\">\r\n            <Calendar className=\"h-6 w-6 sm:h-5 sm:w-5 md:h-4 md:w-4 text-muted-foreground mb-2 sm:mb-1 flex-shrink-0\" />\r\n            <CardTitle className=\"text-xs sm:text-sm md:text-base font-medium leading-tight mb-2 sm:mb-1\">Today</CardTitle>\r\n            <div className=\"text-base sm:text-xl md:text-2xl font-bold\">{stats?.todayBookings ?? todayBookings.length}</div>\r\n            <p className=\"text-[9px] sm:text-xs text-muted-foreground mt-0.5 sm:mt-1 leading-tight\">\r\n              {stats?.todayBookings ? `${todayBookings.filter(b => b.status === 'completed').length} completed` : '0 completed'}\r\n            </p>\r\n          </CardContent>\r\n        </Card>\r\n\r\n        <Card className=\"overflow-hidden\">\r\n          <CardContent className=\"px-2 pb-2 sm:px-6 sm:pb-6 pt-3 sm:pt-6 flex flex-col\">\r\n            <Clock className=\"h-6 w-6 sm:h-5 sm:w-5 md:h-4 md:w-4 text-muted-foreground mb-2 sm:mb-1 flex-shrink-0\" />\r\n            <CardTitle className=\"text-xs sm:text-sm md:text-base font-medium leading-tight mb-2 sm:mb-1\">Upcoming</CardTitle>\r\n            <div className=\"text-base sm:text-xl md:text-2xl font-bold\">{weekBookings.length}</div>\r\n            <p className=\"text-[9px] sm:text-xs text-muted-foreground mt-0.5 sm:mt-1 leading-tight\">\r\n              Upcoming bookings\r\n            </p>\r\n          </CardContent>\r\n        </Card>\r\n\r\n        <Card className=\"overflow-hidden\">\r\n          <CardContent className=\"px-2 pb-2 sm:px-6 sm:pb-6 pt-3 sm:pt-6 flex flex-col\">\r\n            <CheckCircle2 className=\"h-6 w-6 sm:h-5 sm:w-5 md:h-4 md:w-4 text-muted-foreground mb-2 sm:mb-1 flex-shrink-0\" />\r\n            <CardTitle className=\"text-xs sm:text-sm md:text-base font-medium leading-tight mb-2 sm:mb-1\">Completed</CardTitle>\r\n            <div className=\"text-base sm:text-xl md:text-2xl font-bold\">{stats?.completedBookings || 0}</div>\r\n            <p className=\"text-[9px] sm:text-xs text-muted-foreground mt-0.5 sm:mt-1 leading-tight\">\r\n              Total bookings\r\n            </p>\r\n          </CardContent>\r\n        </Card>\r\n\r\n        <Card className=\"overflow-hidden\">\r\n          <CardContent className=\"px-2 pb-2 sm:px-6 sm:pb-6 pt-3 sm:pt-6 flex flex-col\">\r\n            <DollarSign className=\"h-6 w-6 sm:h-5 sm:w-5 md:h-4 md:w-4 text-muted-foreground mb-2 sm:mb-1 flex-shrink-0\" />\r\n            <CardTitle className=\"text-xs sm:text-sm md:text-base font-medium leading-tight mb-2 sm:mb-1\">Earnings</CardTitle>\r\n            <div className=\"text-base sm:text-xl md:text-2xl font-bold\">R{stats?.monthlyEarnings?.toFixed(2) || '0.00'}</div>\r\n            <p className=\"text-[9px] sm:text-xs text-muted-foreground mt-0.5 sm:mt-1 leading-tight\">\r\n              {stats?.totalEarnings ? `R${stats.totalEarnings.toFixed(2)} total` : 'No earnings yet'}\r\n            </p>\r\n          </CardContent>\r\n        </Card>\r\n      </div>\r\n\r\n      {/* Today's Bookings */}\r\n      <div className=\"space-y-4\">\r\n        <div className=\"flex items-center justify-between\">\r\n          <h2 className=\"text-xl sm:text-2xl font-bold\">Today's Bookings</h2>\r\n          <Button variant=\"outline\" asChild>\r\n            <Link href=\"/cleaner/bookings\">\r\n              View All\r\n              <ArrowRight className=\"ml-2 h-4 w-4\" />\r\n            </Link>\r\n          </Button>\r\n        </div>\r\n\r\n        {loading ? (\r\n          <div className=\"flex items-center justify-center py-12\">\r\n            <Loader2 className=\"w-6 h-6 animate-spin text-primary\" />\r\n          </div>\r\n        ) : todayBookings.length === 0 ? (\r\n          <Card>\r\n            <CardContent className=\"flex flex-col items-center justify-center py-12\">\r\n              <Calendar className=\"h-12 w-12 text-muted-foreground mb-4\" />\r\n              <p className=\"text-muted-foreground text-center\">\r\n                No bookings scheduled for today\r\n              </p>\r\n            </CardContent>\r\n          </Card>\r\n        ) : (\r\n          <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-3\">\r\n            {todayBookings.map((booking) => {\r\n              const bookingDate = new Date(booking.service_date);\r\n              const displayDate = isToday(bookingDate) ? 'Today' : format(bookingDate, 'MMM d, yyyy');\r\n              \r\n              return (\r\n                <Card key={booking.id} className=\"hover:shadow-md transition-shadow\">\r\n                  <CardHeader>\r\n                    <div className=\"flex items-start justify-between\">\r\n                      <div className=\"flex-1 min-w-0\">\r\n                        <CardTitle className=\"text-lg\">{booking.service_type}</CardTitle>\r\n                        <CardDescription className=\"mt-1\">\r\n                          #{booking.booking_number}\r\n                        </CardDescription>\r\n                        <div className=\"mt-1 flex items-center text-xs text-muted-foreground\">\r\n                          <Calendar className=\"h-3 w-3 mr-1\" />\r\n                          {displayDate}\r\n                        </div>\r\n                      </div>\r\n                      <span className={`px-2 py-1 text-xs font-medium rounded-full flex-shrink-0 ${\r\n                        booking.status === 'confirmed' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/20 dark:text-blue-400' :\r\n                        booking.status === 'on_my_way' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/20 dark:text-yellow-400' :\r\n                        booking.status === 'started' ? 'bg-purple-100 text-purple-800 dark:bg-purple-900/20 dark:text-purple-400' :\r\n                        booking.status === 'completed' ? 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-400' :\r\n                        'bg-gray-100 text-gray-800 dark:bg-gray-900/20 dark:text-gray-400'\r\n                      }`}>\r\n                        {booking.status.replace('_', ' ')}\r\n                      </span>\r\n                    </div>\r\n                  </CardHeader>\r\n                  <CardContent className=\"space-y-3\">\r\n                    <div className=\"flex items-center text-sm text-muted-foreground\">\r\n                      <Clock className=\"h-4 w-4 mr-2 flex-shrink-0\" />\r\n                      {booking.service_time} ({booking.service_duration}h)\r\n                    </div>\r\n                    <div className=\"text-sm\">\r\n                      <p className=\"font-medium\">{booking.customer_first_name} {booking.customer_last_name}</p>\r\n                      <p className=\"text-muted-foreground\">{booking.service_address}, {booking.service_suburb}</p>\r\n                    </div>\r\n                    \r\n                    {/* Booking Action Buttons */}\r\n                    <div className=\"pt-2\">\r\n                      <BookingStatusButton\r\n                        booking={booking}\r\n                        onStatusUpdate={handleStatusUpdate(booking.id)}\r\n                      />\r\n                    </div>\r\n                    \r\n                    <div className=\"flex items-center justify-between pt-2 border-t\">\r\n                      <div>\r\n                        <span className=\"text-xs text-muted-foreground\">Your Earnings</span>\r\n                        <span className=\"text-lg font-semibold block\">R{bookingsEarnings[booking.id]?.totalEarnings.toFixed(2) || '0.00'}</span>\r\n                      </div>\r\n                      <Button variant=\"outline\" size=\"sm\" asChild>\r\n                        <Link href={`/cleaner/bookings/${booking.id}`}>\r\n                          View Details\r\n                          <ArrowRight className=\"ml-1 h-3 w-3\" />\r\n                        </Link>\r\n                      </Button>\r\n                    </div>\r\n                  </CardContent>\r\n                </Card>\r\n              );\r\n            })}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Upcoming Bookings (Next 7 days) */}\r\n      {upcomingBookings.length > todayBookings.length && (\r\n        <div className=\"space-y-4\">\r\n          <div className=\"flex items-center justify-between\">\r\n            <h2 className=\"text-xl sm:text-2xl font-bold\">Upcoming This Week</h2>\r\n            <Button variant=\"ghost\" size=\"sm\" asChild>\r\n              <Link href=\"/cleaner/bookings\">\r\n                View All\r\n                <ArrowRight className=\"ml-2 h-4 w-4\" />\r\n              </Link>\r\n            </Button>\r\n          </div>\r\n\r\n          <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-3\">\r\n            {upcomingBookings\r\n              .filter(b => b.service_date !== today) // Exclude today's bookings (already shown above)\r\n              .slice(0, 6)\r\n              .map((booking) => (\r\n                <Card key={booking.id} className=\"hover:shadow-md transition-shadow\">\r\n                  <CardHeader>\r\n                    <div className=\"flex items-start justify-between\">\r\n                      <div>\r\n                        <CardTitle className=\"text-lg\">{booking.service_type}</CardTitle>\r\n                        <CardDescription className=\"mt-1\">\r\n                          {format(new Date(booking.service_date), 'MMM d, yyyy')} at {booking.service_time}\r\n                        </CardDescription>\r\n                      </div>\r\n                      <span className={`px-2 py-1 text-xs font-medium rounded-full ${\r\n                        booking.status === 'confirmed' ? 'bg-blue-100 text-blue-800' :\r\n                        booking.status === 'on_my_way' ? 'bg-yellow-100 text-yellow-800' :\r\n                        booking.status === 'started' ? 'bg-purple-100 text-purple-800' :\r\n                        'bg-gray-100 text-gray-800'\r\n                      }`}>\r\n                        {booking.status.replace('_', ' ')}\r\n                      </span>\r\n                    </div>\r\n                  </CardHeader>\r\n                  <CardContent>\r\n                    <div className=\"text-sm\">\r\n                      <p className=\"font-medium\">{booking.customer_first_name} {booking.customer_last_name}</p>\r\n                      <p className=\"text-muted-foreground mt-1\">{booking.service_suburb}</p>\r\n                    </div>\r\n                    <Button variant=\"outline\" size=\"sm\" className=\"w-full mt-4\" asChild>\r\n                      <Link href={`/cleaner/bookings/${booking.id}`}>\r\n                        View Details\r\n                        <ArrowRight className=\"ml-1 h-3 w-3\" />\r\n                      </Link>\r\n                    </Button>\r\n                  </CardContent>\r\n                </Card>\r\n              ))}\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n"],"names":[],"mappings":"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"}}]
}