{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst buttonVariants = cva(\r\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-lg text-sm font-semibold ring-offset-background transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90 shadow-button hover:shadow-lg hover:-translate-y-0.5\",\r\n        destructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\r\n        outline: \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\r\n        secondary: \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\r\n        link: \"text-primary underline-offset-4 hover:underline\",\r\n        hero: \"bg-primary text-primary-foreground shadow-button hover:shadow-lg hover:-translate-y-0.5 hover:bg-primary/90\",\r\n        heroOutline: \"border-2 border-primary bg-transparent text-primary hover:bg-primary hover:text-primary-foreground\",\r\n        cta: \"bg-primary text-primary-foreground shadow-button hover:shadow-lg hover:-translate-y-1 hover:bg-primary/90\",\r\n      },\r\n      size: {\r\n        default: \"h-10 px-4 py-2\",\r\n        sm: \"h-9 rounded-md px-3\",\r\n        lg: \"h-12 rounded-lg px-6\",\r\n        xl: \"h-14 rounded-xl px-8 text-base\",\r\n        icon: \"h-10 w-10\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n      size: \"default\",\r\n    },\r\n  },\r\n);\r\n\r\nexport interface ButtonProps\r\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\r\n    VariantProps<typeof buttonVariants> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\r\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\r\n    const Comp = asChild ? Slot : \"button\";\r\n    return <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />;\r\n  },\r\n);\r\nButton.displayName = \"Button\";\r\n\r\nexport { Button, buttonVariants };\r\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,iBAAiB,IAAA,0KAAG,EACxB,wWACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aAAa;YACb,SAAS;YACT,WAAW;YACX,OAAO;YACP,MAAM;YACN,MAAM;YACN,aAAa;YACb,KAAK;QACP;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,MAAM;QACR;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AASF,MAAM,uBAAS,2KAAgB,MAC7B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,KAAK,EAAE,GAAG,OAAO,EAAE;IACxD,MAAM,OAAO,UAAU,2KAAI,GAAG;IAC9B,qBAAO,6LAAC;QAAK,WAAW,IAAA,4HAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QAAK,KAAK;QAAM,GAAG,KAAK;;;;;;AAC/F;;AAEF,OAAO,WAAW,GAAG"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/book/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { BookingFormData, BookingCreateInput, WorkingHour, TimeSlotAvailability, Cleaner, CleanerWithAvailability } from '@/types/booking';\r\nimport { calculatePrice } from '@/lib/pricing/calculator';\r\nimport { generateBookingNumber } from '@/lib/utils/booking-number';\r\nimport { initializePayment } from '@/lib/paystack/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { calculateReliabilityScore, calculateCompletionRate, calculateOnTimeRate } from '@/lib/utils/cleaner-utils';\r\nimport { calculateBookingDatesForMonth, calculateNextBookingDate, formatDateForDB } from '@/lib/utils/recurring-dates';\r\nimport { isValidFrequencyForService, requiresTeamBooking } from '@/lib/utils/service-validation';\r\n\r\n/**\r\n * Get available working hours (30-minute interval start times)\r\n */\r\nexport async function getWorkingHours(): Promise<WorkingHour[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('working_hours')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as WorkingHour[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get working hours from home_detail_options (backward compatibility)\r\n */\r\nexport async function getWorkingHoursFromOptions(): Promise<Array<{ value: string; label: string }>> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('value, label')\r\n      .eq('option_type', 'working_hours')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours from options:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []).map((item) => ({\r\n      value: item.value,\r\n      label: item.label,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours from options:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check cleaner availability for a specific date and time slot\r\n * Returns availability status and count of available cleaners\r\n */\r\nexport async function checkCleanerAvailabilityForSlot(\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<TimeSlotAvailability> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, check if any active cleaners exist in the system\r\n    const { data: activeCleaners, error: cleanersError } = await supabase\r\n      .from('cleaners')\r\n      .select('id')\r\n      .eq('is_active', true);\r\n\r\n    if (cleanersError) {\r\n      console.error('Error checking active cleaners:', cleanersError);\r\n      // If we can't check cleaners, assume unavailable for safety\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    // If no active cleaners exist, no slots are available\r\n    if (!activeCleaners || activeCleaners.length === 0) {\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    const totalCleaners = activeCleaners.length;\r\n\r\n    // Query bookings for the specified date that might overlap\r\n    // We need to check for bookings where:\r\n    // (booking_start_time < new_end_time) AND (booking_end_time > new_start_time)\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid, cancelled/completed)\r\n    // Cleaners should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration, preferred_cleaner_id, preferred_cleaner_ids, number_of_cleaners')\r\n      .eq('service_date', serviceDate)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking bookings:', bookingsError);\r\n      // If we can't check bookings, assume available (optimistic approach)\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      // No bookings for this date, all cleaners are available\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Track which cleaners are booked (by ID)\r\n    const bookedCleanerIds = new Set<string>();\r\n    \r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n      \r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number' \r\n          ? booking.service_duration \r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        // There's an overlap\r\n        // Check preferred_cleaner_ids first (new multi-cleaner support)\r\n        if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n          // Multiple cleaners are assigned\r\n          booking.preferred_cleaner_ids.forEach((cleanerId: string) => {\r\n            if (cleanerId) bookedCleanerIds.add(cleanerId);\r\n          });\r\n        } else if (booking.preferred_cleaner_id) {\r\n          // Single cleaner assigned (backward compatibility)\r\n          bookedCleanerIds.add(booking.preferred_cleaner_id);\r\n        } else {\r\n          // If no preferred cleaner, use number_of_cleaners to count generic cleaner slots\r\n          // This handles bookings without specific cleaner assignments\r\n          const numCleaners = booking.number_of_cleaners || 1;\r\n          // We don't add specific IDs here, but count them in bookingsWithoutPreferredCleaner\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate available cleaners\r\n    // Count bookings without preferred cleaners (generic assignments)\r\n    // These use number_of_cleaners to determine how many cleaner slots are taken\r\n    const bookingsWithoutPreferredCleaner = bookings.filter(\r\n      (b) => {\r\n        const hasPreferredCleaners = (b.preferred_cleaner_ids && Array.isArray(b.preferred_cleaner_ids) && b.preferred_cleaner_ids.length > 0) || b.preferred_cleaner_id;\r\n        if (hasPreferredCleaners) return false;\r\n        \r\n        // Check for time overlap\r\n        const [hours, mins] = b.service_time.split(':').slice(0, 2).map(Number);\r\n        const start = hours * 60 + mins;\r\n        const duration = Math.round((typeof b.service_duration === 'number' ? b.service_duration : parseFloat(b.service_duration || '0')) * 60);\r\n        const end = start + duration;\r\n        return newStartTimeMinutes < end && newEndTimeMinutes > start;\r\n      }\r\n    ).reduce((sum, b) => {\r\n      // Sum up the number_of_cleaners for bookings without preferred cleaners\r\n      return sum + (b.number_of_cleaners || 1);\r\n    }, 0);\r\n\r\n    const unavailableCleaners = bookedCleanerIds.size + bookingsWithoutPreferredCleaner;\r\n    const availableCleanersCount = Math.max(0, totalCleaners - unavailableCleaners);\r\n\r\n    return {\r\n      available: availableCleanersCount > 0,\r\n      availableCleanersCount,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking cleaner availability:', error);\r\n    // On error, assume unavailable for safety\r\n    return { available: false, availableCleanersCount: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Check team availability for a specific date for team-based services\r\n * Returns which teams (1, 2, or 3) are available and which are booked\r\n */\r\nexport async function checkTeamAvailabilityForDate(\r\n  serviceDate: string,\r\n  serviceType: string\r\n): Promise<{\r\n  availableTeams: number[];\r\n  bookedTeams: number[];\r\n  allTeamsBooked: boolean;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Only check for team-based services (Deep Cleaning and Move In/Out)\r\n    if (!requiresTeamBooking(serviceType)) {\r\n      return {\r\n        availableTeams: [],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Query bookings for the specified date and service type\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Teams should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('team_number')\r\n      .eq('service_date', serviceDate)\r\n      .eq('service_type', serviceType)\r\n      .not('team_number', 'is', null)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking team bookings:', bookingsError);\r\n      // If we can't check bookings, assume all teams available (optimistic approach)\r\n      return {\r\n        availableTeams: [1, 2, 3],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Extract booked team numbers\r\n    const bookedTeams = (bookings || [])\r\n      .map((booking) => booking.team_number)\r\n      .filter((teamNumber): teamNumber is number => teamNumber !== null && teamNumber >= 1 && teamNumber <= 3);\r\n\r\n    // Get unique booked teams (in case of duplicates)\r\n    const bookedTeamsSet = new Set(bookedTeams);\r\n\r\n    // Calculate available teams (1, 2, 3 minus booked teams)\r\n    const allTeams = [1, 2, 3];\r\n    const availableTeams = allTeams.filter((team) => !bookedTeamsSet.has(team));\r\n\r\n    return {\r\n      availableTeams,\r\n      bookedTeams: Array.from(bookedTeamsSet),\r\n      allTeamsBooked: availableTeams.length === 0,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking team availability:', error);\r\n    // On error, assume all teams available for safety (let database constraint catch duplicates)\r\n    return {\r\n      availableTeams: [1, 2, 3],\r\n      bookedTeams: [],\r\n      allTeamsBooked: false,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check availability for all time slots for a given date\r\n */\r\nexport async function checkAvailabilityForAllSlots(\r\n  serviceDate: string,\r\n  workingHours: WorkingHour[],\r\n  serviceDuration: number,\r\n  serviceType?: string\r\n): Promise<Record<string, TimeSlotAvailability>> {\r\n  const availability: Record<string, TimeSlotAvailability> = {};\r\n\r\n  // If service requires team booking, check team availability instead\r\n  if (serviceType && requiresTeamBooking(serviceType)) {\r\n    const teamAvailability = await checkTeamAvailabilityForDate(serviceDate, serviceType);\r\n    \r\n    // For team-based services, availability is day-based, not time-based\r\n    // If all teams are booked, all slots are unavailable\r\n    // Otherwise, slots are available (but we'll show team selection in UI)\r\n    const slotsAvailable = !teamAvailability.allTeamsBooked;\r\n    const availableTeamsCount = teamAvailability.availableTeams.length;\r\n    \r\n    // Set same availability for all time slots\r\n    workingHours.forEach((hour) => {\r\n      availability[hour.start_time] = {\r\n        available: slotsAvailable,\r\n        availableCleanersCount: availableTeamsCount,\r\n      };\r\n    });\r\n\r\n    return availability;\r\n  }\r\n\r\n  // For regular services, check individual cleaner availability per time slot\r\n  const promises = workingHours.map(async (hour) => {\r\n    const slotAvailability = await checkCleanerAvailabilityForSlot(\r\n      serviceDate,\r\n      hour.start_time,\r\n      serviceDuration\r\n    );\r\n    return { time: hour.start_time, availability: slotAvailability };\r\n  });\r\n\r\n  const results = await Promise.all(promises);\r\n  \r\n  results.forEach(({ time, availability: avail }) => {\r\n    availability[time] = avail;\r\n  });\r\n\r\n  return availability;\r\n}\r\n\r\n/**\r\n * Validate discount code\r\n */\r\nexport async function validateDiscountCode(code: string, subtotal: number): Promise<{\r\n  valid: boolean;\r\n  discountAmount: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (!code || !code.trim()) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('discount_codes')\r\n      .select('*')\r\n      .eq('code', code.trim().toUpperCase())\r\n      .eq('is_active', true)\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      return { valid: false, discountAmount: 0, error: 'Invalid discount code' };\r\n    }\r\n\r\n    // Check validity dates\r\n    const now = new Date();\r\n    const validFrom = new Date(data.valid_from);\r\n    const validUntil = new Date(data.valid_until);\r\n\r\n    if (now < validFrom || now > validUntil) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has expired' };\r\n    }\r\n\r\n    // Check max uses\r\n    if (data.max_uses && data.used_count >= data.max_uses) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has reached maximum uses' };\r\n    }\r\n\r\n    // Check min purchase amount\r\n    if (data.min_purchase_amount && subtotal < data.min_purchase_amount) {\r\n      return { \r\n        valid: false, \r\n        discountAmount: 0, \r\n        error: `Minimum purchase amount of R${data.min_purchase_amount} required` \r\n      };\r\n    }\r\n\r\n    // Calculate discount amount\r\n    let discountAmount = 0;\r\n    if (data.discount_type === 'percentage') {\r\n      discountAmount = (subtotal * data.discount_value) / 100;\r\n      if (data.max_discount_amount && discountAmount > data.max_discount_amount) {\r\n        discountAmount = data.max_discount_amount;\r\n      }\r\n    } else {\r\n      discountAmount = data.discount_value;\r\n    }\r\n\r\n    // Ensure discount doesn't exceed subtotal\r\n    discountAmount = Math.min(discountAmount, subtotal);\r\n\r\n    return { valid: true, discountAmount };\r\n  } catch (error) {\r\n    console.error('Error validating discount code:', error);\r\n    return { valid: false, discountAmount: 0, error: 'Error validating discount code' };\r\n  }\r\n}\r\n\r\n/**\r\n * Create booking draft (before payment)\r\n */\r\nexport async function createBookingDraft(formData: BookingFormData): Promise<{\r\n  success: boolean;\r\n  bookingId?: string;\r\n  bookingIds?: string[];\r\n  totalAmount?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current user if logged in\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n    const userId = user?.id || null;\r\n\r\n    // Get service name\r\n    const { data: service } = await supabase\r\n      .from('services')\r\n      .select('name')\r\n      .eq('id', formData.serviceId)\r\n      .single();\r\n\r\n    if (!service) {\r\n      return { success: false, error: 'Service not found' };\r\n    }\r\n\r\n    // Validate that the selected frequency is valid for this service\r\n    if (!isValidFrequencyForService(service.name, formData.cleaningFrequency)) {\r\n      return { \r\n        success: false, \r\n        error: `Recurring bookings are only available for Standard Cleaning and Airbnb Cleaning services. Selected service: ${service.name}` \r\n      };\r\n    }\r\n\r\n    // Check if service requires team booking\r\n    const isTeamBooking = requiresTeamBooking(service.name);\r\n\r\n    // Validate team booking requirements\r\n    if (isTeamBooking) {\r\n      if (!formData.teamNumber || (formData.teamNumber < 1 || formData.teamNumber > 3)) {\r\n        return {\r\n          success: false,\r\n          error: 'Please select a team (1, 2, or 3) for this service',\r\n        };\r\n      }\r\n\r\n      // Check team availability for each booking date\r\n      const startDate = new Date(formData.serviceDate);\r\n      const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n      \r\n      for (const bookingDate of bookingDates) {\r\n        const teamAvailability = await checkTeamAvailabilityForDate(\r\n          formatDateForDB(bookingDate),\r\n          service.name\r\n        );\r\n        \r\n        if (!teamAvailability.availableTeams.includes(formData.teamNumber!)) {\r\n          const dateStr = formatDateForDB(bookingDate);\r\n          return {\r\n            success: false,\r\n            error: `Team ${formData.teamNumber} is already booked for ${dateStr}. Please select a different team or date.`,\r\n          };\r\n        }\r\n      }\r\n    } else {\r\n      // For non-team bookings, ensure teamNumber is not set\r\n      if (formData.teamNumber !== null && formData.teamNumber !== undefined) {\r\n        return {\r\n          success: false,\r\n          error: 'Team selection is only available for Deep Cleaning and Move In/Out services',\r\n        };\r\n      }\r\n    }\r\n\r\n    // Calculate pricing\r\n    const priceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount: 0, // Will calculate discount in next step\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Apply discount code if provided\r\n    let discountAmount = 0;\r\n    if (formData.discountCode) {\r\n      const discountValidation = await validateDiscountCode(\r\n        formData.discountCode,\r\n        priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount\r\n      );\r\n      if (discountValidation.valid) {\r\n        discountAmount = discountValidation.discountAmount;\r\n      }\r\n    }\r\n\r\n    // Recalculate with discount\r\n    const finalPriceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount,\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Determine if this is a recurring booking\r\n    // Note: Team-based services (Deep Cleaning and Move In/Out) don't support recurring bookings\r\n    // but we'll handle it gracefully if somehow a recurring frequency is selected\r\n    const isRecurring = formData.cleaningFrequency !== 'one-time';\r\n\r\n    // Calculate booking dates based on frequency\r\n    const startDate = new Date(formData.serviceDate);\r\n    const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n\r\n    // Calculate next booking date for recurring bookings\r\n    let nextBookingDate: Date | null = null;\r\n    if (isRecurring && bookingDates.length > 0) {\r\n      const lastDate = bookingDates[bookingDates.length - 1];\r\n      nextBookingDate = calculateNextBookingDate(lastDate, formData.cleaningFrequency);\r\n    }\r\n\r\n    // Create bookings for all dates\r\n    const bookingsToCreate: BookingCreateInput[] = [];\r\n\r\n    for (let i = 0; i < bookingDates.length; i++) {\r\n      const bookingDate = bookingDates[i];\r\n      const bookingNumber = generateBookingNumber();\r\n\r\n      // Tip is only applied to the first booking in a recurring series (one-time payment)\r\n      const tipAmount = (i === 0) ? (formData.tipAmount || 0) : 0;\r\n      \r\n      const bookingInput: BookingCreateInput = {\r\n        booking_number: bookingNumber,\r\n        customer_first_name: formData.customerFirstName,\r\n        customer_last_name: formData.customerLastName,\r\n        customer_email: formData.customerEmail,\r\n        customer_phone: formData.customerPhone,\r\n        service_id: formData.serviceId,\r\n        service_type: service.name,\r\n        bedrooms: formData.bedrooms,\r\n        bathrooms: formData.bathrooms,\r\n        additional_services: formData.additionalServices,\r\n        cleaning_equipment: formData.cleaningEquipment,\r\n        preferred_cleaner_ids: isTeamBooking \r\n          ? null // Team bookings don't have preferred cleaners\r\n          : (formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n            ? formData.preferredCleanerIds \r\n            : null),\r\n        preferred_cleaner_id: isTeamBooking\r\n          ? null // Team bookings don't have preferred cleaners\r\n          : (formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n            ? formData.preferredCleanerIds[0] \r\n            : null), // Backward compatibility: set to first cleaner\r\n        team_number: isTeamBooking && formData.teamNumber ? formData.teamNumber : null,\r\n        cleaning_frequency: formData.cleaningFrequency,\r\n        service_date: formatDateForDB(bookingDate),\r\n        service_time: formData.serviceTime,\r\n        service_duration: formData.serviceDuration,\r\n        service_address: formData.serviceAddress,\r\n        service_apt_unit: formData.serviceAptUnit || null,\r\n        service_suburb: formData.serviceSuburb,\r\n        service_city: formData.serviceCity,\r\n        special_instructions: formData.specialInstructions || null,\r\n        tip_amount: tipAmount,\r\n        base_price: finalPriceBreakdown.basePrice,\r\n        additional_services_price: finalPriceBreakdown.additionalServicesPrice,\r\n        equipment_supply_price: finalPriceBreakdown.equipmentSupplyPrice,\r\n        number_of_cleaners: formData.numberOfCleaners || 1,\r\n        additional_cleaners_price: finalPriceBreakdown.additionalCleanersPrice,\r\n        frequency_discount_percent: finalPriceBreakdown.frequencyDiscountPercent,\r\n        frequency_discount_amount: finalPriceBreakdown.frequencyDiscountAmount,\r\n        subtotal: finalPriceBreakdown.subtotal,\r\n        service_fee: finalPriceBreakdown.serviceFee,\r\n        total_amount: finalPriceBreakdown.totalAmount + tipAmount,\r\n        discount_code: formData.discountCode || null,\r\n        discount_amount: discountAmount,\r\n        referral_code: formData.referralCode || null,\r\n        amount_paid: 0,\r\n        payment_status: 'pending',\r\n        status: 'pending',\r\n        user_id: userId,\r\n        parent_booking_id: null, // Will be updated after first booking is created\r\n        is_recurring: isRecurring,\r\n        recurrence_status: isRecurring ? 'active' : undefined,\r\n        next_booking_date: i === 0 && isRecurring && nextBookingDate ? formatDateForDB(nextBookingDate) : null,\r\n        credits_used: 0, // Will be updated when credits are used during payment\r\n      };\r\n\r\n      bookingsToCreate.push(bookingInput);\r\n    }\r\n\r\n    // Insert all bookings\r\n    const { data: insertedBookings, error } = await supabase\r\n      .from('bookings')\r\n      .insert(bookingsToCreate)\r\n      .select('id, total_amount');\r\n\r\n    if (error) {\r\n      console.error('Error creating booking drafts:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!insertedBookings || insertedBookings.length === 0) {\r\n      return { success: false, error: 'Failed to create bookings' };\r\n    }\r\n\r\n    // Update parent_booking_id for subsequent bookings if there are multiple\r\n    if (insertedBookings.length > 1 && isRecurring) {\r\n      const firstBookingId = insertedBookings[0].id;\r\n      const subsequentBookingIds = insertedBookings.slice(1).map(b => b.id);\r\n      \r\n      // Update all subsequent bookings to reference the first one\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({ parent_booking_id: firstBookingId })\r\n        .in('id', subsequentBookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating parent_booking_id:', updateError);\r\n        // Don't fail, but log the error\r\n      }\r\n    }\r\n\r\n    // Calculate total amount\r\n    const totalAmount = insertedBookings.reduce((sum, booking) => sum + Number(booking.total_amount), 0);\r\n    const bookingIds = insertedBookings.map(booking => booking.id);\r\n\r\n    // For backward compatibility, also return single bookingId\r\n    const bookingId = bookingIds[0];\r\n\r\n    // If multiple bookings, return array; otherwise return single ID for backward compatibility\r\n    if (bookingIds.length > 1) {\r\n      return { \r\n        success: true, \r\n        bookingIds,\r\n        totalAmount,\r\n        bookingId // Keep for backward compatibility\r\n      };\r\n    }\r\n\r\n    return { \r\n      success: true, \r\n      bookingId,\r\n      bookingIds,\r\n      totalAmount\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error creating booking draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize payment for booking(s)\r\n * Accepts either a single bookingId or an array of bookingIds\r\n */\r\nexport async function initializePaymentForBooking(\r\n  bookingIdOrIds: string | string[]\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const bookingIds = Array.isArray(bookingIdOrIds) ? bookingIdOrIds : [bookingIdOrIds];\r\n\r\n    // Get all booking details\r\n    const { data: bookings, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (fetchError || !bookings || bookings.length === 0) {\r\n      return { success: false, error: 'Booking(s) not found' };\r\n    }\r\n\r\n    // Check if all bookings are in pending status\r\n    const nonPendingBookings = bookings.filter(b => b.payment_status !== 'pending');\r\n    if (nonPendingBookings.length > 0) {\r\n      return { success: false, error: 'Some bookings are not in pending payment status' };\r\n    }\r\n\r\n    // Calculate total amount from all bookings (including tip)\r\n    // Note: total_amount in database now includes tip for new bookings\r\n    // For backward compatibility with existing bookings that might not have tip in total_amount, \r\n    // we check and add tip_amount if it's missing\r\n    const totalAmount = bookings.reduce((sum, booking) => {\r\n      const bookingTotal = Number(booking.total_amount) || 0;\r\n      const tipAmount = Number(booking.tip_amount) || 0;\r\n      const baseTotal = Number(booking.subtotal || 0) + Number(booking.service_fee || 0);\r\n      \r\n      // Check if tip is already included in total_amount\r\n      // If total_amount equals baseTotal exactly, then tip is not included, so add it\r\n      // Otherwise, total_amount already includes tip\r\n      if (tipAmount > 0 && Math.abs(bookingTotal - baseTotal) < 0.01) {\r\n        // Tip is not included in total_amount (backward compatibility case)\r\n        return sum + bookingTotal + tipAmount;\r\n      }\r\n      // Tip is already included in total_amount (new bookings)\r\n      return sum + bookingTotal;\r\n    }, 0);\r\n\r\n    // Calculate total credits used across all bookings\r\n    const totalCreditsUsed = bookings.reduce((sum, booking) => {\r\n      return sum + (Number(booking.credits_used) || 0);\r\n    }, 0);\r\n\r\n    // Calculate remaining amount after credits\r\n    const remainingAmount = totalAmount - totalCreditsUsed;\r\n\r\n    // Use the first booking's email and details for payment\r\n    const firstBooking = bookings[0];\r\n\r\n    // If credits fully cover the booking, mark as paid and skip Paystack\r\n    if (remainingAmount <= 0) {\r\n      // Update all bookings to mark as paid\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({\r\n          payment_status: 'paid',\r\n          amount_paid: totalAmount, // Fully paid with credits\r\n          status: 'confirmed', // Auto-confirm when fully paid\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .in('id', bookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating bookings payment status:', updateError);\r\n        return { success: false, error: 'Failed to update booking payment status' };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        // No authorizationUrl - payment fully covered by credits\r\n      };\r\n    }\r\n\r\n    // Partial credit coverage or no credits - proceed with Paystack for remaining amount\r\n    // Always generate a new unique reference for Paystack (references must be unique and can only be used once)\r\n    const reference = `${firstBooking.booking_number}${Date.now()}${Math.random().toString(36).substring(2, 9)}`;\r\n    \r\n    // Initialize Paystack payment with remaining amount (after credits)\r\n    const paymentResponse = await initializePayment(\r\n      firstBooking.customer_email,\r\n      remainingAmount, // Only charge the remaining amount\r\n      reference,\r\n      {\r\n        booking_ids: bookingIds,\r\n        booking_id: firstBooking.id, // Keep for backward compatibility\r\n        booking_number: firstBooking.booking_number,\r\n        customer_email: firstBooking.customer_email,\r\n        credits_used: totalCreditsUsed, // Include in metadata for tracking\r\n      }\r\n    );\r\n\r\n    if (!paymentResponse.status) {\r\n      return { success: false, error: paymentResponse.message || 'Failed to initialize payment' };\r\n    }\r\n\r\n    // Use the reference that Paystack actually returned (may differ from what we sent)\r\n    const paystackReference = paymentResponse.data.reference;\r\n\r\n    // Update all bookings with the Paystack reference and partial payment from credits\r\n    const { error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        paystack_reference: paystackReference,\r\n        amount_paid: totalCreditsUsed, // Partial payment from credits, Paystack will complete it\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .in('id', bookingIds);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating bookings with Paystack reference:', updateError);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentResponse.data.authorization_url,\r\n      reference: paystackReference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing payment:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get booking by ID\r\n */\r\nexport async function getBooking(bookingId: string): Promise<{\r\n  success: boolean;\r\n  booking?: any;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners for selection\r\n * Optionally filter by service area/suburb\r\n */\r\nexport async function getAvailableCleaners(serviceSuburb?: string): Promise<{\r\n  success: boolean;\r\n  cleaners?: any[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Build query - only filter by is_available if the column exists\r\n    // First, try to get all active cleaners\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = data || [];\r\n\r\n    // Filter by is_available if the column exists (client-side filter as fallback)\r\n    cleaners = cleaners.filter((cleaner) => {\r\n      // If is_available column doesn't exist or is null/undefined, include the cleaner\r\n      // Otherwise, only include if is_available is true\r\n      return cleaner.is_available !== false;\r\n    });\r\n\r\n    // Filter by area if suburb is provided\r\n    // Since PostgreSQL array contains is complex in Supabase, we filter client-side\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        // If cleaner has no areas specified, include them (they serve all areas)\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true;\r\n        }\r\n        // Check if any area matches the suburb (case-insensitive partial match)\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    return { success: true, cleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a cleaner is available for a specific day of the week\r\n * dayOfWeek: 0 = Sunday, 1 = Monday, ..., 6 = Saturday\r\n */\r\nexport async function isCleanerAvailableForDay(cleaner: any, dayOfWeek: number): Promise<boolean> {\r\n  const dayMap: Record<number, keyof typeof cleaner> = {\r\n    0: 'available_sunday',\r\n    1: 'available_monday',\r\n    2: 'available_tuesday',\r\n    3: 'available_wednesday',\r\n    4: 'available_thursday',\r\n    5: 'available_friday',\r\n    6: 'available_saturday',\r\n  };\r\n\r\n  const dayField = dayMap[dayOfWeek];\r\n  return cleaner[dayField] !== false && cleaner.is_available !== false;\r\n}\r\n\r\n/**\r\n * Check if a cleaner has a booking conflict for a specific date and time slot\r\n */\r\nexport async function checkCleanerBookingConflict(\r\n  cleanerId: string,\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Query bookings for this cleaner on the specified date\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Cleaners should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration')\r\n      .eq('preferred_cleaner_id', cleanerId)\r\n      .eq('service_date', serviceDate)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (error) {\r\n      console.error('Error checking booking conflicts:', error);\r\n      return false; // Assume no conflict on error\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      return false; // No bookings, no conflict\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n\r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number'\r\n          ? booking.service_duration\r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        return true; // Conflict found\r\n      }\r\n    }\r\n\r\n    return false; // No conflicts\r\n  } catch (error) {\r\n    console.error('Unexpected error checking booking conflict:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate reliability score for a cleaner (server-side wrapper)\r\n * This calls the database function if available, otherwise calculates client-side\r\n */\r\nexport async function calculateCleanerReliabilityScore(cleanerId: string): Promise<number> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Try to call the database function\r\n    const { data, error } = await supabase.rpc('calculate_cleaner_reliability_score', {\r\n      cleaner_id: cleanerId,\r\n    });\r\n\r\n    if (!error && data !== null) {\r\n      return parseFloat(data.toString());\r\n    }\r\n\r\n    // Fallback: fetch cleaner and calculate client-side\r\n    const { data: cleaner, error: fetchError } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('id', cleanerId)\r\n      .single();\r\n\r\n    if (fetchError || !cleaner) {\r\n      return 50.0; // Default score\r\n    }\r\n\r\n    return calculateReliabilityScore(cleaner as Cleaner);\r\n  } catch (error) {\r\n    console.error('Error calculating reliability score:', error);\r\n    return 50.0; // Default score on error\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners with enhanced filtering criteria\r\n * Filters by: Location, Availability, Booking conflicts\r\n * Sorts by: Reliability Score, Rating\r\n */\r\nexport async function getAvailableCleanersWithCriteria(params: {\r\n  serviceSuburb?: string;\r\n  serviceDate?: string;\r\n  serviceTime?: string;\r\n  serviceDuration?: number;\r\n  minRating?: number;\r\n  minReliabilityScore?: number;\r\n}): Promise<{\r\n  success: boolean;\r\n  cleaners?: CleanerWithAvailability[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const {\r\n      serviceSuburb,\r\n      serviceDate,\r\n      serviceTime,\r\n      serviceDuration = 3,\r\n      minRating = 0,\r\n      minReliabilityScore = 0,\r\n    } = params;\r\n\r\n    // Build base query\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query.order('reliability_score', { ascending: false, nullsFirst: false })\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = (data || []) as Cleaner[];\r\n\r\n    // Filter by is_available\r\n    cleaners = cleaners.filter((cleaner) => cleaner.is_available !== false);\r\n\r\n    // Filter by location (suburb)\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true; // Serve all areas\r\n        }\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Filter by day of week availability if date is provided\r\n    if (serviceDate) {\r\n      const date = new Date(serviceDate);\r\n      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        const dayMap: Record<number, keyof Cleaner> = {\r\n          0: 'available_sunday',\r\n          1: 'available_monday',\r\n          2: 'available_tuesday',\r\n          3: 'available_wednesday',\r\n          4: 'available_thursday',\r\n          5: 'available_friday',\r\n          6: 'available_saturday',\r\n        };\r\n        const dayField = dayMap[dayOfWeek];\r\n        return cleaner[dayField] !== false;\r\n      });\r\n    }\r\n\r\n    // Filter by minimum rating\r\n    if (minRating > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.rating || 0) >= minRating);\r\n    }\r\n\r\n    // Filter by minimum reliability score\r\n    if (minReliabilityScore > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.reliability_score || 0) >= minReliabilityScore);\r\n    }\r\n\r\n    // Enrich cleaners with availability and booking conflict information\r\n    const enrichedCleaners: CleanerWithAvailability[] = await Promise.all(\r\n      cleaners.map(async (cleaner) => {\r\n        let isAvailableForSlot = true;\r\n        let bookingConflict = false;\r\n\r\n        // Check booking conflict if date and time are provided\r\n        if (serviceDate && serviceTime && serviceDuration) {\r\n          bookingConflict = await checkCleanerBookingConflict(\r\n            cleaner.id,\r\n            serviceDate,\r\n            serviceTime,\r\n            serviceDuration\r\n          );\r\n          isAvailableForSlot = !bookingConflict;\r\n        }\r\n\r\n        // Calculate reliability score if not present\r\n        const reliabilityScore = cleaner.reliability_score ?? calculateReliabilityScore(cleaner);\r\n\r\n        return {\r\n          ...cleaner,\r\n          reliability_score: reliabilityScore,\r\n          isAvailableForSlot,\r\n          bookingConflict,\r\n          completionRate: calculateCompletionRate(cleaner),\r\n          onTimeRate: calculateOnTimeRate(cleaner),\r\n        };\r\n      })\r\n    );\r\n\r\n    // Sort by reliability score and rating (already sorted by query, but ensure consistency)\r\n    enrichedCleaners.sort((a, b) => {\r\n      const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n      const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n\r\n    return { success: true, cleaners: enrichedCleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners with criteria:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAqyBsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8CAAA"}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/confirmation/%5BbookingId%5D/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useEffect, useState, Suspense } from 'react';\r\nimport { useParams, useRouter, useSearchParams } from 'next/navigation';\r\nimport { Loader2, CheckCircle2, Calendar, Clock, MapPin, ArrowRight, LayoutDashboard } from 'lucide-react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { getBooking } from '../../book/actions';\r\nimport { format } from 'date-fns';\r\nimport { createClient } from '@/lib/supabase/client';\r\n\r\nfunction BookingConfirmationContent() {\r\n  const params = useParams();\r\n  const router = useRouter();\r\n  const searchParams = useSearchParams();\r\n  const bookingId = params.bookingId as string;\r\n  const paymentSuccess = searchParams.get('payment') === 'success';\r\n\r\n  const [booking, setBooking] = useState<any>(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [isAuthenticated, setIsAuthenticated] = useState<boolean | null>(null);\r\n  const [totalAmountPaid, setTotalAmountPaid] = useState<number | null>(null);\r\n\r\n  // Function to calculate total amount from all bookings with same paystack_reference\r\n  const calculateTotalAmountPaid = async (booking: any): Promise<number> => {\r\n    if (!booking.paystack_reference) {\r\n      // No shared payment, return single booking total\r\n      return booking.total_amount || 0;\r\n    }\r\n    \r\n    // Find all bookings with the same payment reference\r\n    const supabase = createClient();\r\n    const { data: relatedBookings } = await supabase\r\n      .from('bookings')\r\n      .select('total_amount')\r\n      .eq('paystack_reference', booking.paystack_reference)\r\n      .in('payment_status', ['paid', 'pending']);\r\n    \r\n    if (!relatedBookings || relatedBookings.length <= 1) {\r\n      return booking.total_amount || 0;\r\n    }\r\n    \r\n    // Sum all related bookings' total amounts\r\n    return relatedBookings.reduce((sum, b) => sum + (Number(b.total_amount) || 0), 0);\r\n  };\r\n\r\n  useEffect(() => {\r\n    // Check authentication status\r\n    const checkAuth = async () => {\r\n      const supabase = createClient();\r\n      const { data: { user } } = await supabase.auth.getUser();\r\n      setIsAuthenticated(!!user);\r\n    };\r\n    checkAuth();\r\n\r\n    // Load booking data and calculate total amount paid\r\n    if (bookingId) {\r\n      getBooking(bookingId).then(async (result) => {\r\n        if (result.success && result.booking) {\r\n          setBooking(result.booking);\r\n          \r\n          // Calculate total amount paid (includes all bookings with same payment reference)\r\n          const totalAmount = await calculateTotalAmountPaid(result.booking);\r\n          setTotalAmountPaid(totalAmount);\r\n        } else {\r\n          setError(result.error || 'Booking not found');\r\n        }\r\n        setLoading(false);\r\n      });\r\n    }\r\n  }, [bookingId]);\r\n\r\n  const handleViewDashboard = () => {\r\n    if (isAuthenticated) {\r\n      router.push('/dashboard');\r\n    } else {\r\n      router.push('/login?redirect=/dashboard');\r\n    }\r\n  };\r\n\r\n  if (loading) {\r\n    return (\r\n      <div className=\"min-h-screen flex items-center justify-center bg-muted/30\">\r\n        <Loader2 className=\"w-8 h-8 animate-spin text-primary\" />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (error || !booking) {\r\n    return (\r\n      <div className=\"min-h-screen flex items-center justify-center bg-muted/30\">\r\n        <div className=\"text-center\">\r\n          <h1 className=\"text-2xl font-bold mb-4\">Booking Not Found</h1>\r\n          <p className=\"text-muted-foreground mb-4\">{error || 'The booking you are looking for does not exist.'}</p>\r\n          <Button onClick={() => router.push('/booking/details')}>Book Now</Button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-muted/30\">\r\n      <main className=\"pb-16\">\r\n        <div className=\"container mx-auto px-4 md:px-6 pt-8 pb-16 max-w-2xl\">\r\n          <div className=\"bg-white rounded-2xl p-8 md:p-12 text-center space-y-6\">\r\n            {/* Success Icon */}\r\n            <div className=\"flex justify-center\">\r\n              <div className=\"w-20 h-20 rounded-full bg-green-100 flex items-center justify-center\">\r\n                <CheckCircle2 className=\"w-12 h-12 text-green-600\" />\r\n              </div>\r\n            </div>\r\n\r\n            {/* Success Message */}\r\n            <div className=\"space-y-3\">\r\n              <h1 className=\"text-3xl md:text-4xl font-bold text-foreground\">\r\n                {paymentSuccess ? 'Payment Successful!' : 'Booking Confirmed!'}\r\n              </h1>\r\n              <p className=\"text-lg text-muted-foreground\">\r\n                {paymentSuccess\r\n                  ? 'Your payment has been processed successfully and your booking is confirmed.'\r\n                  : 'Your booking has been successfully created. A confirmation email has been sent to your email address.'}\r\n              </p>\r\n            </div>\r\n\r\n            {/* Booking Reference */}\r\n            <div className=\"bg-muted/50 rounded-xl p-6 border border-border\">\r\n              <p className=\"text-sm text-muted-foreground mb-2\">Booking Reference</p>\r\n              <p className=\"text-3xl font-bold text-foreground\">{booking.booking_number}</p>\r\n            </div>\r\n\r\n            {/* Essential Booking Details */}\r\n            <div className=\"bg-muted/50 rounded-xl p-6 border border-border space-y-4 text-left\">\r\n              <div className=\"flex items-start gap-3\">\r\n                <Calendar className=\"w-5 h-5 text-primary mt-0.5 flex-shrink-0\" />\r\n                <div>\r\n                  <h3 className=\"font-semibold text-foreground mb-1\">Service Date & Time</h3>\r\n                  <p className=\"text-sm text-muted-foreground\">\r\n                    {format(new Date(booking.service_date), 'EEEE, MMMM d, yyyy')}\r\n                  </p>\r\n                  <div className=\"flex items-center gap-2 mt-1\">\r\n                    <Clock className=\"w-4 h-4 text-muted-foreground\" />\r\n                    <span className=\"text-sm text-muted-foreground\">{booking.service_time}</span>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"flex items-start gap-3\">\r\n                <MapPin className=\"w-5 h-5 text-primary mt-0.5 flex-shrink-0\" />\r\n                <div>\r\n                  <h3 className=\"font-semibold text-foreground mb-1\">Service Address</h3>\r\n                  <p className=\"text-sm text-muted-foreground\">\r\n                    {booking.service_address}\r\n                    {booking.service_apt_unit && `, ${booking.service_apt_unit}`}\r\n                    <br />\r\n                    {booking.service_suburb}, {booking.service_city}\r\n                  </p>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"pt-4 border-t border-border\">\r\n                <div className=\"flex justify-between items-center\">\r\n                  <span className=\"font-semibold text-foreground\">Service</span>\r\n                  <span className=\"text-sm text-muted-foreground\">{booking.service_type}</span>\r\n                </div>\r\n                <div className=\"flex justify-between items-center mt-2\">\r\n                  <span className=\"font-semibold text-foreground\">Total Paid</span>\r\n                  <span className=\"text-lg font-bold text-primary\">\r\n                    R{(totalAmountPaid ?? booking.total_amount).toFixed(2)}\r\n                  </span>\r\n                </div>\r\n              </div>\r\n            </div>\r\n\r\n            {/* Action Buttons */}\r\n            <div className=\"pt-4 flex flex-col sm:flex-row gap-4 justify-center items-center\">\r\n              <Button onClick={() => router.push('/')} variant=\"hero\" size=\"lg\" className=\"w-full sm:w-auto\">\r\n                Return to Home\r\n                <ArrowRight className=\"ml-2 w-4 h-4\" />\r\n              </Button>\r\n              <Button \r\n                onClick={handleViewDashboard} \r\n                variant=\"outline\" \r\n                size=\"lg\" \r\n                className=\"w-full sm:w-auto\"\r\n              >\r\n                <LayoutDashboard className=\"mr-2 w-4 h-4\" />\r\n                View Dashboard\r\n              </Button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </main>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default function BookingConfirmationPage() {\r\n  return (\r\n    <Suspense fallback={\r\n      <div className=\"min-h-screen bg-muted/30 flex items-center justify-center p-4\">\r\n        <div className=\"bg-white rounded-lg p-8 shadow-lg text-center\">\r\n          <div className=\"w-16 h-16 border-4 border-primary border-t-transparent rounded-full animate-spin mx-auto mb-4\"></div>\r\n          <p className=\"text-muted-foreground\">Loading...</p>\r\n        </div>\r\n      </div>\r\n    }>\r\n      <BookingConfirmationContent />\r\n    </Suspense>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":"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"}}]
}