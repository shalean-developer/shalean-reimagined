{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/src/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst buttonVariants = cva(\r\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-lg text-sm font-semibold ring-offset-background transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90 shadow-button hover:shadow-lg hover:-translate-y-0.5\",\r\n        destructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\r\n        outline: \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\r\n        secondary: \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\r\n        link: \"text-primary underline-offset-4 hover:underline\",\r\n        hero: \"bg-primary text-primary-foreground shadow-button hover:shadow-lg hover:-translate-y-0.5 hover:bg-primary/90\",\r\n        heroOutline: \"border-2 border-primary bg-transparent text-primary hover:bg-primary hover:text-primary-foreground\",\r\n        cta: \"bg-primary text-primary-foreground shadow-button hover:shadow-lg hover:-translate-y-1 hover:bg-primary/90\",\r\n      },\r\n      size: {\r\n        default: \"h-10 px-4 py-2\",\r\n        sm: \"h-9 rounded-md px-3\",\r\n        lg: \"h-12 rounded-lg px-6\",\r\n        xl: \"h-14 rounded-xl px-8 text-base\",\r\n        icon: \"h-10 w-10\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n      size: \"default\",\r\n    },\r\n  },\r\n);\r\n\r\nexport interface ButtonProps\r\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\r\n    VariantProps<typeof buttonVariants> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\r\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\r\n    const Comp = asChild ? Slot : \"button\";\r\n    return <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />;\r\n  },\r\n);\r\nButton.displayName = \"Button\";\r\n\r\nexport { Button, buttonVariants };\r\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,iBAAiB,IAAA,0KAAG,EACxB,wWACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aAAa;YACb,SAAS;YACT,WAAW;YACX,OAAO;YACP,MAAM;YACN,MAAM;YACN,aAAa;YACb,KAAK;QACP;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,MAAM;QACR;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AASF,MAAM,uBAAS,2KAAgB,MAC7B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,KAAK,EAAE,GAAG,OAAO,EAAE;IACxD,MAAM,OAAO,UAAU,2KAAI,GAAG;IAC9B,qBAAO,6LAAC;QAAK,WAAW,IAAA,4HAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QAAK,KAAK;QAAM,GAAG,KAAK;;;;;;AAC/F;;AAEF,OAAO,WAAW,GAAG"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/book/actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { BookingFormData, BookingCreateInput, WorkingHour, TimeSlotAvailability, Cleaner, CleanerWithAvailability } from '@/types/booking';\r\nimport { calculatePrice } from '@/lib/pricing/calculator';\r\nimport { generateBookingNumber } from '@/lib/utils/booking-number';\r\nimport { initializePayment } from '@/lib/paystack/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { calculateReliabilityScore, calculateCompletionRate, calculateOnTimeRate } from '@/lib/utils/cleaner-utils';\r\nimport { calculateBookingDatesForMonth, calculateNextBookingDate, formatDateForDB } from '@/lib/utils/recurring-dates';\r\nimport { isValidFrequencyForService } from '@/lib/utils/service-validation';\r\n\r\n/**\r\n * Get available working hours (30-minute interval start times)\r\n */\r\nexport async function getWorkingHours(): Promise<WorkingHour[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('working_hours')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as WorkingHour[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get working hours from home_detail_options (backward compatibility)\r\n */\r\nexport async function getWorkingHoursFromOptions(): Promise<Array<{ value: string; label: string }>> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('value, label')\r\n      .eq('option_type', 'working_hours')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours from options:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []).map((item) => ({\r\n      value: item.value,\r\n      label: item.label,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours from options:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check cleaner availability for a specific date and time slot\r\n * Returns availability status and count of available cleaners\r\n */\r\nexport async function checkCleanerAvailabilityForSlot(\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<TimeSlotAvailability> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, check if any active cleaners exist in the system\r\n    const { data: activeCleaners, error: cleanersError } = await supabase\r\n      .from('cleaners')\r\n      .select('id')\r\n      .eq('is_active', true);\r\n\r\n    if (cleanersError) {\r\n      console.error('Error checking active cleaners:', cleanersError);\r\n      // If we can't check cleaners, assume unavailable for safety\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    // If no active cleaners exist, no slots are available\r\n    if (!activeCleaners || activeCleaners.length === 0) {\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    const totalCleaners = activeCleaners.length;\r\n\r\n    // Query bookings for the specified date that might overlap\r\n    // We need to check for bookings where:\r\n    // (booking_start_time < new_end_time) AND (booking_end_time > new_start_time)\r\n    // Only consider pending or confirmed bookings (exclude cancelled/completed)\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration, preferred_cleaner_id, preferred_cleaner_ids, number_of_cleaners')\r\n      .eq('service_date', serviceDate)\r\n      .in('status', ['pending', 'confirmed']);\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking bookings:', bookingsError);\r\n      // If we can't check bookings, assume available (optimistic approach)\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      // No bookings for this date, all cleaners are available\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Track which cleaners are booked (by ID)\r\n    const bookedCleanerIds = new Set<string>();\r\n    \r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n      \r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number' \r\n          ? booking.service_duration \r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        // There's an overlap\r\n        // Check preferred_cleaner_ids first (new multi-cleaner support)\r\n        if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n          // Multiple cleaners are assigned\r\n          booking.preferred_cleaner_ids.forEach((cleanerId: string) => {\r\n            if (cleanerId) bookedCleanerIds.add(cleanerId);\r\n          });\r\n        } else if (booking.preferred_cleaner_id) {\r\n          // Single cleaner assigned (backward compatibility)\r\n          bookedCleanerIds.add(booking.preferred_cleaner_id);\r\n        } else {\r\n          // If no preferred cleaner, use number_of_cleaners to count generic cleaner slots\r\n          // This handles bookings without specific cleaner assignments\r\n          const numCleaners = booking.number_of_cleaners || 1;\r\n          // We don't add specific IDs here, but count them in bookingsWithoutPreferredCleaner\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate available cleaners\r\n    // Count bookings without preferred cleaners (generic assignments)\r\n    // These use number_of_cleaners to determine how many cleaner slots are taken\r\n    const bookingsWithoutPreferredCleaner = bookings.filter(\r\n      (b) => {\r\n        const hasPreferredCleaners = (b.preferred_cleaner_ids && Array.isArray(b.preferred_cleaner_ids) && b.preferred_cleaner_ids.length > 0) || b.preferred_cleaner_id;\r\n        if (hasPreferredCleaners) return false;\r\n        \r\n        // Check for time overlap\r\n        const [hours, mins] = b.service_time.split(':').slice(0, 2).map(Number);\r\n        const start = hours * 60 + mins;\r\n        const duration = Math.round((typeof b.service_duration === 'number' ? b.service_duration : parseFloat(b.service_duration || '0')) * 60);\r\n        const end = start + duration;\r\n        return newStartTimeMinutes < end && newEndTimeMinutes > start;\r\n      }\r\n    ).reduce((sum, b) => {\r\n      // Sum up the number_of_cleaners for bookings without preferred cleaners\r\n      return sum + (b.number_of_cleaners || 1);\r\n    }, 0);\r\n\r\n    const unavailableCleaners = bookedCleanerIds.size + bookingsWithoutPreferredCleaner;\r\n    const availableCleanersCount = Math.max(0, totalCleaners - unavailableCleaners);\r\n\r\n    return {\r\n      available: availableCleanersCount > 0,\r\n      availableCleanersCount,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking cleaner availability:', error);\r\n    // On error, assume unavailable for safety\r\n    return { available: false, availableCleanersCount: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Check availability for all time slots for a given date\r\n */\r\nexport async function checkAvailabilityForAllSlots(\r\n  serviceDate: string,\r\n  workingHours: WorkingHour[],\r\n  serviceDuration: number\r\n): Promise<Record<string, TimeSlotAvailability>> {\r\n  const availability: Record<string, TimeSlotAvailability> = {};\r\n\r\n  // Check availability for each time slot in parallel\r\n  // Use the service duration provided (either from form data or calculated)\r\n  const promises = workingHours.map(async (hour) => {\r\n    // Use the provided service duration, not the working hour's duration\r\n    // The working hour duration is just the slot length, but the actual booking\r\n    // will use the service duration from the form\r\n    const slotAvailability = await checkCleanerAvailabilityForSlot(\r\n      serviceDate,\r\n      hour.start_time,\r\n      serviceDuration\r\n    );\r\n    return { time: hour.start_time, availability: slotAvailability };\r\n  });\r\n\r\n  const results = await Promise.all(promises);\r\n  \r\n  results.forEach(({ time, availability: avail }) => {\r\n    availability[time] = avail;\r\n  });\r\n\r\n  return availability;\r\n}\r\n\r\n/**\r\n * Validate discount code\r\n */\r\nexport async function validateDiscountCode(code: string, subtotal: number): Promise<{\r\n  valid: boolean;\r\n  discountAmount: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (!code || !code.trim()) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('discount_codes')\r\n      .select('*')\r\n      .eq('code', code.trim().toUpperCase())\r\n      .eq('is_active', true)\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      return { valid: false, discountAmount: 0, error: 'Invalid discount code' };\r\n    }\r\n\r\n    // Check validity dates\r\n    const now = new Date();\r\n    const validFrom = new Date(data.valid_from);\r\n    const validUntil = new Date(data.valid_until);\r\n\r\n    if (now < validFrom || now > validUntil) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has expired' };\r\n    }\r\n\r\n    // Check max uses\r\n    if (data.max_uses && data.used_count >= data.max_uses) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has reached maximum uses' };\r\n    }\r\n\r\n    // Check min purchase amount\r\n    if (data.min_purchase_amount && subtotal < data.min_purchase_amount) {\r\n      return { \r\n        valid: false, \r\n        discountAmount: 0, \r\n        error: `Minimum purchase amount of R${data.min_purchase_amount} required` \r\n      };\r\n    }\r\n\r\n    // Calculate discount amount\r\n    let discountAmount = 0;\r\n    if (data.discount_type === 'percentage') {\r\n      discountAmount = (subtotal * data.discount_value) / 100;\r\n      if (data.max_discount_amount && discountAmount > data.max_discount_amount) {\r\n        discountAmount = data.max_discount_amount;\r\n      }\r\n    } else {\r\n      discountAmount = data.discount_value;\r\n    }\r\n\r\n    // Ensure discount doesn't exceed subtotal\r\n    discountAmount = Math.min(discountAmount, subtotal);\r\n\r\n    return { valid: true, discountAmount };\r\n  } catch (error) {\r\n    console.error('Error validating discount code:', error);\r\n    return { valid: false, discountAmount: 0, error: 'Error validating discount code' };\r\n  }\r\n}\r\n\r\n/**\r\n * Create booking draft (before payment)\r\n */\r\nexport async function createBookingDraft(formData: BookingFormData): Promise<{\r\n  success: boolean;\r\n  bookingId?: string;\r\n  bookingIds?: string[];\r\n  totalAmount?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current user if logged in\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n    const userId = user?.id || null;\r\n\r\n    // Get service name\r\n    const { data: service } = await supabase\r\n      .from('services')\r\n      .select('name')\r\n      .eq('id', formData.serviceId)\r\n      .single();\r\n\r\n    if (!service) {\r\n      return { success: false, error: 'Service not found' };\r\n    }\r\n\r\n    // Validate that the selected frequency is valid for this service\r\n    if (!isValidFrequencyForService(service.name, formData.cleaningFrequency)) {\r\n      return { \r\n        success: false, \r\n        error: `Recurring bookings are only available for Standard Cleaning and Airbnb Cleaning services. Selected service: ${service.name}` \r\n      };\r\n    }\r\n\r\n    // Calculate pricing\r\n    const priceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount: 0, // Will calculate discount in next step\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Apply discount code if provided\r\n    let discountAmount = 0;\r\n    if (formData.discountCode) {\r\n      const discountValidation = await validateDiscountCode(\r\n        formData.discountCode,\r\n        priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount\r\n      );\r\n      if (discountValidation.valid) {\r\n        discountAmount = discountValidation.discountAmount;\r\n      }\r\n    }\r\n\r\n    // Recalculate with discount\r\n    const finalPriceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount,\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Determine if this is a recurring booking\r\n    const isRecurring = formData.cleaningFrequency !== 'one-time';\r\n\r\n    // Calculate booking dates based on frequency\r\n    const startDate = new Date(formData.serviceDate);\r\n    const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n\r\n    // Calculate next booking date for recurring bookings\r\n    let nextBookingDate: Date | null = null;\r\n    if (isRecurring && bookingDates.length > 0) {\r\n      const lastDate = bookingDates[bookingDates.length - 1];\r\n      nextBookingDate = calculateNextBookingDate(lastDate, formData.cleaningFrequency);\r\n    }\r\n\r\n    // Create bookings for all dates\r\n    const bookingsToCreate: BookingCreateInput[] = [];\r\n\r\n    for (let i = 0; i < bookingDates.length; i++) {\r\n      const bookingDate = bookingDates[i];\r\n      const bookingNumber = generateBookingNumber();\r\n\r\n      // Tip is only applied to the first booking in a recurring series (one-time payment)\r\n      const tipAmount = (i === 0) ? (formData.tipAmount || 0) : 0;\r\n      \r\n      const bookingInput: BookingCreateInput = {\r\n        booking_number: bookingNumber,\r\n        customer_first_name: formData.customerFirstName,\r\n        customer_last_name: formData.customerLastName,\r\n        customer_email: formData.customerEmail,\r\n        customer_phone: formData.customerPhone,\r\n        service_id: formData.serviceId,\r\n        service_type: service.name,\r\n        bedrooms: formData.bedrooms,\r\n        bathrooms: formData.bathrooms,\r\n        additional_services: formData.additionalServices,\r\n        cleaning_equipment: formData.cleaningEquipment,\r\n        preferred_cleaner_ids: formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n          ? formData.preferredCleanerIds \r\n          : null,\r\n        preferred_cleaner_id: formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n          ? formData.preferredCleanerIds[0] \r\n          : null, // Backward compatibility: set to first cleaner\r\n        cleaning_frequency: formData.cleaningFrequency,\r\n        service_date: formatDateForDB(bookingDate),\r\n        service_time: formData.serviceTime,\r\n        service_duration: formData.serviceDuration,\r\n        service_address: formData.serviceAddress,\r\n        service_apt_unit: formData.serviceAptUnit || null,\r\n        service_suburb: formData.serviceSuburb,\r\n        service_city: formData.serviceCity,\r\n        special_instructions: formData.specialInstructions || null,\r\n        tip_amount: tipAmount,\r\n        base_price: finalPriceBreakdown.basePrice,\r\n        additional_services_price: finalPriceBreakdown.additionalServicesPrice,\r\n        equipment_supply_price: finalPriceBreakdown.equipmentSupplyPrice,\r\n        number_of_cleaners: formData.numberOfCleaners || 1,\r\n        additional_cleaners_price: finalPriceBreakdown.additionalCleanersPrice,\r\n        frequency_discount_percent: finalPriceBreakdown.frequencyDiscountPercent,\r\n        frequency_discount_amount: finalPriceBreakdown.frequencyDiscountAmount,\r\n        subtotal: finalPriceBreakdown.subtotal,\r\n        service_fee: finalPriceBreakdown.serviceFee,\r\n        total_amount: finalPriceBreakdown.totalAmount + tipAmount,\r\n        discount_code: formData.discountCode || null,\r\n        discount_amount: discountAmount,\r\n        referral_code: formData.referralCode || null,\r\n        amount_paid: 0,\r\n        payment_status: 'pending',\r\n        status: 'pending',\r\n        user_id: userId,\r\n        parent_booking_id: null, // Will be updated after first booking is created\r\n        is_recurring: isRecurring,\r\n        recurrence_status: isRecurring ? 'active' : undefined,\r\n        next_booking_date: i === 0 && isRecurring && nextBookingDate ? formatDateForDB(nextBookingDate) : null,\r\n      };\r\n\r\n      bookingsToCreate.push(bookingInput);\r\n    }\r\n\r\n    // Insert all bookings\r\n    const { data: insertedBookings, error } = await supabase\r\n      .from('bookings')\r\n      .insert(bookingsToCreate)\r\n      .select('id, total_amount');\r\n\r\n    if (error) {\r\n      console.error('Error creating booking drafts:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!insertedBookings || insertedBookings.length === 0) {\r\n      return { success: false, error: 'Failed to create bookings' };\r\n    }\r\n\r\n    // Update parent_booking_id for subsequent bookings if there are multiple\r\n    if (insertedBookings.length > 1 && isRecurring) {\r\n      const firstBookingId = insertedBookings[0].id;\r\n      const subsequentBookingIds = insertedBookings.slice(1).map(b => b.id);\r\n      \r\n      // Update all subsequent bookings to reference the first one\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({ parent_booking_id: firstBookingId })\r\n        .in('id', subsequentBookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating parent_booking_id:', updateError);\r\n        // Don't fail, but log the error\r\n      }\r\n    }\r\n\r\n    // Calculate total amount\r\n    const totalAmount = insertedBookings.reduce((sum, booking) => sum + Number(booking.total_amount), 0);\r\n    const bookingIds = insertedBookings.map(booking => booking.id);\r\n\r\n    // For backward compatibility, also return single bookingId\r\n    const bookingId = bookingIds[0];\r\n\r\n    // If multiple bookings, return array; otherwise return single ID for backward compatibility\r\n    if (bookingIds.length > 1) {\r\n      return { \r\n        success: true, \r\n        bookingIds,\r\n        totalAmount,\r\n        bookingId // Keep for backward compatibility\r\n      };\r\n    }\r\n\r\n    return { \r\n      success: true, \r\n      bookingId,\r\n      bookingIds,\r\n      totalAmount\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error creating booking draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize payment for booking(s)\r\n * Accepts either a single bookingId or an array of bookingIds\r\n */\r\nexport async function initializePaymentForBooking(\r\n  bookingIdOrIds: string | string[]\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const bookingIds = Array.isArray(bookingIdOrIds) ? bookingIdOrIds : [bookingIdOrIds];\r\n\r\n    // Get all booking details\r\n    const { data: bookings, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (fetchError || !bookings || bookings.length === 0) {\r\n      return { success: false, error: 'Booking(s) not found' };\r\n    }\r\n\r\n    // Check if all bookings are in pending status\r\n    const nonPendingBookings = bookings.filter(b => b.payment_status !== 'pending');\r\n    if (nonPendingBookings.length > 0) {\r\n      return { success: false, error: 'Some bookings are not in pending payment status' };\r\n    }\r\n\r\n    // Calculate total amount from all bookings (including tip)\r\n    // Note: total_amount in database now includes tip for new bookings\r\n    // For backward compatibility with existing bookings that might not have tip in total_amount, \r\n    // we check and add tip_amount if it's missing\r\n    const totalAmount = bookings.reduce((sum, booking) => {\r\n      const bookingTotal = Number(booking.total_amount) || 0;\r\n      const tipAmount = Number(booking.tip_amount) || 0;\r\n      const baseTotal = Number(booking.subtotal || 0) + Number(booking.service_fee || 0);\r\n      \r\n      // Check if tip is already included in total_amount\r\n      // If total_amount equals baseTotal exactly, then tip is not included, so add it\r\n      // Otherwise, total_amount already includes tip\r\n      if (tipAmount > 0 && Math.abs(bookingTotal - baseTotal) < 0.01) {\r\n        // Tip is not included in total_amount (backward compatibility case)\r\n        return sum + bookingTotal + tipAmount;\r\n      }\r\n      // Tip is already included in total_amount (new bookings)\r\n      return sum + bookingTotal;\r\n    }, 0);\r\n    \r\n    // Use the first booking's email and details for payment\r\n    const firstBooking = bookings[0];\r\n    const reference = firstBooking.paystack_reference || `${firstBooking.booking_number}${Date.now()}`;\r\n    \r\n    // Initialize Paystack payment with total amount\r\n    const paymentResponse = await initializePayment(\r\n      firstBooking.customer_email,\r\n      totalAmount,\r\n      reference,\r\n      {\r\n        booking_ids: bookingIds,\r\n        booking_id: firstBooking.id, // Keep for backward compatibility\r\n        booking_number: firstBooking.booking_number,\r\n        customer_email: firstBooking.customer_email,\r\n      }\r\n    );\r\n\r\n    if (!paymentResponse.status) {\r\n      return { success: false, error: paymentResponse.message || 'Failed to initialize payment' };\r\n    }\r\n\r\n    // Use the reference that Paystack actually returned (may differ from what we sent)\r\n    const paystackReference = paymentResponse.data.reference;\r\n\r\n    // Update all bookings with the Paystack reference that was actually returned\r\n    const { error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        paystack_reference: paystackReference,\r\n      })\r\n      .in('id', bookingIds);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating bookings with Paystack reference:', updateError);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentResponse.data.authorization_url,\r\n      reference: paystackReference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing payment:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get booking by ID\r\n */\r\nexport async function getBooking(bookingId: string): Promise<{\r\n  success: boolean;\r\n  booking?: any;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners for selection\r\n * Optionally filter by service area/suburb\r\n */\r\nexport async function getAvailableCleaners(serviceSuburb?: string): Promise<{\r\n  success: boolean;\r\n  cleaners?: any[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Build query - only filter by is_available if the column exists\r\n    // First, try to get all active cleaners\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = data || [];\r\n\r\n    // Filter by is_available if the column exists (client-side filter as fallback)\r\n    cleaners = cleaners.filter((cleaner) => {\r\n      // If is_available column doesn't exist or is null/undefined, include the cleaner\r\n      // Otherwise, only include if is_available is true\r\n      return cleaner.is_available !== false;\r\n    });\r\n\r\n    // Filter by area if suburb is provided\r\n    // Since PostgreSQL array contains is complex in Supabase, we filter client-side\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        // If cleaner has no areas specified, include them (they serve all areas)\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true;\r\n        }\r\n        // Check if any area matches the suburb (case-insensitive partial match)\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    return { success: true, cleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a cleaner is available for a specific day of the week\r\n * dayOfWeek: 0 = Sunday, 1 = Monday, ..., 6 = Saturday\r\n */\r\nexport async function isCleanerAvailableForDay(cleaner: any, dayOfWeek: number): Promise<boolean> {\r\n  const dayMap: Record<number, keyof typeof cleaner> = {\r\n    0: 'available_sunday',\r\n    1: 'available_monday',\r\n    2: 'available_tuesday',\r\n    3: 'available_wednesday',\r\n    4: 'available_thursday',\r\n    5: 'available_friday',\r\n    6: 'available_saturday',\r\n  };\r\n\r\n  const dayField = dayMap[dayOfWeek];\r\n  return cleaner[dayField] !== false && cleaner.is_available !== false;\r\n}\r\n\r\n/**\r\n * Check if a cleaner has a booking conflict for a specific date and time slot\r\n */\r\nexport async function checkCleanerBookingConflict(\r\n  cleanerId: string,\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Query bookings for this cleaner on the specified date\r\n    const { data: bookings, error } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration')\r\n      .eq('preferred_cleaner_id', cleanerId)\r\n      .eq('service_date', serviceDate)\r\n      .in('status', ['pending', 'confirmed']);\r\n\r\n    if (error) {\r\n      console.error('Error checking booking conflicts:', error);\r\n      return false; // Assume no conflict on error\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      return false; // No bookings, no conflict\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n\r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number'\r\n          ? booking.service_duration\r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        return true; // Conflict found\r\n      }\r\n    }\r\n\r\n    return false; // No conflicts\r\n  } catch (error) {\r\n    console.error('Unexpected error checking booking conflict:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate reliability score for a cleaner (server-side wrapper)\r\n * This calls the database function if available, otherwise calculates client-side\r\n */\r\nexport async function calculateCleanerReliabilityScore(cleanerId: string): Promise<number> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Try to call the database function\r\n    const { data, error } = await supabase.rpc('calculate_cleaner_reliability_score', {\r\n      cleaner_id: cleanerId,\r\n    });\r\n\r\n    if (!error && data !== null) {\r\n      return parseFloat(data.toString());\r\n    }\r\n\r\n    // Fallback: fetch cleaner and calculate client-side\r\n    const { data: cleaner, error: fetchError } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('id', cleanerId)\r\n      .single();\r\n\r\n    if (fetchError || !cleaner) {\r\n      return 50.0; // Default score\r\n    }\r\n\r\n    return calculateReliabilityScore(cleaner as Cleaner);\r\n  } catch (error) {\r\n    console.error('Error calculating reliability score:', error);\r\n    return 50.0; // Default score on error\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners with enhanced filtering criteria\r\n * Filters by: Location, Availability, Booking conflicts\r\n * Sorts by: Reliability Score, Rating\r\n */\r\nexport async function getAvailableCleanersWithCriteria(params: {\r\n  serviceSuburb?: string;\r\n  serviceDate?: string;\r\n  serviceTime?: string;\r\n  serviceDuration?: number;\r\n  minRating?: number;\r\n  minReliabilityScore?: number;\r\n}): Promise<{\r\n  success: boolean;\r\n  cleaners?: CleanerWithAvailability[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const {\r\n      serviceSuburb,\r\n      serviceDate,\r\n      serviceTime,\r\n      serviceDuration = 3,\r\n      minRating = 0,\r\n      minReliabilityScore = 0,\r\n    } = params;\r\n\r\n    // Build base query\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query.order('reliability_score', { ascending: false, nullsFirst: false })\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = (data || []) as Cleaner[];\r\n\r\n    // Filter by is_available\r\n    cleaners = cleaners.filter((cleaner) => cleaner.is_available !== false);\r\n\r\n    // Filter by location (suburb)\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true; // Serve all areas\r\n        }\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Filter by day of week availability if date is provided\r\n    if (serviceDate) {\r\n      const date = new Date(serviceDate);\r\n      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        const dayMap: Record<number, keyof Cleaner> = {\r\n          0: 'available_sunday',\r\n          1: 'available_monday',\r\n          2: 'available_tuesday',\r\n          3: 'available_wednesday',\r\n          4: 'available_thursday',\r\n          5: 'available_friday',\r\n          6: 'available_saturday',\r\n        };\r\n        const dayField = dayMap[dayOfWeek];\r\n        return cleaner[dayField] !== false;\r\n      });\r\n    }\r\n\r\n    // Filter by minimum rating\r\n    if (minRating > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.rating || 0) >= minRating);\r\n    }\r\n\r\n    // Filter by minimum reliability score\r\n    if (minReliabilityScore > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.reliability_score || 0) >= minReliabilityScore);\r\n    }\r\n\r\n    // Enrich cleaners with availability and booking conflict information\r\n    const enrichedCleaners: CleanerWithAvailability[] = await Promise.all(\r\n      cleaners.map(async (cleaner) => {\r\n        let isAvailableForSlot = true;\r\n        let bookingConflict = false;\r\n\r\n        // Check booking conflict if date and time are provided\r\n        if (serviceDate && serviceTime && serviceDuration) {\r\n          bookingConflict = await checkCleanerBookingConflict(\r\n            cleaner.id,\r\n            serviceDate,\r\n            serviceTime,\r\n            serviceDuration\r\n          );\r\n          isAvailableForSlot = !bookingConflict;\r\n        }\r\n\r\n        // Calculate reliability score if not present\r\n        const reliabilityScore = cleaner.reliability_score ?? calculateReliabilityScore(cleaner);\r\n\r\n        return {\r\n          ...cleaner,\r\n          reliability_score: reliabilityScore,\r\n          isAvailableForSlot,\r\n          bookingConflict,\r\n          completionRate: calculateCompletionRate(cleaner),\r\n          onTimeRate: calculateOnTimeRate(cleaner),\r\n        };\r\n      })\r\n    );\r\n\r\n    // Sort by reliability score and rating (already sorted by query, but ensure consistency)\r\n    enrichedCleaners.sort((a, b) => {\r\n      const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n      const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n\r\n    return { success: true, cleaners: enrichedCleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners with criteria:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;MAinBsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8CAAA"}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/27825/shalean-v2/shalean-reimagined/app/booking/confirmation/%5BbookingId%5D/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useEffect, useState } from 'react';\r\nimport { useParams, useRouter } from 'next/navigation';\r\nimport { Loader2, CheckCircle2, Calendar, Clock, MapPin, Mail, Phone, User } from 'lucide-react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { getBooking } from '../../book/actions';\r\nimport { format } from 'date-fns';\r\nimport Footer from '@/components/Footer';\r\nimport { Hand } from 'lucide-react';\r\n\r\nexport default function BookingConfirmationPage() {\r\n  const params = useParams();\r\n  const router = useRouter();\r\n  const bookingId = params.bookingId as string;\r\n\r\n  const [booking, setBooking] = useState<any>(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (bookingId) {\r\n      getBooking(bookingId).then((result) => {\r\n        if (result.success && result.booking) {\r\n          setBooking(result.booking);\r\n        } else {\r\n          setError(result.error || 'Booking not found');\r\n        }\r\n        setLoading(false);\r\n      });\r\n    }\r\n  }, [bookingId]);\r\n\r\n  if (loading) {\r\n    return (\r\n      <div className=\"min-h-screen flex items-center justify-center\">\r\n        <Loader2 className=\"w-8 h-8 animate-spin text-primary\" />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (error || !booking) {\r\n    return (\r\n      <div className=\"min-h-screen flex items-center justify-center\">\r\n        <div className=\"text-center\">\r\n          <h1 className=\"text-2xl font-bold mb-4\">Booking Not Found</h1>\r\n          <p className=\"text-muted-foreground mb-4\">{error || 'The booking you are looking for does not exist.'}</p>\r\n          <Button onClick={() => router.push('/booking/details')}>Book Now</Button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-muted/30\">\r\n      {/* Header */}\r\n      <div className=\"bg-white border-b border-border\">\r\n        <div className=\"container mx-auto px-4 md:px-6 py-4 max-w-4xl\">\r\n          <div className=\"flex items-center gap-2\">\r\n            <div className=\"w-10 h-10 rounded-full bg-primary flex items-center justify-center\">\r\n              <Hand className=\"w-5 h-5 text-primary-foreground\" />\r\n            </div>\r\n            <span className=\"font-bold text-xl text-foreground\">Shalean</span>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <main className=\"container mx-auto px-4 md:px-6 py-12 max-w-4xl\">\r\n        {/* Success Message */}\r\n        <div className=\"bg-white rounded-xl p-8 mb-8 text-center border border-border\">\r\n          <div className=\"w-16 h-16 rounded-full bg-green-100 flex items-center justify-center mx-auto mb-4\">\r\n            <CheckCircle2 className=\"w-10 h-10 text-green-600\" />\r\n          </div>\r\n          <h1 className=\"text-3xl font-bold mb-2\">Booking Confirmed!</h1>\r\n          <p className=\"text-muted-foreground\">\r\n            Your booking has been successfully created. A confirmation email has been sent to {booking.customer_email}.\r\n          </p>\r\n          <div className=\"mt-6 p-4 bg-muted rounded-lg\">\r\n            <p className=\"text-sm text-muted-foreground mb-1\">Booking Reference</p>\r\n            <p className=\"text-2xl font-bold\">{booking.booking_number}</p>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Booking Details */}\r\n        <div className=\"bg-white rounded-xl p-8 border border-border space-y-6\">\r\n          <h2 className=\"text-2xl font-bold\">Booking Details</h2>\r\n\r\n          {/* Service Information */}\r\n          <div className=\"grid md:grid-cols-2 gap-6\">\r\n            <div>\r\n              <h3 className=\"font-semibold mb-2\">Service</h3>\r\n              <p className=\"text-muted-foreground\">{booking.service_type}</p>\r\n            </div>\r\n            <div>\r\n              <h3 className=\"font-semibold mb-2\">Property</h3>\r\n              <p className=\"text-muted-foreground\">\r\n                {booking.bedrooms} Bedrooms, {booking.bathrooms} Bathrooms\r\n              </p>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Schedule */}\r\n          <div>\r\n            <h3 className=\"font-semibold mb-2 flex items-center gap-2\">\r\n              <Calendar className=\"w-5 h-5\" />\r\n              Schedule\r\n            </h3>\r\n            <div className=\"flex items-center gap-4\">\r\n              <p className=\"text-muted-foreground\">\r\n                {format(new Date(booking.service_date), 'EEEE, MMMM d, yyyy')}\r\n              </p>\r\n              <div className=\"flex items-center gap-2\">\r\n                <Clock className=\"w-4 h-4 text-muted-foreground\" />\r\n                <span className=\"text-muted-foreground\">{booking.service_time}</span>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Address */}\r\n          <div>\r\n            <h3 className=\"font-semibold mb-2 flex items-center gap-2\">\r\n              <MapPin className=\"w-5 h-5\" />\r\n              Service Address\r\n            </h3>\r\n            <p className=\"text-muted-foreground\">\r\n              {booking.service_address}\r\n              {booking.service_apt_unit && `, ${booking.service_apt_unit}`}\r\n              <br />\r\n              {booking.service_suburb}, {booking.service_city}\r\n            </p>\r\n          </div>\r\n\r\n          {/* Contact Information */}\r\n          <div>\r\n            <h3 className=\"font-semibold mb-2\">Contact Information</h3>\r\n            <div className=\"space-y-2\">\r\n              <div className=\"flex items-center gap-2\">\r\n                <User className=\"w-4 h-4 text-muted-foreground\" />\r\n                <span>{booking.customer_first_name} {booking.customer_last_name}</span>\r\n              </div>\r\n              <div className=\"flex items-center gap-2\">\r\n                <Mail className=\"w-4 h-4 text-muted-foreground\" />\r\n                <span>{booking.customer_email}</span>\r\n              </div>\r\n              <div className=\"flex items-center gap-2\">\r\n                <Phone className=\"w-4 h-4 text-muted-foreground\" />\r\n                <span>{booking.customer_phone}</span>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Payment Summary */}\r\n          <div className=\"pt-6 border-t border-border\">\r\n            <h3 className=\"font-semibold mb-4\">Payment Summary</h3>\r\n            <div className=\"space-y-2\">\r\n              <div className=\"flex justify-between\">\r\n                <span className=\"text-muted-foreground\">Subtotal</span>\r\n                <span>R{booking.subtotal.toFixed(2)}</span>\r\n              </div>\r\n              {booking.discount_amount > 0 && (\r\n                <div className=\"flex justify-between text-green-600\">\r\n                  <span>Discount</span>\r\n                  <span>-R{booking.discount_amount.toFixed(2)}</span>\r\n                </div>\r\n              )}\r\n              <div className=\"flex justify-between\">\r\n                <span className=\"text-muted-foreground\">Service Fee</span>\r\n                <span>R{booking.service_fee.toFixed(2)}</span>\r\n              </div>\r\n              <div className=\"flex justify-between pt-2 border-t border-border font-bold text-lg\">\r\n                <span>Total Paid</span>\r\n                <span className=\"text-primary\">R{booking.total_amount.toFixed(2)}</span>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Actions */}\r\n          <div className=\"pt-6 border-t border-border flex gap-4\">\r\n            <Button onClick={() => router.push('/')}>Back to Home</Button>\r\n            <Button variant=\"outline\" onClick={() => window.print()}>\r\n              Print Confirmation\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </main>\r\n\r\n      <Footer />\r\n    </div>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AATA;;;;;;;;;AAWe,SAAS;;IACtB,MAAM,SAAS,IAAA,kJAAS;IACxB,MAAM,SAAS,IAAA,kJAAS;IACxB,MAAM,YAAY,OAAO,SAAS;IAElC,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAM;IAC5C,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IACvC,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAgB;IAElD,IAAA,0KAAS;6CAAC;YACR,IAAI,WAAW;gBACb,IAAA,+KAAU,EAAC,WAAW,IAAI;yDAAC,CAAC;wBAC1B,IAAI,OAAO,OAAO,IAAI,OAAO,OAAO,EAAE;4BACpC,WAAW,OAAO,OAAO;wBAC3B,OAAO;4BACL,SAAS,OAAO,KAAK,IAAI;wBAC3B;wBACA,WAAW;oBACb;;YACF;QACF;4CAAG;QAAC;KAAU;IAEd,IAAI,SAAS;QACX,qBACE,6LAAC;YAAI,WAAU;sBACb,cAAA,6LAAC,+NAAO;gBAAC,WAAU;;;;;;;;;;;IAGzB;IAEA,IAAI,SAAS,CAAC,SAAS;QACrB,qBACE,6LAAC;YAAI,WAAU;sBACb,cAAA,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAG,WAAU;kCAA0B;;;;;;kCACxC,6LAAC;wBAAE,WAAU;kCAA8B,SAAS;;;;;;kCACpD,6LAAC,+IAAM;wBAAC,SAAS,IAAM,OAAO,IAAI,CAAC;kCAAqB;;;;;;;;;;;;;;;;;IAIhE;IAEA,qBACE,6LAAC;QAAI,WAAU;;0BAEb,6LAAC;gBAAI,WAAU;0BACb,cAAA,6LAAC;oBAAI,WAAU;8BACb,cAAA,6LAAC;wBAAI,WAAU;;0CACb,6LAAC;gCAAI,WAAU;0CACb,cAAA,6LAAC,6MAAI;oCAAC,WAAU;;;;;;;;;;;0CAElB,6LAAC;gCAAK,WAAU;0CAAoC;;;;;;;;;;;;;;;;;;;;;;0BAK1D,6LAAC;gBAAK,WAAU;;kCAEd,6LAAC;wBAAI,WAAU;;0CACb,6LAAC;gCAAI,WAAU;0CACb,cAAA,6LAAC,wOAAY;oCAAC,WAAU;;;;;;;;;;;0CAE1B,6LAAC;gCAAG,WAAU;0CAA0B;;;;;;0CACxC,6LAAC;gCAAE,WAAU;;oCAAwB;oCACgD,QAAQ,cAAc;oCAAC;;;;;;;0CAE5G,6LAAC;gCAAI,WAAU;;kDACb,6LAAC;wCAAE,WAAU;kDAAqC;;;;;;kDAClD,6LAAC;wCAAE,WAAU;kDAAsB,QAAQ,cAAc;;;;;;;;;;;;;;;;;;kCAK7D,6LAAC;wBAAI,WAAU;;0CACb,6LAAC;gCAAG,WAAU;0CAAqB;;;;;;0CAGnC,6LAAC;gCAAI,WAAU;;kDACb,6LAAC;;0DACC,6LAAC;gDAAG,WAAU;0DAAqB;;;;;;0DACnC,6LAAC;gDAAE,WAAU;0DAAyB,QAAQ,YAAY;;;;;;;;;;;;kDAE5D,6LAAC;;0DACC,6LAAC;gDAAG,WAAU;0DAAqB;;;;;;0DACnC,6LAAC;gDAAE,WAAU;;oDACV,QAAQ,QAAQ;oDAAC;oDAAY,QAAQ,SAAS;oDAAC;;;;;;;;;;;;;;;;;;;0CAMtD,6LAAC;;kDACC,6LAAC;wCAAG,WAAU;;0DACZ,6LAAC,yNAAQ;gDAAC,WAAU;;;;;;4CAAY;;;;;;;kDAGlC,6LAAC;wCAAI,WAAU;;0DACb,6LAAC;gDAAE,WAAU;0DACV,IAAA,mKAAM,EAAC,IAAI,KAAK,QAAQ,YAAY,GAAG;;;;;;0DAE1C,6LAAC;gDAAI,WAAU;;kEACb,6LAAC,gNAAK;wDAAC,WAAU;;;;;;kEACjB,6LAAC;wDAAK,WAAU;kEAAyB,QAAQ,YAAY;;;;;;;;;;;;;;;;;;;;;;;;0CAMnE,6LAAC;;kDACC,6LAAC;wCAAG,WAAU;;0DACZ,6LAAC,uNAAM;gDAAC,WAAU;;;;;;4CAAY;;;;;;;kDAGhC,6LAAC;wCAAE,WAAU;;4CACV,QAAQ,eAAe;4CACvB,QAAQ,gBAAgB,IAAI,CAAC,EAAE,EAAE,QAAQ,gBAAgB,EAAE;0DAC5D,6LAAC;;;;;4CACA,QAAQ,cAAc;4CAAC;4CAAG,QAAQ,YAAY;;;;;;;;;;;;;0CAKnD,6LAAC;;kDACC,6LAAC;wCAAG,WAAU;kDAAqB;;;;;;kDACnC,6LAAC;wCAAI,WAAU;;0DACb,6LAAC;gDAAI,WAAU;;kEACb,6LAAC,6MAAI;wDAAC,WAAU;;;;;;kEAChB,6LAAC;;4DAAM,QAAQ,mBAAmB;4DAAC;4DAAE,QAAQ,kBAAkB;;;;;;;;;;;;;0DAEjE,6LAAC;gDAAI,WAAU;;kEACb,6LAAC,6MAAI;wDAAC,WAAU;;;;;;kEAChB,6LAAC;kEAAM,QAAQ,cAAc;;;;;;;;;;;;0DAE/B,6LAAC;gDAAI,WAAU;;kEACb,6LAAC,gNAAK;wDAAC,WAAU;;;;;;kEACjB,6LAAC;kEAAM,QAAQ,cAAc;;;;;;;;;;;;;;;;;;;;;;;;0CAMnC,6LAAC;gCAAI,WAAU;;kDACb,6LAAC;wCAAG,WAAU;kDAAqB;;;;;;kDACnC,6LAAC;wCAAI,WAAU;;0DACb,6LAAC;gDAAI,WAAU;;kEACb,6LAAC;wDAAK,WAAU;kEAAwB;;;;;;kEACxC,6LAAC;;4DAAK;4DAAE,QAAQ,QAAQ,CAAC,OAAO,CAAC;;;;;;;;;;;;;4CAElC,QAAQ,eAAe,GAAG,mBACzB,6LAAC;gDAAI,WAAU;;kEACb,6LAAC;kEAAK;;;;;;kEACN,6LAAC;;4DAAK;4DAAG,QAAQ,eAAe,CAAC,OAAO,CAAC;;;;;;;;;;;;;0DAG7C,6LAAC;gDAAI,WAAU;;kEACb,6LAAC;wDAAK,WAAU;kEAAwB;;;;;;kEACxC,6LAAC;;4DAAK;4DAAE,QAAQ,WAAW,CAAC,OAAO,CAAC;;;;;;;;;;;;;0DAEtC,6LAAC;gDAAI,WAAU;;kEACb,6LAAC;kEAAK;;;;;;kEACN,6LAAC;wDAAK,WAAU;;4DAAe;4DAAE,QAAQ,YAAY,CAAC,OAAO,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;0CAMpE,6LAAC;gCAAI,WAAU;;kDACb,6LAAC,+IAAM;wCAAC,SAAS,IAAM,OAAO,IAAI,CAAC;kDAAM;;;;;;kDACzC,6LAAC,+IAAM;wCAAC,SAAQ;wCAAU,SAAS,IAAM,OAAO,KAAK;kDAAI;;;;;;;;;;;;;;;;;;;;;;;;0BAO/D,6LAAC,0IAAM;;;;;;;;;;;AAGb;GAlLwB;;QACP,kJAAS;QACT,kJAAS;;;KAFF"}}]
}