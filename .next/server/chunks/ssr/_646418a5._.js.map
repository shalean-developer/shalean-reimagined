{"version":3,"sources":["../../../../app/booking/quote/data%3A805cf7%20%3Ctext/javascript%3E","../../../../src/lib/utils/slug.ts","../../../../app/booking/book/context/BookingFormContext.tsx","../../../../app/booking/book/hooks/useBookingForm.ts","../../../../src/lib/utils/cleaner-utils.ts","../../../../src/lib/utils/service-validation.ts","../../../../app/booking/book/actions-client.ts"],"sourcesContent":["/* __next_internal_action_entry_do_not_use__ [{\"00356ed3d067e417ab658e33cb25cca0a078f0eecd\":\"getServices\"},\"app/booking/quote/actions.ts\",\"\"] */\"use turbopack no side effects\";import{createServerReference,callServer,findSourceMapURL}from\"private-next-rsc-action-client-wrapper\";const $$RSC_SERVER_ACTION_4=/*#__PURE__*/createServerReference(\"00356ed3d067e417ab658e33cb25cca0a078f0eecd\",callServer,void 0,findSourceMapURL,\"getServices\");export{$$RSC_SERVER_ACTION_4 as getServices};","import { Service } from '@/types/quote';\r\n\r\n/**\r\n * Generate a URL-friendly slug from a service name\r\n * Examples:\r\n * - \"Standard Cleaning\" → \"standard-cleaning\"\r\n * - \"Move In/Out\" → \"move-in-out\"\r\n * - \"Airbnb Cleaning\" → \"airbnb-cleaning\"\r\n */\r\nexport function generateSlug(name: string): string {\r\n  return name\r\n    .toLowerCase()\r\n    .trim()\r\n    // Replace slashes with hyphens\r\n    .replace(/\\//g, '-')\r\n    // Replace spaces and special characters with hyphens\r\n    .replace(/[^\\w\\s-]/g, '')\r\n    .replace(/\\s+/g, '-')\r\n    // Remove multiple consecutive hyphens\r\n    .replace(/-+/g, '-')\r\n    // Remove leading/trailing hyphens\r\n    .replace(/^-+|-+$/g, '');\r\n}\r\n\r\n/**\r\n * Find a service by its slug\r\n */\r\nexport function findServiceBySlug(services: Service[], slug: string): Service | undefined {\r\n  return services.find(service => generateSlug(service.name) === slug);\r\n}\r\n\r\n/**\r\n * Get the slug for a service by its ID\r\n */\r\nexport function getServiceSlugById(services: Service[], serviceId: string): string | undefined {\r\n  const service = services.find(s => s.id === serviceId);\r\n  return service ? generateSlug(service.name) : undefined;\r\n}\r\n\r\n","'use client';\r\n\r\nimport { createContext, useContext, ReactNode } from 'react';\r\nimport { useBookingForm } from '../hooks/useBookingForm';\r\n\r\ninterface BookingFormContextValue {\r\n  currentStep: number;\r\n  serviceSlug: string | null;\r\n  formData: ReturnType<typeof useBookingForm>['formData'];\r\n  updateFormData: ReturnType<typeof useBookingForm>['updateFormData'];\r\n  resetForm: ReturnType<typeof useBookingForm>['resetForm'];\r\n  nextStep: ReturnType<typeof useBookingForm>['nextStep'];\r\n  previousStep: ReturnType<typeof useBookingForm>['previousStep'];\r\n  goToStep: ReturnType<typeof useBookingForm>['goToStep'];\r\n  goToStepByUrl: ReturnType<typeof useBookingForm>['goToStepByUrl'];\r\n  getStepUrl: ReturnType<typeof useBookingForm>['getStepUrl'];\r\n  setServicesForSlug: ReturnType<typeof useBookingForm>['setServicesForSlug'];\r\n  isStepCompleted: ReturnType<typeof useBookingForm>['isStepCompleted'];\r\n  getDiscountAmount: ReturnType<typeof useBookingForm>['getDiscountAmount'];\r\n  setDiscountAmount: ReturnType<typeof useBookingForm>['setDiscountAmount'];\r\n  clearDiscountAmount: ReturnType<typeof useBookingForm>['clearDiscountAmount'];\r\n  validateStep1: ReturnType<typeof useBookingForm>['validateStep1'];\r\n  validateStep2: ReturnType<typeof useBookingForm>['validateStep2'];\r\n  validateStep3: ReturnType<typeof useBookingForm>['validateStep3'];\r\n  validateCurrentStep: ReturnType<typeof useBookingForm>['validateCurrentStep'];\r\n}\r\n\r\nconst BookingFormContext = createContext<BookingFormContextValue | undefined>(undefined);\r\n\r\nexport function BookingFormProvider({ children }: { children: ReactNode }) {\r\n  const bookingForm = useBookingForm();\r\n\r\n  return (\r\n    <BookingFormContext.Provider value={bookingForm}>\r\n      {children}\r\n    </BookingFormContext.Provider>\r\n  );\r\n}\r\n\r\nexport function useBookingFormContext() {\r\n  const context = useContext(BookingFormContext);\r\n  if (context === undefined) {\r\n    throw new Error('useBookingFormContext must be used within a BookingFormProvider');\r\n  }\r\n  return context;\r\n}\r\n\r\n","'use client';\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { useRouter, usePathname } from 'next/navigation';\r\nimport { BookingFormData } from '@/types/booking';\r\nimport { getServiceSlugById } from '@/lib/utils/slug';\r\nimport { Service } from '@/types/quote';\r\n\r\nconst STORAGE_KEY = 'shalean_booking_form_draft';\r\nconst DISCOUNT_AMOUNT_KEY = 'shalean_booking_discount_amount';\r\n\r\n// URL to step mapping (supports both with and without slug)\r\nconst getStepFromPath = (pathname: string): number => {\r\n  if (pathname.startsWith('/booking/details')) return 1;\r\n  if (pathname.startsWith('/booking/worker')) return 2;\r\n  if (pathname.startsWith('/booking/submit')) return 3;\r\n  return 1;\r\n};\r\n\r\n// Extract service slug from pathname\r\nconst extractServiceSlug = (pathname: string): string | null => {\r\n  const match = pathname.match(/\\/booking\\/(details|worker|submit)\\/([^/]+)/);\r\n  return match ? match[2] : null;\r\n};\r\n\r\nconst defaultFormData: BookingFormData = {\r\n  // Step 1\r\n  serviceId: '',\r\n  bedrooms: '0',\r\n  bathrooms: '1',\r\n  additionalServices: [],\r\n  cleaningEquipment: '',\r\n  serviceDate: '',\r\n  serviceTime: '',\r\n  serviceDuration: 3.5,\r\n  specialInstructions: '',\r\n  // Carpet Cleaning specific fields\r\n  carpetTypes: [],\r\n  roomStatus: '',\r\n  numberOfFittedRooms: '',\r\n  numberOfLooseCarpets: '',\r\n  numberOfCleaners: 1,\r\n  \r\n  // Step 2\r\n  serviceAddress: '',\r\n  serviceAptUnit: '',\r\n  serviceSuburb: '',\r\n  serviceCity: '',\r\n  preferredCleanerIds: [],\r\n  teamNumber: null,\r\n  cleaningFrequency: 'one-time',\r\n  \r\n  // Step 3\r\n  customerFirstName: '',\r\n  customerLastName: '',\r\n  customerEmail: '',\r\n  customerPhone: '',\r\n  tipAmount: 0,\r\n  discountCode: '',\r\n  referralCode: '',\r\n};\r\n\r\nexport function useBookingForm() {\r\n  const router = useRouter();\r\n  const pathname = usePathname();\r\n  const [formData, setFormData] = useState<BookingFormData>(defaultFormData);\r\n  const [isDirty, setIsDirty] = useState(false);\r\n  const [services, setServices] = useState<Service[]>([]);\r\n\r\n  // Get current step from URL\r\n  const currentStep = getStepFromPath(pathname);\r\n  \r\n  // Get service slug from URL\r\n  const serviceSlug = extractServiceSlug(pathname);\r\n\r\n  // Load draft from localStorage on mount\r\n  useEffect(() => {\r\n    try {\r\n      const saved = localStorage.getItem(STORAGE_KEY);\r\n      const savedReferralCode = localStorage.getItem('shalean_referral_code');\r\n      \r\n      if (saved) {\r\n        const parsed = JSON.parse(saved);\r\n        // Migrate old preferredCleanerId to preferredCleanerIds array\r\n        if (parsed.preferredCleanerId !== undefined && parsed.preferredCleanerIds === undefined) {\r\n          parsed.preferredCleanerIds = parsed.preferredCleanerId ? [parsed.preferredCleanerId] : [];\r\n          delete parsed.preferredCleanerId; // Remove old field\r\n        }\r\n        // Ensure preferredCleanerIds is always an array\r\n        if (!Array.isArray(parsed.preferredCleanerIds)) {\r\n          parsed.preferredCleanerIds = [];\r\n        }\r\n        // Preserve referral code from localStorage if not in saved data\r\n        if (savedReferralCode && !parsed.referralCode) {\r\n          parsed.referralCode = savedReferralCode;\r\n        }\r\n        setFormData({ ...defaultFormData, ...parsed });\r\n      } else if (savedReferralCode) {\r\n        // If no saved form data but referral code exists, set it\r\n        setFormData({ ...defaultFormData, referralCode: savedReferralCode });\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading form draft:', error);\r\n    }\r\n  }, []);\r\n\r\n  // Auto-save to localStorage when form data changes\r\n  useEffect(() => {\r\n    if (isDirty) {\r\n      try {\r\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(formData));\r\n      } catch (error) {\r\n        console.error('Error saving form draft:', error);\r\n      }\r\n    }\r\n  }, [formData, isDirty]);\r\n\r\n  const updateFormData = useCallback((updates: Partial<BookingFormData>) => {\r\n    setFormData((prev) => {\r\n      const updated = { ...prev, ...updates };\r\n      // Ensure preferredCleanerIds is always an array\r\n      if (updated.preferredCleanerIds !== undefined && !Array.isArray(updated.preferredCleanerIds)) {\r\n        updated.preferredCleanerIds = [];\r\n      }\r\n      setIsDirty(true);\r\n      return updated;\r\n    });\r\n  }, []);\r\n\r\n  const resetForm = useCallback(() => {\r\n    setFormData(defaultFormData);\r\n    setIsDirty(false);\r\n    try {\r\n      localStorage.removeItem(STORAGE_KEY);\r\n      localStorage.removeItem(DISCOUNT_AMOUNT_KEY);\r\n    } catch (error) {\r\n      console.error('Error clearing form draft:', error);\r\n    }\r\n    router.push('/booking/details');\r\n  }, [router]);\r\n\r\n  // Get URL for a step, preserving service slug if available\r\n  const getStepUrl = useCallback((step: number, slug?: string | null): string => {\r\n    const stepPaths = {\r\n      1: '/booking/details',\r\n      2: '/booking/worker',\r\n      3: '/booking/submit',\r\n    };\r\n    \r\n    const baseUrl = stepPaths[step as keyof typeof stepPaths];\r\n    if (!baseUrl) return '/booking/details';\r\n    \r\n    // Priority: provided slug > current URL slug > generate from formData > no slug\r\n    let finalSlug = slug;\r\n    \r\n    // If no slug provided, use current URL slug\r\n    if (!finalSlug) {\r\n      finalSlug = serviceSlug;\r\n    }\r\n    \r\n    // If still no slug, try to generate from formData (only if services are loaded)\r\n    if (!finalSlug && formData.serviceId && services.length > 0) {\r\n      finalSlug = getServiceSlugById(services, formData.serviceId) || null;\r\n    }\r\n    \r\n    return finalSlug ? `${baseUrl}/${finalSlug}` : baseUrl;\r\n  }, [formData.serviceId, services, serviceSlug]);\r\n\r\n  const nextStep = useCallback(() => {\r\n    if (currentStep < 3) {\r\n      const nextStepNumber = currentStep + 1;\r\n      const nextUrl = getStepUrl(nextStepNumber);\r\n      // Always navigate to next step\r\n      router.push(nextUrl);\r\n    }\r\n  }, [currentStep, router, getStepUrl]);\r\n\r\n  const previousStep = useCallback(() => {\r\n    if (currentStep > 1) {\r\n      const prevUrl = getStepUrl(currentStep - 1);\r\n      router.push(prevUrl);\r\n    }\r\n  }, [currentStep, router, getStepUrl]);\r\n\r\n  const goToStep = useCallback((step: number) => {\r\n    if (step >= 1 && step <= 3) {\r\n      const url = getStepUrl(step);\r\n      router.push(url);\r\n    }\r\n  }, [router, getStepUrl]);\r\n\r\n  const goToStepByUrl = useCallback((url: string) => {\r\n    const step = getStepFromPath(url);\r\n    if (step >= 1 && step <= 3) {\r\n      router.push(url);\r\n    }\r\n  }, [router]);\r\n\r\n  // Set services for slug generation\r\n  const setServicesForSlug = useCallback((servicesList: Service[]) => {\r\n    setServices(servicesList);\r\n  }, []);\r\n\r\n  // Validation for each step\r\n  const validateStep1 = useCallback((): { valid: boolean; errors: string[] } => {\r\n    const errors: string[] = [];\r\n\r\n    if (!formData.serviceId) {\r\n      errors.push('Please select a service');\r\n    }\r\n    if (!formData.serviceDate) {\r\n      errors.push('Please select a date');\r\n    }\r\n    if (!formData.serviceTime) {\r\n      errors.push('Please select a time');\r\n    }\r\n    if (formData.serviceTime && (!formData.serviceDuration || formData.serviceDuration < 3.5 || formData.serviceDuration > 10)) {\r\n      errors.push('Service duration must be between 3.5 and 10 hours');\r\n    }\r\n    // Only require cleaning equipment for Standard and Airbnb services\r\n    // Note: We can't check service name here without services data, so we'll check in the component\r\n    // For now, we'll make it optional and validate in the component if needed\r\n\r\n    return { valid: errors.length === 0, errors };\r\n  }, [formData]);\r\n\r\n  const validateStep2 = useCallback((): { valid: boolean; errors: string[] } => {\r\n    const errors: string[] = [];\r\n\r\n    if (!formData.serviceAddress.trim()) {\r\n      errors.push('Please enter service address');\r\n    }\r\n    if (!formData.serviceSuburb.trim()) {\r\n      errors.push('Please enter suburb');\r\n    }\r\n    if (!formData.serviceCity.trim()) {\r\n      errors.push('Please enter city');\r\n    }\r\n\r\n    // Validate team selection if teamNumber is set\r\n    if (formData.teamNumber !== null && formData.teamNumber !== undefined) {\r\n      if (formData.teamNumber < 1 || formData.teamNumber > 3) {\r\n        errors.push('Team number must be 1, 2, or 3');\r\n      }\r\n    }\r\n\r\n    // Validate cleaner selection count (only for non-team bookings)\r\n    // Team bookings use teamNumber instead of preferredCleanerIds\r\n    if (!formData.teamNumber && formData.numberOfCleaners > 1) {\r\n      const selectedCleaners = formData.preferredCleanerIds || [];\r\n      if (selectedCleaners.length !== formData.numberOfCleaners) {\r\n        errors.push(`Please select exactly ${formData.numberOfCleaners} cleaners`);\r\n      }\r\n    }\r\n    // For single cleaner (numberOfCleaners === 1), no validation needed - user can select 0 or 1\r\n\r\n    return { valid: errors.length === 0, errors };\r\n  }, [formData]);\r\n\r\n  const validateStep3 = useCallback((): { valid: boolean; errors: string[] } => {\r\n    const errors: string[] = [];\r\n\r\n    if (!formData.customerFirstName.trim()) {\r\n      errors.push('Please enter your first name');\r\n    }\r\n    if (!formData.customerLastName.trim()) {\r\n      errors.push('Please enter your last name');\r\n    }\r\n    if (!formData.customerEmail.trim()) {\r\n      errors.push('Please enter your email');\r\n    } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(formData.customerEmail)) {\r\n      errors.push('Please enter a valid email address');\r\n    }\r\n    if (!formData.customerPhone.trim()) {\r\n      errors.push('Please enter your phone number');\r\n    }\r\n\r\n    return { valid: errors.length === 0, errors };\r\n  }, [formData]);\r\n\r\n  const validateCurrentStep = useCallback((): { valid: boolean; errors: string[] } => {\r\n    switch (currentStep) {\r\n      case 1:\r\n        return validateStep1();\r\n      case 2:\r\n        return validateStep2();\r\n      case 3:\r\n        return validateStep3();\r\n      default:\r\n        return { valid: false, errors: ['Invalid step'] };\r\n    }\r\n  }, [currentStep, validateStep1, validateStep2, validateStep3]);\r\n\r\n  // Check if a step is completed (for navigation validation)\r\n  const isStepCompleted = useCallback((step: number): boolean => {\r\n    switch (step) {\r\n      case 1:\r\n        return validateStep1().valid;\r\n      case 2:\r\n        return validateStep1().valid && validateStep2().valid;\r\n      case 3:\r\n        return validateStep1().valid && validateStep2().valid && validateStep3().valid;\r\n      default:\r\n        return false;\r\n    }\r\n  }, [validateStep1, validateStep2, validateStep3]);\r\n\r\n  // Get discount amount from localStorage\r\n  const getDiscountAmount = useCallback((): number => {\r\n    try {\r\n      const saved = localStorage.getItem(DISCOUNT_AMOUNT_KEY);\r\n      return saved ? parseFloat(saved) : 0;\r\n    } catch (error) {\r\n      console.error('Error reading discount amount:', error);\r\n      return 0;\r\n    }\r\n  }, []);\r\n\r\n  // Set discount amount in localStorage\r\n  const setDiscountAmount = useCallback((amount: number) => {\r\n    try {\r\n      localStorage.setItem(DISCOUNT_AMOUNT_KEY, amount.toString());\r\n    } catch (error) {\r\n      console.error('Error saving discount amount:', error);\r\n    }\r\n  }, []);\r\n\r\n  // Clear discount amount\r\n  const clearDiscountAmount = useCallback(() => {\r\n    try {\r\n      localStorage.removeItem(DISCOUNT_AMOUNT_KEY);\r\n    } catch (error) {\r\n      console.error('Error clearing discount amount:', error);\r\n    }\r\n  }, []);\r\n\r\n  return {\r\n    currentStep,\r\n    serviceSlug,\r\n    formData,\r\n    updateFormData,\r\n    resetForm,\r\n    nextStep,\r\n    previousStep,\r\n    goToStep,\r\n    goToStepByUrl,\r\n    getStepUrl,\r\n    setServicesForSlug,\r\n    isStepCompleted,\r\n    getDiscountAmount,\r\n    setDiscountAmount,\r\n    clearDiscountAmount,\r\n    validateStep1,\r\n    validateStep2,\r\n    validateStep3,\r\n    validateCurrentStep,\r\n  };\r\n}\r\n\r\n","import { Cleaner, CleanerWithAvailability } from '@/types/booking';\r\n\r\nexport type SortCriteria = 'best-match' | 'highest-rated' | 'most-reliable' | 'most-experienced';\r\n\r\n/**\r\n * Calculate reliability score from booking metrics\r\n * Formula:\r\n * - Completion Rate (40%): (completed_bookings / total_bookings) * 40\r\n * - On-Time Rate (30%): (on_time_bookings / total_bookings) * 30\r\n * - Rating Factor (20%): (rating / 5.0) * 20\r\n * - Booking Volume (10%): min(total_bookings / 50, 1) * 10\r\n */\r\nexport function calculateReliabilityScore(cleaner: Cleaner): number {\r\n  const totalBookings = cleaner.total_bookings || 0;\r\n  const completedBookings = cleaner.completed_bookings || 0;\r\n  const onTimeBookings = cleaner.on_time_bookings || 0;\r\n  const rating = cleaner.rating || 0;\r\n\r\n  // If no bookings, return default score of 50\r\n  if (totalBookings === 0) {\r\n    return 50.0;\r\n  }\r\n\r\n  // Calculate completion rate score (40% weight)\r\n  const completionRateScore = (completedBookings / totalBookings) * 40.0;\r\n\r\n  // Calculate on-time rate score (30% weight)\r\n  const onTimeRateScore = (onTimeBookings / totalBookings) * 30.0;\r\n\r\n  // Calculate rating score (20% weight)\r\n  const ratingScore = (rating / 5.0) * 20.0;\r\n\r\n  // Calculate volume score (10% weight) - normalized to max 50 bookings\r\n  const volumeScore = Math.min(totalBookings / 50.0, 1.0) * 10.0;\r\n\r\n  // Calculate final score\r\n  let finalScore = completionRateScore + onTimeRateScore + ratingScore + volumeScore;\r\n\r\n  // Ensure score is between 0 and 100\r\n  finalScore = Math.max(0.0, Math.min(100.0, finalScore));\r\n\r\n  return Math.round(finalScore * 100) / 100; // Round to 2 decimal places\r\n}\r\n\r\n/**\r\n * Format reliability score for display\r\n */\r\nexport function formatReliabilityScore(score: number | null | undefined): string {\r\n  if (score === null || score === undefined) {\r\n    return 'N/A';\r\n  }\r\n  return `${score.toFixed(0)}%`;\r\n}\r\n\r\n/**\r\n * Sort cleaners by selected criteria\r\n */\r\nexport function sortCleanersByCriteria(\r\n  cleaners: CleanerWithAvailability[],\r\n  criteria: SortCriteria\r\n): CleanerWithAvailability[] {\r\n  const sorted = [...cleaners];\r\n\r\n  switch (criteria) {\r\n    case 'best-match':\r\n      // Sort by: reliability_score (60%) + rating (40%)\r\n      sorted.sort((a, b) => {\r\n        const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n        const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n        return scoreB - scoreA;\r\n      });\r\n      break;\r\n\r\n    case 'highest-rated':\r\n      sorted.sort((a, b) => (b.rating || 0) - (a.rating || 0));\r\n      break;\r\n\r\n    case 'most-reliable':\r\n      sorted.sort((a, b) => (b.reliability_score || 0) - (a.reliability_score || 0));\r\n      break;\r\n\r\n    case 'most-experienced':\r\n      sorted.sort((a, b) => (b.years_experience || 0) - (a.years_experience || 0));\r\n      break;\r\n\r\n    default:\r\n      // Default to best-match\r\n      sorted.sort((a, b) => {\r\n        const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n        const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n        return scoreB - scoreA;\r\n      });\r\n  }\r\n\r\n  return sorted;\r\n}\r\n\r\n/**\r\n * Calculate completion rate for a cleaner\r\n */\r\nexport function calculateCompletionRate(cleaner: Cleaner): number {\r\n  const total = cleaner.total_bookings || 0;\r\n  const completed = cleaner.completed_bookings || 0;\r\n  if (total === 0) return 0;\r\n  return Math.round((completed / total) * 100);\r\n}\r\n\r\n/**\r\n * Calculate on-time rate for a cleaner\r\n */\r\nexport function calculateOnTimeRate(cleaner: Cleaner): number {\r\n  const total = cleaner.total_bookings || 0;\r\n  const onTime = cleaner.on_time_bookings || 0;\r\n  if (total === 0) return 0;\r\n  return Math.round((onTime / total) * 100);\r\n}\r\n\r\n","/**\r\n * Service validation utilities for recurring bookings\r\n * \r\n * Only Standard Cleaning and Airbnb Cleaning support recurring bookings.\r\n * All other services (Deep Cleaning, Move In/Out, Carpet Cleaning) are One-Time only.\r\n */\r\n\r\n/**\r\n * Check if a service supports recurring bookings\r\n * @param serviceName - The name of the service (case-insensitive)\r\n * @returns true if the service supports recurring bookings, false otherwise\r\n */\r\nexport function supportsRecurringBookings(serviceName: string): boolean {\r\n  if (!serviceName) return false;\r\n  \r\n  const normalizedName = serviceName.toLowerCase().trim();\r\n  \r\n  // Standard Cleaning supports recurring\r\n  if (normalizedName.includes('standard')) {\r\n    return true;\r\n  }\r\n  \r\n  // Airbnb Cleaning supports recurring\r\n  if (normalizedName.includes('airbnb')) {\r\n    return true;\r\n  }\r\n  \r\n  // All other services are One-Time only\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get available frequencies for a service\r\n * @param serviceName - The name of the service (case-insensitive)\r\n * @returns Array of available frequency options\r\n */\r\nexport function getAvailableFrequencies(\r\n  serviceName: string\r\n): ('one-time' | 'weekly' | 'bi-weekly' | 'monthly')[] {\r\n  if (supportsRecurringBookings(serviceName)) {\r\n    return ['one-time', 'weekly', 'bi-weekly', 'monthly'];\r\n  }\r\n  \r\n  // Non-supported services only allow One-Time\r\n  return ['one-time'];\r\n}\r\n\r\n/**\r\n * Check if a frequency is valid for a service\r\n * @param serviceName - The name of the service\r\n * @param frequency - The frequency to check\r\n * @returns true if the frequency is valid for the service\r\n */\r\nexport function isValidFrequencyForService(\r\n  serviceName: string,\r\n  frequency: 'one-time' | 'weekly' | 'bi-weekly' | 'monthly'\r\n): boolean {\r\n  const availableFrequencies = getAvailableFrequencies(serviceName);\r\n  return availableFrequencies.includes(frequency);\r\n}\r\n\r\n/**\r\n * Check if a service requires team-based booking\r\n * \r\n * Deep Cleaning and Move In/Out services require team booking (3 teams available per day).\r\n * Each team can be booked once per day for the entire day.\r\n * \r\n * @param serviceName - The name of the service (case-insensitive)\r\n * @returns true if the service requires team booking, false otherwise\r\n */\r\nexport function requiresTeamBooking(serviceName: string): boolean {\r\n  if (!serviceName) return false;\r\n  \r\n  const normalizedName = serviceName.toLowerCase().trim();\r\n  \r\n  // Deep Cleaning requires team booking\r\n  if (normalizedName.includes('deep')) {\r\n    return true;\r\n  }\r\n  \r\n  // Move In/Out requires team booking\r\n  // Check for \"move\" and (\"in/out\" or \"in out\" or \"inout\")\r\n  if (normalizedName.includes('move')) {\r\n    if (normalizedName.includes('in/out') || \r\n        normalizedName.includes('in out') || \r\n        normalizedName.includes('inout')) {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  // All other services use individual cleaners\r\n  return false;\r\n}\r\n\r\n","'use client';\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { PricingRule, Cleaner, CleanerWithAvailability } from '@/types/booking';\r\nimport { calculateReliabilityScore, calculateCompletionRate, calculateOnTimeRate } from '@/lib/utils/cleaner-utils';\r\nimport { requiresTeamBooking } from '@/lib/utils/service-validation';\r\n\r\n/**\r\n * Client-side action to fetch pricing rules\r\n * This can be called from client components and cached with React Query\r\n */\r\nexport async function getPricingRulesClient(): Promise<PricingRule[]> {\r\n  try {\r\n    const supabase = createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('pricing_rules')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching pricing rules:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as PricingRule[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching pricing rules:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Client-side action to fetch available cleaners\r\n * This can be called from client components\r\n */\r\nexport async function getAvailableCleanersClient(serviceSuburb?: string): Promise<{\r\n  success: boolean;\r\n  cleaners?: Cleaner[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = createClient();\r\n\r\n    // Build query - only filter by is_active\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = data || [];\r\n\r\n    // Filter by is_available if the column exists (client-side filter as fallback)\r\n    cleaners = cleaners.filter((cleaner) => {\r\n      // If is_available column doesn't exist or is null/undefined, include the cleaner\r\n      // Otherwise, only include if is_available is true\r\n      return cleaner.is_available !== false;\r\n    });\r\n\r\n    // Filter by area if suburb is provided\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        // If cleaner has no areas specified, include them (they serve all areas)\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true;\r\n        }\r\n        // Check if any area matches the suburb (case-insensitive partial match)\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    return { success: true, cleaners: cleaners as Cleaner[] };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a cleaner has a booking conflict for a specific date and time slot (client-side)\r\n */\r\nexport async function checkCleanerBookingConflictClient(\r\n  cleanerId: string,\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = createClient();\r\n\r\n    // Query bookings for this cleaner on the specified date\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Cleaners should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration')\r\n      .eq('preferred_cleaner_id', cleanerId)\r\n      .eq('service_date', serviceDate)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (error) {\r\n      console.error('Error checking booking conflicts:', error);\r\n      return false; // Assume no conflict on error\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      return false; // No bookings, no conflict\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n\r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number'\r\n          ? booking.service_duration\r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        return true; // Conflict found\r\n      }\r\n    }\r\n\r\n    return false; // No conflicts\r\n  } catch (error) {\r\n    console.error('Unexpected error checking booking conflict:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners with enhanced filtering criteria (client-side)\r\n * Filters by: Location, Availability, Booking conflicts\r\n * Sorts by: Reliability Score, Rating\r\n */\r\nexport async function getAvailableCleanersWithCriteriaClient(params: {\r\n  serviceSuburb?: string;\r\n  serviceDate?: string;\r\n  serviceTime?: string;\r\n  serviceDuration?: number;\r\n  minRating?: number;\r\n  minReliabilityScore?: number;\r\n}): Promise<{\r\n  success: boolean;\r\n  cleaners?: CleanerWithAvailability[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = createClient();\r\n    const {\r\n      serviceSuburb,\r\n      serviceDate,\r\n      serviceTime,\r\n      serviceDuration = 3,\r\n      minRating = 0,\r\n      minReliabilityScore = 0,\r\n    } = params;\r\n\r\n    // Build base query\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('reliability_score', { ascending: false, nullsFirst: false })\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = (data || []) as Cleaner[];\r\n\r\n    // Filter by is_available\r\n    cleaners = cleaners.filter((cleaner) => cleaner.is_available !== false);\r\n\r\n    // Filter by location (suburb)\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true; // Serve all areas\r\n        }\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Filter by day of week availability if date is provided\r\n    if (serviceDate) {\r\n      const date = new Date(serviceDate);\r\n      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        const dayMap: Record<number, keyof Cleaner> = {\r\n          0: 'available_sunday',\r\n          1: 'available_monday',\r\n          2: 'available_tuesday',\r\n          3: 'available_wednesday',\r\n          4: 'available_thursday',\r\n          5: 'available_friday',\r\n          6: 'available_saturday',\r\n        };\r\n        const dayField = dayMap[dayOfWeek];\r\n        return cleaner[dayField] !== false;\r\n      });\r\n    }\r\n\r\n    // Filter by minimum rating\r\n    if (minRating > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.rating || 0) >= minRating);\r\n    }\r\n\r\n    // Filter by minimum reliability score\r\n    if (minReliabilityScore > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.reliability_score || 0) >= minReliabilityScore);\r\n    }\r\n\r\n    // Enrich cleaners with availability and booking conflict information\r\n    const enrichedCleaners: CleanerWithAvailability[] = await Promise.all(\r\n      cleaners.map(async (cleaner) => {\r\n        let isAvailableForSlot = true;\r\n        let bookingConflict = false;\r\n\r\n        // Check booking conflict if date and time are provided\r\n        if (serviceDate && serviceTime && serviceDuration) {\r\n          bookingConflict = await checkCleanerBookingConflictClient(\r\n            cleaner.id,\r\n            serviceDate,\r\n            serviceTime,\r\n            serviceDuration\r\n          );\r\n          isAvailableForSlot = !bookingConflict;\r\n        }\r\n\r\n        // Calculate reliability score if not present\r\n        const reliabilityScore = cleaner.reliability_score ?? calculateReliabilityScore(cleaner);\r\n\r\n        return {\r\n          ...cleaner,\r\n          reliability_score: reliabilityScore,\r\n          isAvailableForSlot,\r\n          bookingConflict,\r\n          completionRate: calculateCompletionRate(cleaner),\r\n          onTimeRate: calculateOnTimeRate(cleaner),\r\n        };\r\n      })\r\n    );\r\n\r\n    // Sort by reliability score and rating\r\n    enrichedCleaners.sort((a, b) => {\r\n      const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n      const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n\r\n    return { success: true, cleaners: enrichedCleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners with criteria:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check team availability for a specific date for team-based services (client-side)\r\n * Returns which teams (1, 2, or 3) are available and which are booked\r\n */\r\nexport async function checkTeamAvailabilityForDateClient(\r\n  serviceDate: string,\r\n  serviceType: string\r\n): Promise<{\r\n  availableTeams: number[];\r\n  bookedTeams: number[];\r\n  allTeamsBooked: boolean;\r\n}> {\r\n  try {\r\n    const supabase = createClient();\r\n\r\n    // Only check for team-based services (Deep Cleaning and Move In/Out)\r\n    if (!requiresTeamBooking(serviceType)) {\r\n      return {\r\n        availableTeams: [],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Query bookings for the specified date and service type\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Teams should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('team_number')\r\n      .eq('service_date', serviceDate)\r\n      .eq('service_type', serviceType)\r\n      .not('team_number', 'is', null)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking team bookings:', bookingsError);\r\n      // If we can't check bookings, assume all teams available (optimistic approach)\r\n      return {\r\n        availableTeams: [1, 2, 3],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Extract booked team numbers\r\n    const bookedTeams = (bookings || [])\r\n      .map((booking) => booking.team_number)\r\n      .filter((teamNumber): teamNumber is number => teamNumber !== null && teamNumber >= 1 && teamNumber <= 3);\r\n\r\n    // Get unique booked teams (in case of duplicates)\r\n    const bookedTeamsSet = new Set(bookedTeams);\r\n\r\n    // Calculate available teams (1, 2, 3 minus booked teams)\r\n    const allTeams = [1, 2, 3];\r\n    const availableTeams = allTeams.filter((team) => !bookedTeamsSet.has(team));\r\n\r\n    return {\r\n      availableTeams,\r\n      bookedTeams: Array.from(bookedTeamsSet),\r\n      allTeamsBooked: availableTeams.length === 0,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking team availability:', error);\r\n    // On error, assume all teams available for safety (let database constraint catch duplicates)\r\n    return {\r\n      availableTeams: [1, 2, 3],\r\n      bookedTeams: [],\r\n      allTeamsBooked: false,\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}