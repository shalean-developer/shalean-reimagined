{"version":3,"sources":["../../../../app/cleaner/actions.ts","../../../../src/lib/utils/cleaner-earnings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { createAdminClient } from '@/lib/supabase/server-admin';\r\nimport { Booking } from '@/types/booking';\r\nimport { Cleaner } from '@/types/booking';\r\nimport {\r\n  calculateCleanerTenure,\r\n  calculateTotalHours,\r\n  getEarningsPercentage,\r\n  calculateTotalEarningsFromBooking,\r\n  calculateCleanerEarnings,\r\n  calculateTipPerCleaner,\r\n} from '@/lib/utils/cleaner-earnings';\r\n\r\n/**\r\n * Get cleaner by phone number\r\n */\r\nexport async function getCleanerByPhone(phone: string): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    \r\n    // Normalize phone number (remove spaces, dashes, etc.)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    \r\n    const { data, error } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .or(`phone.eq.${normalizedPhone},phone.eq.+${normalizedPhone}`)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaner by phone:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!data) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: data as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerByPhone:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Authenticate cleaner with phone and password\r\n * Uses Supabase Auth - expects email format: {phone}@cleaners.shalean.local\r\n * Admin should create auth accounts with this email format when creating cleaner accounts\r\n */\r\nexport async function authenticateCleaner(\r\n  phone: string,\r\n  password: string\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // First, find the cleaner by phone to verify they exist\r\n    const cleanerResult = await getCleanerByPhone(phone);\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    const cleaner = cleanerResult.cleaner;\r\n\r\n    // Use phone-based email format for login\r\n    // Format: {phone}@cleaners.shalean.local\r\n    // Normalize phone (remove spaces, keep + if present)\r\n    const normalizedPhone = phone.replace(/\\s+/g, '').trim();\r\n    const authEmail = `${normalizedPhone}@cleaners.shalean.local`;\r\n\r\n    // Authenticate with Supabase Auth using client-side (this should be called from client)\r\n    // Note: This function should ideally be called from a client component\r\n    // For server-side, we'll return the cleaner info and let client handle auth\r\n    const supabase = await createClient();\r\n    \r\n    // Try to authenticate\r\n    const { data, error } = await supabase.auth.signInWithPassword({\r\n      email: authEmail,\r\n      password,\r\n    });\r\n\r\n    if (error) {\r\n      console.error('Authentication error:', error);\r\n      return { success: false, error: 'Invalid phone number or password' };\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Authentication failed' };\r\n    }\r\n\r\n    // Update cleaner's auth_user_id if not set\r\n    if (!cleaner.auth_user_id) {\r\n      try {\r\n        const adminSupabase = createAdminClient();\r\n        await adminSupabase\r\n          .from('cleaners')\r\n          .update({ auth_user_id: data.user.id })\r\n          .eq('id', cleaner.id);\r\n      } catch (updateError) {\r\n        // Log but don't fail - auth_user_id update is optional\r\n        console.warn('Could not update auth_user_id:', updateError);\r\n      }\r\n    }\r\n\r\n    return { success: true, cleaner };\r\n  } catch (error) {\r\n    console.error('Error in authenticateCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Authentication failed',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get current authenticated cleaner\r\n */\r\nexport async function getCurrentCleaner(): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return { success: false, error: 'Not authenticated' };\r\n    }\r\n\r\n    // Try to find cleaner by auth_user_id first\r\n    let cleanerQuery = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('auth_user_id', user.id)\r\n      .eq('is_active', true)\r\n      .maybeSingle();\r\n\r\n    let { data: cleaner, error: cleanerError } = await cleanerQuery;\r\n\r\n    // If not found by auth_user_id, try to match by phone from email\r\n    if (!cleaner && !cleanerError && user.email) {\r\n      // Extract phone from email format: {phone}@cleaners.shalean.local\r\n      const phoneMatch = user.email.match(/^(.+)@cleaners\\.shalean\\.local$/);\r\n      if (phoneMatch) {\r\n        const phone = phoneMatch[1];\r\n        const phoneResult = await getCleanerByPhone(phone);\r\n        if (phoneResult.success && phoneResult.cleaner) {\r\n          cleaner = phoneResult.cleaner;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner profile not found' };\r\n    }\r\n\r\n    return { success: true, cleaner: cleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in getCurrentCleaner:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to get cleaner',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get bookings assigned to the authenticated cleaner\r\n */\r\nexport async function getCleanerBookings(\r\n  filter?: 'all' | 'today' | 'upcoming' | 'past' | 'on_my_way' | 'started'\r\n): Promise<{\r\n  success: boolean;\r\n  bookings?: Booking[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n    \r\n    // Fetch bookings where cleaner is assigned via preferred_cleaner_id (single)\r\n    let singleQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter\r\n    let arrayQuery = supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Apply filters to both queries\r\n    if (filter && filter !== 'all') {\r\n      const today = new Date().toISOString().split('T')[0];\r\n      \r\n      switch (filter) {\r\n        case 'today':\r\n          singleQuery = singleQuery.eq('service_date', today);\r\n          arrayQuery = arrayQuery.eq('service_date', today);\r\n          break;\r\n        case 'upcoming':\r\n          singleQuery = singleQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          arrayQuery = arrayQuery.gte('service_date', today)\r\n                      .in('status', ['pending', 'confirmed', 'on_my_way', 'started']);\r\n          break;\r\n        case 'past':\r\n          singleQuery = singleQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          arrayQuery = arrayQuery.lt('service_date', today)\r\n                      .or('status.eq.completed,status.eq.cancelled');\r\n          break;\r\n        case 'on_my_way':\r\n          singleQuery = singleQuery.eq('status', 'on_my_way');\r\n          arrayQuery = arrayQuery.eq('status', 'on_my_way');\r\n          break;\r\n        case 'started':\r\n          singleQuery = singleQuery.eq('status', 'started');\r\n          arrayQuery = arrayQuery.eq('status', 'started');\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Execute both queries\r\n    const [singleResult, arrayResult] = await Promise.all([\r\n      singleQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true }),\r\n      arrayQuery.order('service_date', { ascending: true }).order('service_time', { ascending: true })\r\n    ]);\r\n\r\n    if (singleResult.error) {\r\n      console.error('Error fetching cleaner bookings (single):', singleResult.error);\r\n      return { success: false, error: singleResult.error.message };\r\n    }\r\n\r\n    if (arrayResult.error) {\r\n      console.error('Error fetching cleaner bookings (array):', arrayResult.error);\r\n      return { success: false, error: arrayResult.error.message };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerBookings] Fetched bookings:', {\r\n      cleanerId,\r\n      filter,\r\n      singleBookingsCount: singleResult.data?.length || 0,\r\n      arrayBookingsCount: arrayResult.data?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const filteredArrayBookings = (arrayResult.data || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine results and remove duplicates\r\n    const allBookings = [\r\n      ...(singleResult.data || []),\r\n      ...filteredArrayBookings\r\n    ];\r\n\r\n    // Remove duplicates by booking ID\r\n    const uniqueBookingsMap = new Map<string, Booking>();\r\n    allBookings.forEach((booking: any) => {\r\n      if (booking.id && !uniqueBookingsMap.has(booking.id)) {\r\n        uniqueBookingsMap.set(booking.id, booking as Booking);\r\n      }\r\n    });\r\n\r\n    const bookings = Array.from(uniqueBookingsMap.values());\r\n\r\n    // Sort by service_date and service_time\r\n    bookings.sort((a, b) => {\r\n      const dateCompare = a.service_date.localeCompare(b.service_date);\r\n      if (dateCompare !== 0) return dateCompare;\r\n      return a.service_time.localeCompare(b.service_time);\r\n    });\r\n\r\n    return { success: true, bookings };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch bookings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate cleaner earnings for a specific booking\r\n * This helper function is used to display earnings on booking details page\r\n */\r\nexport async function calculateBookingEarnings(bookingId: string): Promise<{\r\n  success: boolean;\r\n  earnings?: {\r\n    baseEarnings: number;\r\n    tipAmount: number;\r\n    totalEarnings: number;\r\n    earningsPercentage: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get the booking\r\n    const { data: booking, error: bookingError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (bookingError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Calculate tenure and total hours to determine percentage\r\n    // For single booking display, we need all paid completed bookings to calculate hours\r\n    // Use the same approach as getCleanerStats\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate base earnings\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const baseEarnings = calculateCleanerEarnings(\r\n      {\r\n        service_type: booking.service_type || '',\r\n        total_amount: Number(booking.total_amount) || 0,\r\n        service_fee: Number(booking.service_fee) || 0,\r\n        equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n        additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n        preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n        preferred_cleaner_id: booking.preferred_cleaner_id,\r\n      },\r\n      cleanerId,\r\n      earningsPercentage,\r\n      booking.preferred_cleaner_ids\r\n    );\r\n\r\n    // Calculate tip per cleaner\r\n    const tipAmount = calculateTipPerCleaner(\r\n      Number(booking.tip_amount) || 0,\r\n      booking.preferred_cleaner_ids,\r\n      booking.preferred_cleaner_id\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      earnings: {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n        earningsPercentage,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error calculating booking earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get a specific booking by ID (only if assigned to authenticated cleaner)\r\n */\r\nexport async function getCleanerBookingById(\r\n  bookingId: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Fetch the booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError) {\r\n      console.error('Error fetching booking:', fetchError);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    if (!booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Verify the cleaner is assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    // Check single cleaner assignment\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    // Check multiple cleaner assignment\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    if (!isAssignedSingle && !isAssignedMultiple) {\r\n      return { \r\n        success: false, \r\n        error: 'Unauthorized: You are not assigned to this booking' \r\n      };\r\n    }\r\n\r\n    return { success: true, booking: booking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerBookingById:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch booking',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update booking status (with authorization check for authenticated cleaner)\r\n */\r\nexport async function updateBookingStatus(\r\n  bookingId: string,\r\n  status: Booking['status']\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // First, verify the cleaner is assigned to this booking\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Validate status transition\r\n    const validTransitions: Record<string, string[]> = {\r\n      'pending': ['confirmed', 'cancelled'],\r\n      'confirmed': ['on_my_way', 'cancelled'],\r\n      'on_my_way': ['started', 'cancelled'],\r\n      'started': ['completed', 'cancelled'],\r\n      'completed': [],\r\n      'cancelled': [],\r\n    };\r\n\r\n    const currentStatus = booking.status;\r\n    const allowedStatuses = validTransitions[currentStatus] || [];\r\n    \r\n    if (!allowedStatuses.includes(status) && status !== currentStatus) {\r\n      return { \r\n        success: false, \r\n        error: `Invalid status transition: cannot change from ${currentStatus} to ${status}` \r\n      };\r\n    }\r\n\r\n    // Update booking status\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({ \r\n        status,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error updating booking status:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in updateBookingStatus:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update booking status',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Report lateness for a booking (with authorization check for authenticated cleaner)\r\n */\r\nexport async function reportLateness(\r\n  bookingId: string,\r\n  expectedArrivalTime: string, // ISO timestamp\r\n  reason: string\r\n): Promise<{\r\n  success: boolean;\r\n  booking?: Booking;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Verify authorization\r\n    const { data: booking, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .maybeSingle();\r\n\r\n    if (fetchError || !booking) {\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    // Check authorization: cleaner must be assigned to this booking\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const isAssignedSingle = booking.preferred_cleaner_id && \r\n      normalizeUuid(booking.preferred_cleaner_id) === normalizedCleanerId;\r\n\r\n    let isAssignedMultiple = false;\r\n    if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n      isAssignedMultiple = booking.preferred_cleaner_ids.some(\r\n        (id: string) => normalizeUuid(id) === normalizedCleanerId\r\n      );\r\n    }\r\n\r\n    const isAssigned = isAssignedSingle || isAssignedMultiple;\r\n\r\n    if (!isAssigned) {\r\n      return { success: false, error: 'Unauthorized: You are not assigned to this booking' };\r\n    }\r\n\r\n    // Update booking with lateness information\r\n    const { data: updatedBooking, error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        expected_arrival_time: expectedArrivalTime,\r\n        lateness_reason: reason,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', bookingId)\r\n      .select()\r\n      .single();\r\n\r\n    if (updateError) {\r\n      console.error('Error reporting lateness:', updateError);\r\n      return { success: false, error: updateError.message };\r\n    }\r\n\r\n    return { success: true, booking: updatedBooking as Booking };\r\n  } catch (error) {\r\n    console.error('Error in reportLateness:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to report lateness',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate earnings for multiple bookings at once\r\n * This is more efficient than calculating earnings one booking at a time\r\n */\r\nexport async function calculateBookingsEarnings(bookingIds: string[]): Promise<{\r\n  success: boolean;\r\n  earnings?: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }>;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    if (bookingIds.length === 0) {\r\n      return { success: true, earnings: {} };\r\n    }\r\n\r\n    // Get cleaner info for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (bookingsError || !bookings) {\r\n      return { success: false, error: 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Get all cleaner bookings to calculate hours\r\n    const { data: singleBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    const { data: allMultiBookings } = await supabase\r\n      .from('bookings')\r\n      .select('status, payment_status, service_duration, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    // Filter bookings assigned to this cleaner\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n\r\n    const arrayBookings = (allMultiBookings || []).filter((b: any) => {\r\n      if (!b.preferred_cleaner_ids || !Array.isArray(b.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      if (b.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      return b.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((b: any) => {\r\n      if (b.id) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n    arrayBookings.forEach((b: any) => {\r\n      if (b.id && !allBookingsMap.has(b.id)) {\r\n        allBookingsMap.set(b.id, b);\r\n      }\r\n    });\r\n\r\n    const cleanerBookings = Array.from(allBookingsMap.values());\r\n\r\n    // Calculate tenure and hours\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(cleanerBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings for each booking\r\n    const earningsRecord: Record<string, { baseEarnings: number; tipAmount: number; totalEarnings: number }> = {};\r\n\r\n    for (const booking of bookings) {\r\n      const baseEarnings = calculateCleanerEarnings(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage,\r\n        booking.preferred_cleaner_ids\r\n      );\r\n\r\n      const tipAmount = calculateTipPerCleaner(\r\n        Number(booking.tip_amount) || 0,\r\n        booking.preferred_cleaner_ids,\r\n        booking.preferred_cleaner_id\r\n      );\r\n\r\n      earningsRecord[booking.id] = {\r\n        baseEarnings,\r\n        tipAmount,\r\n        totalEarnings: baseEarnings + tipAmount,\r\n      };\r\n    }\r\n\r\n    return { success: true, earnings: earningsRecord };\r\n  } catch (error) {\r\n    console.error('Error calculating bookings earnings:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to calculate earnings',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get cleaner statistics for the authenticated cleaner\r\n */\r\nexport async function getCleanerStats(): Promise<{\r\n  success: boolean;\r\n  stats?: {\r\n    totalBookings: number;\r\n    completedBookings: number;\r\n    upcomingBookings: number;\r\n    todayBookings: number;\r\n    totalEarnings: number;\r\n    monthlyEarnings: number;\r\n    averageRating: number;\r\n    reliabilityScore: number;\r\n    completionRate: number;\r\n    onTimeRate: number;\r\n  };\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Get authenticated cleaner first\r\n    const cleanerResult = await getCurrentCleaner();\r\n    if (!cleanerResult.success || !cleanerResult.cleaner) {\r\n      return { success: false, error: 'Not authenticated or cleaner profile not found' };\r\n    }\r\n\r\n    const cleanerId = cleanerResult.cleaner.id;\r\n    const supabase = await createClient();\r\n\r\n    // Get cleaner info including created_at for tenure calculation\r\n    const { data: cleaner, error: cleanerError } = await supabase\r\n      .from('cleaners')\r\n      .select('rating, reliability_score, total_bookings, completed_bookings, on_time_bookings, created_at')\r\n      .eq('id', cleanerId)\r\n      .maybeSingle();\r\n\r\n    if (cleanerError || !cleaner) {\r\n      return { success: false, error: 'Cleaner not found' };\r\n    }\r\n\r\n    // Get all bookings assigned to this cleaner\r\n    // Fetch bookings with preferred_cleaner_id (single) - include all fields needed for earnings calculation\r\n    const { data: singleBookings, error: singleError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_id, preferred_cleaner_ids')\r\n      .eq('preferred_cleaner_id', cleanerId);\r\n\r\n    // Fetch bookings with preferred_cleaner_ids (array) - fetch all with arrays, then filter in JS\r\n    const { data: allMultiBookings, error: multiError } = await supabase\r\n      .from('bookings')\r\n      .select('id, status, service_date, total_amount, payment_status, service_type, service_fee, subtotal, tip_amount, service_duration, equipment_supply_price, additional_cleaners_price, preferred_cleaner_ids, preferred_cleaner_id')\r\n      .not('preferred_cleaner_ids', 'is', null);\r\n\r\n    if (singleError || multiError) {\r\n      console.error('Error fetching bookings for stats:', singleError || multiError);\r\n      return { success: false, error: (singleError || multiError)?.message || 'Failed to fetch bookings' };\r\n    }\r\n\r\n    // Debug logging\r\n    console.log('[getCleanerStats] Fetched bookings:', {\r\n      cleanerId,\r\n      singleBookingsCount: singleBookings?.length || 0,\r\n      allMultiBookingsCount: allMultiBookings?.length || 0,\r\n    });\r\n\r\n    // Filter bookings where preferred_cleaner_ids array contains this cleanerId\r\n    // Normalize UUIDs for comparison (handle case differences and string formats)\r\n    const normalizeUuid = (id: any): string => {\r\n      if (!id) return '';\r\n      return String(id).toLowerCase().trim();\r\n    };\r\n    const normalizedCleanerId = normalizeUuid(cleanerId);\r\n    \r\n    const arrayBookings = (allMultiBookings || []).filter((booking: any) => {\r\n      if (!booking.preferred_cleaner_ids || !Array.isArray(booking.preferred_cleaner_ids)) {\r\n        return false;\r\n      }\r\n      // Check if array is empty\r\n      if (booking.preferred_cleaner_ids.length === 0) {\r\n        return false;\r\n      }\r\n      // Check if any ID in the array matches the cleanerId (case-insensitive)\r\n      return booking.preferred_cleaner_ids.some((id: string) => normalizeUuid(id) === normalizedCleanerId);\r\n    });\r\n\r\n    // Combine and remove duplicates by ID\r\n    const allBookingsMap = new Map<string, any>();\r\n    (singleBookings || []).forEach((booking: any) => {\r\n      if (booking.id) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    arrayBookings.forEach((booking: any) => {\r\n      if (booking.id && !allBookingsMap.has(booking.id)) {\r\n        allBookingsMap.set(booking.id, booking);\r\n      }\r\n    });\r\n    \r\n    const allBookings = Array.from(allBookingsMap.values());\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n    const now = new Date();\r\n    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];\r\n    const completedBookings = allBookings.filter(b => b.status === 'completed');\r\n    const upcomingBookings = allBookings.filter(b => \r\n      ['pending', 'confirmed', 'on_my_way', 'started'].includes(b.status) &&\r\n      b.service_date >= today\r\n    );\r\n    const todayBookings = allBookings.filter(b => b.service_date === today);\r\n    const paidBookings = allBookings.filter(b => b.payment_status === 'paid');\r\n    const monthlyPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid' && \r\n      b.service_date >= firstDayOfMonth\r\n    );\r\n    const completedPaidBookings = allBookings.filter(b => \r\n      b.status === 'completed' && \r\n      b.payment_status === 'paid'\r\n    );\r\n\r\n    // Calculate cleaner tenure and total hours for eligibility determination\r\n    const tenureMonths = calculateCleanerTenure(cleaner.created_at);\r\n    const totalHours = calculateTotalHours(allBookings);\r\n    const earningsPercentage = getEarningsPercentage(tenureMonths, totalHours);\r\n\r\n    // Calculate earnings using the new system\r\n    // Only calculate earnings for paid bookings (earnings are only paid when customer has paid)\r\n    // Equipment fee and additional cleaners charges are excluded from cleaner earnings\r\n    const totalEarnings = completedPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const monthlyEarnings = monthlyPaidBookings.reduce((sum, booking) => {\r\n      const earnings = calculateTotalEarningsFromBooking(\r\n        {\r\n          service_type: booking.service_type || '',\r\n          total_amount: Number(booking.total_amount) || 0,\r\n          service_fee: Number(booking.service_fee) || 0,\r\n          equipment_supply_price: Number(booking.equipment_supply_price) || 0,\r\n          additional_cleaners_price: Number(booking.additional_cleaners_price) || 0,\r\n          tip_amount: Number(booking.tip_amount) || 0,\r\n          preferred_cleaner_ids: booking.preferred_cleaner_ids,\r\n          preferred_cleaner_id: booking.preferred_cleaner_id,\r\n        },\r\n        cleanerId,\r\n        earningsPercentage\r\n      );\r\n      return sum + earnings;\r\n    }, 0);\r\n\r\n    const completionRate = cleaner.total_bookings \r\n      ? (cleaner.completed_bookings || 0) / cleaner.total_bookings * 100 \r\n      : 0;\r\n    \r\n    const onTimeRate = cleaner.completed_bookings\r\n      ? (cleaner.on_time_bookings || 0) / cleaner.completed_bookings * 100\r\n      : 0;\r\n\r\n    return {\r\n      success: true,\r\n      stats: {\r\n        totalBookings: allBookings.length,\r\n        completedBookings: completedBookings.length,\r\n        upcomingBookings: upcomingBookings.length,\r\n        todayBookings: todayBookings.length,\r\n        totalEarnings,\r\n        monthlyEarnings,\r\n        averageRating: Number(cleaner.rating) || 0,\r\n        reliabilityScore: Number(cleaner.reliability_score) || 0,\r\n        completionRate,\r\n        onTimeRate,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('Error in getCleanerStats:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to fetch stats',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update cleaner availability\r\n */\r\nexport async function updateCleanerAvailability(\r\n  cleanerId: string,\r\n  updates: {\r\n    isAvailable?: boolean;\r\n    availableMonday?: boolean;\r\n    availableTuesday?: boolean;\r\n    availableWednesday?: boolean;\r\n    availableThursday?: boolean;\r\n    availableFriday?: boolean;\r\n    availableSaturday?: boolean;\r\n    availableSunday?: boolean;\r\n  }\r\n): Promise<{\r\n  success: boolean;\r\n  cleaner?: Cleaner;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const updateData: any = {\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    if (updates.isAvailable !== undefined) {\r\n      updateData.is_available = updates.isAvailable;\r\n    }\r\n    if (updates.availableMonday !== undefined) {\r\n      updateData.available_monday = updates.availableMonday;\r\n    }\r\n    if (updates.availableTuesday !== undefined) {\r\n      updateData.available_tuesday = updates.availableTuesday;\r\n    }\r\n    if (updates.availableWednesday !== undefined) {\r\n      updateData.available_wednesday = updates.availableWednesday;\r\n    }\r\n    if (updates.availableThursday !== undefined) {\r\n      updateData.available_thursday = updates.availableThursday;\r\n    }\r\n    if (updates.availableFriday !== undefined) {\r\n      updateData.available_friday = updates.availableFriday;\r\n    }\r\n    if (updates.availableSaturday !== undefined) {\r\n      updateData.available_saturday = updates.availableSaturday;\r\n    }\r\n    if (updates.availableSunday !== undefined) {\r\n      updateData.available_sunday = updates.availableSunday;\r\n    }\r\n\r\n    const { data: updatedCleaner, error } = await supabase\r\n      .from('cleaners')\r\n      .update(updateData)\r\n      .eq('id', cleanerId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error updating cleaner availability:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return { success: true, cleaner: updatedCleaner as Cleaner };\r\n  } catch (error) {\r\n    console.error('Error in updateCleanerAvailability:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to update availability',\r\n    };\r\n  }\r\n}\r\n","/**\r\n * Cleaner earnings calculation utilities\r\n * \r\n * Implements tiered earnings system:\r\n * - Standard/Airbnb: 70% if ≥3 months AND ≥400 hours, else 60%\r\n * - Deep Cleaning/Move In/Out/Carpet Cleaning: R250 per cleaner (fixed)\r\n * - Tips are added to earnings and divided among cleaners if multiple assigned\r\n */\r\n\r\nimport { Booking } from '@/types/booking';\r\n\r\n/**\r\n * Check if a service is team-based (Deep Cleaning, Move In/Out, Carpet Cleaning)\r\n * These services pay a fixed R250 per cleaner\r\n * \r\n * @param serviceType - The service type name (case-insensitive)\r\n * @returns true if the service is team-based and uses fixed earnings\r\n */\r\nexport function isTeamBasedService(serviceType: string): boolean {\r\n  if (!serviceType) return false;\r\n  \r\n  const normalized = serviceType.toLowerCase().trim();\r\n  \r\n  // Deep Cleaning\r\n  if (normalized.includes('deep')) {\r\n    return true;\r\n  }\r\n  \r\n  // Move In/Out\r\n  if (normalized.includes('move')) {\r\n    if (normalized.includes('in/out') || \r\n        normalized.includes('in out') || \r\n        normalized.includes('inout')) {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  // Carpet Cleaning\r\n  if (normalized.includes('carpet')) {\r\n    return true;\r\n  }\r\n  \r\n  return false;\r\n}\r\n\r\n/**\r\n * Calculate cleaner tenure in months from created_at date\r\n * \r\n * @param createdAt - The cleaner's created_at timestamp (ISO string or Date)\r\n * @returns Number of months (as a decimal, e.g., 3.5 months)\r\n */\r\nexport function calculateCleanerTenure(createdAt: string | Date): number {\r\n  if (!createdAt) return 0;\r\n  \r\n  const createdDate = typeof createdAt === 'string' ? new Date(createdAt) : createdAt;\r\n  const now = new Date();\r\n  \r\n  // Calculate difference in milliseconds\r\n  const diffMs = now.getTime() - createdDate.getTime();\r\n  \r\n  // Convert to months (approximate: 30 days per month)\r\n  const diffDays = diffMs / (1000 * 60 * 60 * 24);\r\n  const months = diffDays / 30;\r\n  \r\n  return Math.max(0, months);\r\n}\r\n\r\n/**\r\n * Calculate total hours worked from completed and paid bookings\r\n * \r\n * @param bookings - Array of bookings with status, payment_status, and service_duration\r\n * @returns Total hours worked (sum of service_duration from completed AND paid bookings)\r\n */\r\nexport function calculateTotalHours(bookings: Array<{\r\n  status: string;\r\n  payment_status: string;\r\n  service_duration: number;\r\n}>): number {\r\n  if (!bookings || bookings.length === 0) return 0;\r\n  \r\n  return bookings\r\n    .filter(b => b.status === 'completed' && b.payment_status === 'paid')\r\n    .reduce((total, booking) => {\r\n      const duration = Number(booking.service_duration) || 0;\r\n      return total + duration;\r\n    }, 0);\r\n}\r\n\r\n/**\r\n * Determine earnings percentage based on cleaner eligibility\r\n * \r\n * @param tenureMonths - Cleaner's tenure in months\r\n * @param totalHours - Total hours worked (completed AND paid bookings)\r\n * @returns 0.70 if eligible (≥3 months AND ≥400 hours), else 0.60\r\n */\r\nexport function getEarningsPercentage(tenureMonths: number, totalHours: number): number {\r\n  if (tenureMonths >= 3 && totalHours >= 400) {\r\n    return 0.70;\r\n  }\r\n  return 0.60;\r\n}\r\n\r\n/**\r\n * Calculate cleaner earnings for a single booking\r\n * \r\n * Calculation steps for non-team services:\r\n * 1. Calculate earnings for 1 default cleaner: (total_amount - service_fee - equipment_supply_price) × earningsPercentage\r\n * 2. Add additional_cleaners_price to the earnings pool\r\n * 3. Divide the total earnings pool by the number of cleaners (including the base cleaner)\r\n * \r\n * Equipment fee is excluded from earnings. Additional cleaners fee is added to the earnings pool\r\n * and then divided among all cleaners equally.\r\n * \r\n * @param booking - The booking object\r\n * @param cleanerId - The cleaner's ID (for verification if needed)\r\n * @param earningsPercentage - The percentage to use (0.60 or 0.70) for non-team services\r\n * @param preferredCleanerIds - Array of cleaner IDs assigned to this booking\r\n * @returns The cleaner's earnings for this booking (excluding tip, which is added separately)\r\n */\r\nexport function calculateCleanerEarnings(\r\n  booking: {\r\n    service_type: string;\r\n    total_amount: number;\r\n    service_fee: number;\r\n    equipment_supply_price?: number;\r\n    additional_cleaners_price?: number;\r\n    preferred_cleaner_ids?: string[] | null;\r\n    preferred_cleaner_id?: string | null;\r\n  },\r\n  cleanerId: string,\r\n  earningsPercentage: number,\r\n  preferredCleanerIds?: string[] | null\r\n): number {\r\n  // For team-based services: fixed R250 per cleaner\r\n  if (isTeamBasedService(booking.service_type)) {\r\n    return 250;\r\n  }\r\n  \r\n  // For other services: \r\n  // Step 1: Calculate earnings for 1 default cleaner (excluding only equipment and service fee)\r\n  // Step 2: Add additional_cleaners_price to the earnings pool\r\n  // Step 3: Divide the total by the number of cleaners (including the base cleaner)\r\n  // Equipment fee is excluded from earnings, but additional cleaners fee is added to the earnings pool\r\n  const equipmentPrice = Number(booking.equipment_supply_price) || 0;\r\n  const additionalCleanersPrice = Number(booking.additional_cleaners_price) || 0;\r\n  \r\n  // Step 1: Calculate amount for base cleaner (excluding only equipment and service fee)\r\n  const amountForBaseCleaner = (Number(booking.total_amount) || 0) - (Number(booking.service_fee) || 0) - equipmentPrice;\r\n  \r\n  // Calculate earnings for 1 cleaner\r\n  const baseEarningsForOneCleaner = amountForBaseCleaner * earningsPercentage;\r\n  \r\n  // Step 2: Add additional cleaners fee to the earnings pool\r\n  const totalEarningsPool = baseEarningsForOneCleaner + additionalCleanersPrice;\r\n  \r\n  // Determine number of cleaners assigned to this booking\r\n  // Use preferred_cleaner_ids if available, otherwise check preferred_cleaner_id\r\n  let numCleaners = 1;\r\n  if (preferredCleanerIds && Array.isArray(preferredCleanerIds) && preferredCleanerIds.length > 0) {\r\n    numCleaners = preferredCleanerIds.length;\r\n  } else if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids) && booking.preferred_cleaner_ids.length > 0) {\r\n    numCleaners = booking.preferred_cleaner_ids.length;\r\n  } else if (booking.preferred_cleaner_id) {\r\n    numCleaners = 1;\r\n  }\r\n  \r\n  // Step 3: Divide total earnings pool equally among all assigned cleaners\r\n  return totalEarningsPool / numCleaners;\r\n}\r\n\r\n/**\r\n * Calculate tip amount per cleaner (tips are divided equally among all cleaners)\r\n * \r\n * @param tipAmount - Total tip amount from booking\r\n * @param preferredCleanerIds - Array of cleaner IDs assigned to this booking\r\n * @param preferredCleanerId - Single cleaner ID (for backward compatibility)\r\n * @returns Tip amount for this cleaner\r\n */\r\nexport function calculateTipPerCleaner(\r\n  tipAmount: number,\r\n  preferredCleanerIds?: string[] | null,\r\n  preferredCleanerId?: string | null\r\n): number {\r\n  const tip = Number(tipAmount) || 0;\r\n  if (tip <= 0) return 0;\r\n  \r\n  // Determine number of cleaners\r\n  let numCleaners = 1;\r\n  if (preferredCleanerIds && Array.isArray(preferredCleanerIds) && preferredCleanerIds.length > 0) {\r\n    numCleaners = preferredCleanerIds.length;\r\n  } else if (preferredCleanerId) {\r\n    numCleaners = 1;\r\n  }\r\n  \r\n  // Divide tip equally among all cleaners\r\n  return tip / numCleaners;\r\n}\r\n\r\n/**\r\n * Calculate total earnings for a cleaner from a booking (base earnings + tip)\r\n * \r\n * @param booking - The booking object with all required fields\r\n * @param cleanerId - The cleaner's ID\r\n * @param earningsPercentage - The percentage to use (0.60 or 0.70)\r\n * @returns Total earnings (base + tip) for this cleaner from this booking\r\n */\r\nexport function calculateTotalEarningsFromBooking(\r\n  booking: {\r\n    service_type: string;\r\n    total_amount: number;\r\n    service_fee: number;\r\n    equipment_supply_price?: number;\r\n    additional_cleaners_price?: number;\r\n    tip_amount: number;\r\n    preferred_cleaner_ids?: string[] | null;\r\n    preferred_cleaner_id?: string | null;\r\n  },\r\n  cleanerId: string,\r\n  earningsPercentage: number\r\n): number {\r\n  const baseEarnings = calculateCleanerEarnings(\r\n    booking,\r\n    cleanerId,\r\n    earningsPercentage,\r\n    booking.preferred_cleaner_ids || null\r\n  );\r\n  \r\n  const tip = calculateTipPerCleaner(\r\n    booking.tip_amount || 0,\r\n    booking.preferred_cleaner_ids,\r\n    booking.preferred_cleaner_id\r\n  );\r\n  \r\n  return baseEarnings + tip;\r\n}\r\n"],"names":[],"mappings":"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"}