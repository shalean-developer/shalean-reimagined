{"version":3,"sources":["../../../../app/booking/book/actions.ts","../../../../src/lib/pricing/rules.ts","../../../../src/lib/utils/service-validation.ts","../../../../src/lib/pricing/calculator.ts","../../../../src/lib/utils/booking-number.ts","../../../../src/lib/paystack/client.ts","../../../../src/lib/utils/cleaner-utils.ts","../../../../src/lib/utils/recurring-dates.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { BookingFormData, BookingCreateInput, WorkingHour, TimeSlotAvailability, Cleaner, CleanerWithAvailability } from '@/types/booking';\r\nimport { calculatePrice } from '@/lib/pricing/calculator';\r\nimport { generateBookingNumber } from '@/lib/utils/booking-number';\r\nimport { initializePayment } from '@/lib/paystack/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { calculateReliabilityScore, calculateCompletionRate, calculateOnTimeRate } from '@/lib/utils/cleaner-utils';\r\nimport { calculateBookingDatesForMonth, calculateNextBookingDate, formatDateForDB } from '@/lib/utils/recurring-dates';\r\nimport { isValidFrequencyForService, requiresTeamBooking } from '@/lib/utils/service-validation';\r\n\r\n/**\r\n * Get available working hours (30-minute interval start times)\r\n */\r\nexport async function getWorkingHours(): Promise<WorkingHour[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('working_hours')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as WorkingHour[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get working hours from home_detail_options (backward compatibility)\r\n */\r\nexport async function getWorkingHoursFromOptions(): Promise<Array<{ value: string; label: string }>> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('home_detail_options')\r\n      .select('value, label')\r\n      .eq('option_type', 'working_hours')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching working hours from options:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []).map((item) => ({\r\n      value: item.value,\r\n      label: item.label,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching working hours from options:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check cleaner availability for a specific date and time slot\r\n * Returns availability status and count of available cleaners\r\n */\r\nexport async function checkCleanerAvailabilityForSlot(\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<TimeSlotAvailability> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // First, check if any active cleaners exist in the system\r\n    const { data: activeCleaners, error: cleanersError } = await supabase\r\n      .from('cleaners')\r\n      .select('id')\r\n      .eq('is_active', true);\r\n\r\n    if (cleanersError) {\r\n      console.error('Error checking active cleaners:', cleanersError);\r\n      // If we can't check cleaners, assume unavailable for safety\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    // If no active cleaners exist, no slots are available\r\n    if (!activeCleaners || activeCleaners.length === 0) {\r\n      return { available: false, availableCleanersCount: 0 };\r\n    }\r\n\r\n    const totalCleaners = activeCleaners.length;\r\n\r\n    // Query bookings for the specified date that might overlap\r\n    // We need to check for bookings where:\r\n    // (booking_start_time < new_end_time) AND (booking_end_time > new_start_time)\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid, cancelled/completed)\r\n    // Cleaners should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration, preferred_cleaner_id, preferred_cleaner_ids, number_of_cleaners')\r\n      .eq('service_date', serviceDate)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking bookings:', bookingsError);\r\n      // If we can't check bookings, assume available (optimistic approach)\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      // No bookings for this date, all cleaners are available\r\n      return { available: true, availableCleanersCount: totalCleaners };\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Track which cleaners are booked (by ID)\r\n    const bookedCleanerIds = new Set<string>();\r\n    \r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n      \r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number' \r\n          ? booking.service_duration \r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        // There's an overlap\r\n        // Check preferred_cleaner_ids first (new multi-cleaner support)\r\n        if (booking.preferred_cleaner_ids && Array.isArray(booking.preferred_cleaner_ids)) {\r\n          // Multiple cleaners are assigned\r\n          booking.preferred_cleaner_ids.forEach((cleanerId: string) => {\r\n            if (cleanerId) bookedCleanerIds.add(cleanerId);\r\n          });\r\n        } else if (booking.preferred_cleaner_id) {\r\n          // Single cleaner assigned (backward compatibility)\r\n          bookedCleanerIds.add(booking.preferred_cleaner_id);\r\n        } else {\r\n          // If no preferred cleaner, use number_of_cleaners to count generic cleaner slots\r\n          // This handles bookings without specific cleaner assignments\r\n          const numCleaners = booking.number_of_cleaners || 1;\r\n          // We don't add specific IDs here, but count them in bookingsWithoutPreferredCleaner\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate available cleaners\r\n    // Count bookings without preferred cleaners (generic assignments)\r\n    // These use number_of_cleaners to determine how many cleaner slots are taken\r\n    const bookingsWithoutPreferredCleaner = bookings.filter(\r\n      (b) => {\r\n        const hasPreferredCleaners = (b.preferred_cleaner_ids && Array.isArray(b.preferred_cleaner_ids) && b.preferred_cleaner_ids.length > 0) || b.preferred_cleaner_id;\r\n        if (hasPreferredCleaners) return false;\r\n        \r\n        // Check for time overlap\r\n        const [hours, mins] = b.service_time.split(':').slice(0, 2).map(Number);\r\n        const start = hours * 60 + mins;\r\n        const duration = Math.round((typeof b.service_duration === 'number' ? b.service_duration : parseFloat(b.service_duration || '0')) * 60);\r\n        const end = start + duration;\r\n        return newStartTimeMinutes < end && newEndTimeMinutes > start;\r\n      }\r\n    ).reduce((sum, b) => {\r\n      // Sum up the number_of_cleaners for bookings without preferred cleaners\r\n      return sum + (b.number_of_cleaners || 1);\r\n    }, 0);\r\n\r\n    const unavailableCleaners = bookedCleanerIds.size + bookingsWithoutPreferredCleaner;\r\n    const availableCleanersCount = Math.max(0, totalCleaners - unavailableCleaners);\r\n\r\n    return {\r\n      available: availableCleanersCount > 0,\r\n      availableCleanersCount,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking cleaner availability:', error);\r\n    // On error, assume unavailable for safety\r\n    return { available: false, availableCleanersCount: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Check team availability for a specific date for team-based services\r\n * Returns which teams (1, 2, or 3) are available and which are booked\r\n */\r\nexport async function checkTeamAvailabilityForDate(\r\n  serviceDate: string,\r\n  serviceType: string\r\n): Promise<{\r\n  availableTeams: number[];\r\n  bookedTeams: number[];\r\n  allTeamsBooked: boolean;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Only check for team-based services (Deep Cleaning and Move In/Out)\r\n    if (!requiresTeamBooking(serviceType)) {\r\n      return {\r\n        availableTeams: [],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Query bookings for the specified date and service type\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Teams should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error: bookingsError } = await supabase\r\n      .from('bookings')\r\n      .select('team_number')\r\n      .eq('service_date', serviceDate)\r\n      .eq('service_type', serviceType)\r\n      .not('team_number', 'is', null)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (bookingsError) {\r\n      console.error('Error checking team bookings:', bookingsError);\r\n      // If we can't check bookings, assume all teams available (optimistic approach)\r\n      return {\r\n        availableTeams: [1, 2, 3],\r\n        bookedTeams: [],\r\n        allTeamsBooked: false,\r\n      };\r\n    }\r\n\r\n    // Extract booked team numbers\r\n    const bookedTeams = (bookings || [])\r\n      .map((booking) => booking.team_number)\r\n      .filter((teamNumber): teamNumber is number => teamNumber !== null && teamNumber >= 1 && teamNumber <= 3);\r\n\r\n    // Get unique booked teams (in case of duplicates)\r\n    const bookedTeamsSet = new Set(bookedTeams);\r\n\r\n    // Calculate available teams (1, 2, 3 minus booked teams)\r\n    const allTeams = [1, 2, 3];\r\n    const availableTeams = allTeams.filter((team) => !bookedTeamsSet.has(team));\r\n\r\n    return {\r\n      availableTeams,\r\n      bookedTeams: Array.from(bookedTeamsSet),\r\n      allTeamsBooked: availableTeams.length === 0,\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error checking team availability:', error);\r\n    // On error, assume all teams available for safety (let database constraint catch duplicates)\r\n    return {\r\n      availableTeams: [1, 2, 3],\r\n      bookedTeams: [],\r\n      allTeamsBooked: false,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check availability for all time slots for a given date\r\n */\r\nexport async function checkAvailabilityForAllSlots(\r\n  serviceDate: string,\r\n  workingHours: WorkingHour[],\r\n  serviceDuration: number,\r\n  serviceType?: string\r\n): Promise<Record<string, TimeSlotAvailability>> {\r\n  const availability: Record<string, TimeSlotAvailability> = {};\r\n\r\n  // If service requires team booking, check team availability instead\r\n  if (serviceType && requiresTeamBooking(serviceType)) {\r\n    const teamAvailability = await checkTeamAvailabilityForDate(serviceDate, serviceType);\r\n    \r\n    // For team-based services, availability is day-based, not time-based\r\n    // If all teams are booked, all slots are unavailable\r\n    // Otherwise, slots are available (but we'll show team selection in UI)\r\n    const slotsAvailable = !teamAvailability.allTeamsBooked;\r\n    const availableTeamsCount = teamAvailability.availableTeams.length;\r\n    \r\n    // Set same availability for all time slots\r\n    workingHours.forEach((hour) => {\r\n      availability[hour.start_time] = {\r\n        available: slotsAvailable,\r\n        availableCleanersCount: availableTeamsCount,\r\n      };\r\n    });\r\n\r\n    return availability;\r\n  }\r\n\r\n  // For regular services, check individual cleaner availability per time slot\r\n  const promises = workingHours.map(async (hour) => {\r\n    const slotAvailability = await checkCleanerAvailabilityForSlot(\r\n      serviceDate,\r\n      hour.start_time,\r\n      serviceDuration\r\n    );\r\n    return { time: hour.start_time, availability: slotAvailability };\r\n  });\r\n\r\n  const results = await Promise.all(promises);\r\n  \r\n  results.forEach(({ time, availability: avail }) => {\r\n    availability[time] = avail;\r\n  });\r\n\r\n  return availability;\r\n}\r\n\r\n/**\r\n * Validate discount code\r\n */\r\nexport async function validateDiscountCode(code: string, subtotal: number): Promise<{\r\n  valid: boolean;\r\n  discountAmount: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    if (!code || !code.trim()) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code is required' };\r\n    }\r\n\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('discount_codes')\r\n      .select('*')\r\n      .eq('code', code.trim().toUpperCase())\r\n      .eq('is_active', true)\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      return { valid: false, discountAmount: 0, error: 'Invalid discount code' };\r\n    }\r\n\r\n    // Check validity dates\r\n    const now = new Date();\r\n    const validFrom = new Date(data.valid_from);\r\n    const validUntil = new Date(data.valid_until);\r\n\r\n    if (now < validFrom || now > validUntil) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has expired' };\r\n    }\r\n\r\n    // Check max uses\r\n    if (data.max_uses && data.used_count >= data.max_uses) {\r\n      return { valid: false, discountAmount: 0, error: 'Discount code has reached maximum uses' };\r\n    }\r\n\r\n    // Check min purchase amount\r\n    if (data.min_purchase_amount && subtotal < data.min_purchase_amount) {\r\n      return { \r\n        valid: false, \r\n        discountAmount: 0, \r\n        error: `Minimum purchase amount of R${data.min_purchase_amount} required` \r\n      };\r\n    }\r\n\r\n    // Calculate discount amount\r\n    let discountAmount = 0;\r\n    if (data.discount_type === 'percentage') {\r\n      discountAmount = (subtotal * data.discount_value) / 100;\r\n      if (data.max_discount_amount && discountAmount > data.max_discount_amount) {\r\n        discountAmount = data.max_discount_amount;\r\n      }\r\n    } else {\r\n      discountAmount = data.discount_value;\r\n    }\r\n\r\n    // Ensure discount doesn't exceed subtotal\r\n    discountAmount = Math.min(discountAmount, subtotal);\r\n\r\n    return { valid: true, discountAmount };\r\n  } catch (error) {\r\n    console.error('Error validating discount code:', error);\r\n    return { valid: false, discountAmount: 0, error: 'Error validating discount code' };\r\n  }\r\n}\r\n\r\n/**\r\n * Create booking draft (before payment)\r\n */\r\nexport async function createBookingDraft(formData: BookingFormData): Promise<{\r\n  success: boolean;\r\n  bookingId?: string;\r\n  bookingIds?: string[];\r\n  totalAmount?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Get current user if logged in\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n    const userId = user?.id || null;\r\n\r\n    // Get service name\r\n    const { data: service } = await supabase\r\n      .from('services')\r\n      .select('name')\r\n      .eq('id', formData.serviceId)\r\n      .single();\r\n\r\n    if (!service) {\r\n      return { success: false, error: 'Service not found' };\r\n    }\r\n\r\n    // Validate that the selected frequency is valid for this service\r\n    if (!isValidFrequencyForService(service.name, formData.cleaningFrequency)) {\r\n      return { \r\n        success: false, \r\n        error: `Recurring bookings are only available for Standard Cleaning and Airbnb Cleaning services. Selected service: ${service.name}` \r\n      };\r\n    }\r\n\r\n    // Check if service requires team booking\r\n    const isTeamBooking = requiresTeamBooking(service.name);\r\n\r\n    // Validate team booking requirements\r\n    if (isTeamBooking) {\r\n      if (!formData.teamNumber || (formData.teamNumber < 1 || formData.teamNumber > 3)) {\r\n        return {\r\n          success: false,\r\n          error: 'Please select a team (1, 2, or 3) for this service',\r\n        };\r\n      }\r\n\r\n      // Check team availability for each booking date\r\n      const startDate = new Date(formData.serviceDate);\r\n      const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n      \r\n      for (const bookingDate of bookingDates) {\r\n        const teamAvailability = await checkTeamAvailabilityForDate(\r\n          formatDateForDB(bookingDate),\r\n          service.name\r\n        );\r\n        \r\n        if (!teamAvailability.availableTeams.includes(formData.teamNumber!)) {\r\n          const dateStr = formatDateForDB(bookingDate);\r\n          return {\r\n            success: false,\r\n            error: `Team ${formData.teamNumber} is already booked for ${dateStr}. Please select a different team or date.`,\r\n          };\r\n        }\r\n      }\r\n    } else {\r\n      // For non-team bookings, ensure teamNumber is not set\r\n      if (formData.teamNumber !== null && formData.teamNumber !== undefined) {\r\n        return {\r\n          success: false,\r\n          error: 'Team selection is only available for Deep Cleaning and Move In/Out services',\r\n        };\r\n      }\r\n    }\r\n\r\n    // Calculate pricing\r\n    const priceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount: 0, // Will calculate discount in next step\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Apply discount code if provided\r\n    let discountAmount = 0;\r\n    if (formData.discountCode) {\r\n      const discountValidation = await validateDiscountCode(\r\n        formData.discountCode,\r\n        priceBreakdown.subtotal - priceBreakdown.frequencyDiscountAmount\r\n      );\r\n      if (discountValidation.valid) {\r\n        discountAmount = discountValidation.discountAmount;\r\n      }\r\n    }\r\n\r\n    // Recalculate with discount\r\n    const finalPriceBreakdown = await calculatePrice({\r\n      serviceId: formData.serviceId,\r\n      serviceName: service.name,\r\n      bedrooms: formData.bedrooms,\r\n      bathrooms: formData.bathrooms,\r\n      additionalServiceIds: formData.additionalServices,\r\n      cleaningFrequency: formData.cleaningFrequency,\r\n      discountAmount,\r\n      cleaningEquipment: formData.cleaningEquipment,\r\n      numberOfCleaners: formData.numberOfCleaners || 1,\r\n    });\r\n\r\n    // Determine if this is a recurring booking\r\n    // Note: Team-based services (Deep Cleaning and Move In/Out) don't support recurring bookings\r\n    // but we'll handle it gracefully if somehow a recurring frequency is selected\r\n    const isRecurring = formData.cleaningFrequency !== 'one-time';\r\n\r\n    // Calculate booking dates based on frequency\r\n    const startDate = new Date(formData.serviceDate);\r\n    const bookingDates = calculateBookingDatesForMonth(startDate, formData.cleaningFrequency);\r\n\r\n    // Calculate next booking date for recurring bookings\r\n    let nextBookingDate: Date | null = null;\r\n    if (isRecurring && bookingDates.length > 0) {\r\n      const lastDate = bookingDates[bookingDates.length - 1];\r\n      nextBookingDate = calculateNextBookingDate(lastDate, formData.cleaningFrequency);\r\n    }\r\n\r\n    // Create bookings for all dates\r\n    const bookingsToCreate: BookingCreateInput[] = [];\r\n\r\n    for (let i = 0; i < bookingDates.length; i++) {\r\n      const bookingDate = bookingDates[i];\r\n      const bookingNumber = generateBookingNumber();\r\n\r\n      // Tip is only applied to the first booking in a recurring series (one-time payment)\r\n      const tipAmount = (i === 0) ? (formData.tipAmount || 0) : 0;\r\n      \r\n      const bookingInput: BookingCreateInput = {\r\n        booking_number: bookingNumber,\r\n        customer_first_name: formData.customerFirstName,\r\n        customer_last_name: formData.customerLastName,\r\n        customer_email: formData.customerEmail,\r\n        customer_phone: formData.customerPhone,\r\n        service_id: formData.serviceId,\r\n        service_type: service.name,\r\n        bedrooms: formData.bedrooms,\r\n        bathrooms: formData.bathrooms,\r\n        additional_services: formData.additionalServices,\r\n        cleaning_equipment: formData.cleaningEquipment,\r\n        preferred_cleaner_ids: isTeamBooking \r\n          ? null // Team bookings don't have preferred cleaners\r\n          : (formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n            ? formData.preferredCleanerIds \r\n            : null),\r\n        preferred_cleaner_id: isTeamBooking\r\n          ? null // Team bookings don't have preferred cleaners\r\n          : (formData.preferredCleanerIds && formData.preferredCleanerIds.length > 0 \r\n            ? formData.preferredCleanerIds[0] \r\n            : null), // Backward compatibility: set to first cleaner\r\n        team_number: isTeamBooking && formData.teamNumber ? formData.teamNumber : null,\r\n        cleaning_frequency: formData.cleaningFrequency,\r\n        service_date: formatDateForDB(bookingDate),\r\n        service_time: formData.serviceTime,\r\n        service_duration: formData.serviceDuration,\r\n        service_address: formData.serviceAddress,\r\n        service_apt_unit: formData.serviceAptUnit || null,\r\n        service_suburb: formData.serviceSuburb,\r\n        service_city: formData.serviceCity,\r\n        special_instructions: formData.specialInstructions || null,\r\n        tip_amount: tipAmount,\r\n        base_price: finalPriceBreakdown.basePrice,\r\n        additional_services_price: finalPriceBreakdown.additionalServicesPrice,\r\n        equipment_supply_price: finalPriceBreakdown.equipmentSupplyPrice,\r\n        number_of_cleaners: formData.numberOfCleaners || 1,\r\n        additional_cleaners_price: finalPriceBreakdown.additionalCleanersPrice,\r\n        frequency_discount_percent: finalPriceBreakdown.frequencyDiscountPercent,\r\n        frequency_discount_amount: finalPriceBreakdown.frequencyDiscountAmount,\r\n        subtotal: finalPriceBreakdown.subtotal,\r\n        service_fee: finalPriceBreakdown.serviceFee,\r\n        total_amount: finalPriceBreakdown.totalAmount + tipAmount,\r\n        discount_code: formData.discountCode || null,\r\n        discount_amount: discountAmount,\r\n        referral_code: formData.referralCode || null,\r\n        amount_paid: 0,\r\n        payment_status: 'pending',\r\n        status: 'pending',\r\n        user_id: userId,\r\n        parent_booking_id: null, // Will be updated after first booking is created\r\n        is_recurring: isRecurring,\r\n        recurrence_status: isRecurring ? 'active' : undefined,\r\n        next_booking_date: i === 0 && isRecurring && nextBookingDate ? formatDateForDB(nextBookingDate) : null,\r\n        credits_used: 0, // Will be updated when credits are used during payment\r\n      };\r\n\r\n      bookingsToCreate.push(bookingInput);\r\n    }\r\n\r\n    // Insert all bookings\r\n    const { data: insertedBookings, error } = await supabase\r\n      .from('bookings')\r\n      .insert(bookingsToCreate)\r\n      .select('id, total_amount');\r\n\r\n    if (error) {\r\n      console.error('Error creating booking drafts:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    if (!insertedBookings || insertedBookings.length === 0) {\r\n      return { success: false, error: 'Failed to create bookings' };\r\n    }\r\n\r\n    // Update parent_booking_id for subsequent bookings if there are multiple\r\n    if (insertedBookings.length > 1 && isRecurring) {\r\n      const firstBookingId = insertedBookings[0].id;\r\n      const subsequentBookingIds = insertedBookings.slice(1).map(b => b.id);\r\n      \r\n      // Update all subsequent bookings to reference the first one\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({ parent_booking_id: firstBookingId })\r\n        .in('id', subsequentBookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating parent_booking_id:', updateError);\r\n        // Don't fail, but log the error\r\n      }\r\n    }\r\n\r\n    // Calculate total amount\r\n    const totalAmount = insertedBookings.reduce((sum, booking) => sum + Number(booking.total_amount), 0);\r\n    const bookingIds = insertedBookings.map(booking => booking.id);\r\n\r\n    // For backward compatibility, also return single bookingId\r\n    const bookingId = bookingIds[0];\r\n\r\n    // If multiple bookings, return array; otherwise return single ID for backward compatibility\r\n    if (bookingIds.length > 1) {\r\n      return { \r\n        success: true, \r\n        bookingIds,\r\n        totalAmount,\r\n        bookingId // Keep for backward compatibility\r\n      };\r\n    }\r\n\r\n    return { \r\n      success: true, \r\n      bookingId,\r\n      bookingIds,\r\n      totalAmount\r\n    };\r\n  } catch (error) {\r\n    console.error('Unexpected error creating booking draft:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize payment for booking(s)\r\n * Accepts either a single bookingId or an array of bookingIds\r\n */\r\nexport async function initializePaymentForBooking(\r\n  bookingIdOrIds: string | string[]\r\n): Promise<{\r\n  success: boolean;\r\n  authorizationUrl?: string;\r\n  reference?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const bookingIds = Array.isArray(bookingIdOrIds) ? bookingIdOrIds : [bookingIdOrIds];\r\n\r\n    // Get all booking details\r\n    const { data: bookings, error: fetchError } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .in('id', bookingIds);\r\n\r\n    if (fetchError || !bookings || bookings.length === 0) {\r\n      return { success: false, error: 'Booking(s) not found' };\r\n    }\r\n\r\n    // Check if all bookings are in pending status\r\n    const nonPendingBookings = bookings.filter(b => b.payment_status !== 'pending');\r\n    if (nonPendingBookings.length > 0) {\r\n      return { success: false, error: 'Some bookings are not in pending payment status' };\r\n    }\r\n\r\n    // Calculate total amount from all bookings (including tip)\r\n    // Note: total_amount in database now includes tip for new bookings\r\n    // For backward compatibility with existing bookings that might not have tip in total_amount, \r\n    // we check and add tip_amount if it's missing\r\n    const totalAmount = bookings.reduce((sum, booking) => {\r\n      const bookingTotal = Number(booking.total_amount) || 0;\r\n      const tipAmount = Number(booking.tip_amount) || 0;\r\n      const baseTotal = Number(booking.subtotal || 0) + Number(booking.service_fee || 0);\r\n      \r\n      // Check if tip is already included in total_amount\r\n      // If total_amount equals baseTotal exactly, then tip is not included, so add it\r\n      // Otherwise, total_amount already includes tip\r\n      if (tipAmount > 0 && Math.abs(bookingTotal - baseTotal) < 0.01) {\r\n        // Tip is not included in total_amount (backward compatibility case)\r\n        return sum + bookingTotal + tipAmount;\r\n      }\r\n      // Tip is already included in total_amount (new bookings)\r\n      return sum + bookingTotal;\r\n    }, 0);\r\n\r\n    // Calculate total credits used across all bookings\r\n    const totalCreditsUsed = bookings.reduce((sum, booking) => {\r\n      return sum + (Number(booking.credits_used) || 0);\r\n    }, 0);\r\n\r\n    // Calculate remaining amount after credits\r\n    const remainingAmount = totalAmount - totalCreditsUsed;\r\n\r\n    // Use the first booking's email and details for payment\r\n    const firstBooking = bookings[0];\r\n\r\n    // If credits fully cover the booking, mark as paid and skip Paystack\r\n    if (remainingAmount <= 0) {\r\n      // Update all bookings to mark as paid\r\n      const { error: updateError } = await supabase\r\n        .from('bookings')\r\n        .update({\r\n          payment_status: 'paid',\r\n          amount_paid: totalAmount, // Fully paid with credits\r\n          status: 'confirmed', // Auto-confirm when fully paid\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .in('id', bookingIds);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating bookings payment status:', updateError);\r\n        return { success: false, error: 'Failed to update booking payment status' };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        // No authorizationUrl - payment fully covered by credits\r\n      };\r\n    }\r\n\r\n    // Partial credit coverage or no credits - proceed with Paystack for remaining amount\r\n    // Always generate a new unique reference for Paystack (references must be unique and can only be used once)\r\n    const reference = `${firstBooking.booking_number}${Date.now()}${Math.random().toString(36).substring(2, 9)}`;\r\n    \r\n    // Initialize Paystack payment with remaining amount (after credits)\r\n    const paymentResponse = await initializePayment(\r\n      firstBooking.customer_email,\r\n      remainingAmount, // Only charge the remaining amount\r\n      reference,\r\n      {\r\n        booking_ids: bookingIds,\r\n        booking_id: firstBooking.id, // Keep for backward compatibility\r\n        booking_number: firstBooking.booking_number,\r\n        customer_email: firstBooking.customer_email,\r\n        credits_used: totalCreditsUsed, // Include in metadata for tracking\r\n      }\r\n    );\r\n\r\n    if (!paymentResponse.status) {\r\n      return { success: false, error: paymentResponse.message || 'Failed to initialize payment' };\r\n    }\r\n\r\n    // Use the reference that Paystack actually returned (may differ from what we sent)\r\n    const paystackReference = paymentResponse.data.reference;\r\n\r\n    // Update all bookings with the Paystack reference and partial payment from credits\r\n    const { error: updateError } = await supabase\r\n      .from('bookings')\r\n      .update({\r\n        paystack_reference: paystackReference,\r\n        amount_paid: totalCreditsUsed, // Partial payment from credits, Paystack will complete it\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .in('id', bookingIds);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating bookings with Paystack reference:', updateError);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      authorizationUrl: paymentResponse.data.authorization_url,\r\n      reference: paystackReference,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error initializing payment:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Failed to initialize payment',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get booking by ID\r\n */\r\nexport async function getBooking(bookingId: string): Promise<{\r\n  success: boolean;\r\n  booking?: any;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('bookings')\r\n      .select('*')\r\n      .eq('id', bookingId)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { success: false, error: 'Booking not found' };\r\n    }\r\n\r\n    return { success: true, booking: data };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching booking:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners for selection\r\n * Optionally filter by service area/suburb\r\n */\r\nexport async function getAvailableCleaners(serviceSuburb?: string): Promise<{\r\n  success: boolean;\r\n  cleaners?: any[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Build query - only filter by is_available if the column exists\r\n    // First, try to get all active cleaners\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = data || [];\r\n\r\n    // Filter by is_available if the column exists (client-side filter as fallback)\r\n    cleaners = cleaners.filter((cleaner) => {\r\n      // If is_available column doesn't exist or is null/undefined, include the cleaner\r\n      // Otherwise, only include if is_available is true\r\n      return cleaner.is_available !== false;\r\n    });\r\n\r\n    // Filter by area if suburb is provided\r\n    // Since PostgreSQL array contains is complex in Supabase, we filter client-side\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        // If cleaner has no areas specified, include them (they serve all areas)\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true;\r\n        }\r\n        // Check if any area matches the suburb (case-insensitive partial match)\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    return { success: true, cleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a cleaner is available for a specific day of the week\r\n * dayOfWeek: 0 = Sunday, 1 = Monday, ..., 6 = Saturday\r\n */\r\nexport async function isCleanerAvailableForDay(cleaner: any, dayOfWeek: number): Promise<boolean> {\r\n  const dayMap: Record<number, keyof typeof cleaner> = {\r\n    0: 'available_sunday',\r\n    1: 'available_monday',\r\n    2: 'available_tuesday',\r\n    3: 'available_wednesday',\r\n    4: 'available_thursday',\r\n    5: 'available_friday',\r\n    6: 'available_saturday',\r\n  };\r\n\r\n  const dayField = dayMap[dayOfWeek];\r\n  return cleaner[dayField] !== false && cleaner.is_available !== false;\r\n}\r\n\r\n/**\r\n * Check if a cleaner has a booking conflict for a specific date and time slot\r\n */\r\nexport async function checkCleanerBookingConflict(\r\n  cleanerId: string,\r\n  serviceDate: string,\r\n  serviceTime: string,\r\n  serviceDuration: number\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Query bookings for this cleaner on the specified date\r\n    // Only consider paid and confirmed bookings (exclude pending/unpaid bookings)\r\n    // Cleaners should only be marked as booked when booking is paid and created\r\n    const { data: bookings, error } = await supabase\r\n      .from('bookings')\r\n      .select('service_time, service_duration')\r\n      .eq('preferred_cleaner_id', cleanerId)\r\n      .eq('service_date', serviceDate)\r\n      .eq('payment_status', 'paid')\r\n      .eq('status', 'confirmed');\r\n\r\n    if (error) {\r\n      console.error('Error checking booking conflicts:', error);\r\n      return false; // Assume no conflict on error\r\n    }\r\n\r\n    if (!bookings || bookings.length === 0) {\r\n      return false; // No bookings, no conflict\r\n    }\r\n\r\n    // Parse the new booking start time\r\n    const [newStartHours, newStartMinutes] = serviceTime.split(':').map(Number);\r\n    const newStartTimeMinutes = newStartHours * 60 + newStartMinutes;\r\n    const serviceDurationMinutes = Math.round(serviceDuration * 60);\r\n    const newEndTimeMinutes = newStartTimeMinutes + serviceDurationMinutes;\r\n\r\n    // Check each existing booking for overlap\r\n    for (const booking of bookings) {\r\n      if (!booking.service_time) continue;\r\n\r\n      // Parse booking start time\r\n      const [bookingStartHours, bookingStartMinutes] = booking.service_time\r\n        .split(':')\r\n        .slice(0, 2)\r\n        .map(Number);\r\n      const bookingStartTimeMinutes = bookingStartHours * 60 + bookingStartMinutes;\r\n\r\n      // Parse booking duration\r\n      const bookingDurationMinutes = Math.round(\r\n        (typeof booking.service_duration === 'number'\r\n          ? booking.service_duration\r\n          : parseFloat(booking.service_duration || '0')) * 60\r\n      );\r\n      const bookingEndTimeMinutes = bookingStartTimeMinutes + bookingDurationMinutes;\r\n\r\n      // Check for overlap: new start < existing end AND new end > existing start\r\n      if (newStartTimeMinutes < bookingEndTimeMinutes && newEndTimeMinutes > bookingStartTimeMinutes) {\r\n        return true; // Conflict found\r\n      }\r\n    }\r\n\r\n    return false; // No conflicts\r\n  } catch (error) {\r\n    console.error('Unexpected error checking booking conflict:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate reliability score for a cleaner (server-side wrapper)\r\n * This calls the database function if available, otherwise calculates client-side\r\n */\r\nexport async function calculateCleanerReliabilityScore(cleanerId: string): Promise<number> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    // Try to call the database function\r\n    const { data, error } = await supabase.rpc('calculate_cleaner_reliability_score', {\r\n      cleaner_id: cleanerId,\r\n    });\r\n\r\n    if (!error && data !== null) {\r\n      return parseFloat(data.toString());\r\n    }\r\n\r\n    // Fallback: fetch cleaner and calculate client-side\r\n    const { data: cleaner, error: fetchError } = await supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('id', cleanerId)\r\n      .single();\r\n\r\n    if (fetchError || !cleaner) {\r\n      return 50.0; // Default score\r\n    }\r\n\r\n    return calculateReliabilityScore(cleaner as Cleaner);\r\n  } catch (error) {\r\n    console.error('Error calculating reliability score:', error);\r\n    return 50.0; // Default score on error\r\n  }\r\n}\r\n\r\n/**\r\n * Get available cleaners with enhanced filtering criteria\r\n * Filters by: Location, Availability, Booking conflicts\r\n * Sorts by: Reliability Score, Rating\r\n */\r\nexport async function getAvailableCleanersWithCriteria(params: {\r\n  serviceSuburb?: string;\r\n  serviceDate?: string;\r\n  serviceTime?: string;\r\n  serviceDuration?: number;\r\n  minRating?: number;\r\n  minReliabilityScore?: number;\r\n}): Promise<{\r\n  success: boolean;\r\n  cleaners?: CleanerWithAvailability[];\r\n  error?: string;\r\n}> {\r\n  try {\r\n    const supabase = await createClient();\r\n    const {\r\n      serviceSuburb,\r\n      serviceDate,\r\n      serviceTime,\r\n      serviceDuration = 3,\r\n      minRating = 0,\r\n      minReliabilityScore = 0,\r\n    } = params;\r\n\r\n    // Build base query\r\n    let query = supabase\r\n      .from('cleaners')\r\n      .select('*')\r\n      .eq('is_active', true);\r\n\r\n    const { data, error } = await query.order('reliability_score', { ascending: false, nullsFirst: false })\r\n      .order('rating', { ascending: false })\r\n      .order('name', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching cleaners:', error);\r\n      return { success: false, error: 'Failed to fetch cleaners' };\r\n    }\r\n\r\n    let cleaners = (data || []) as Cleaner[];\r\n\r\n    // Filter by is_available\r\n    cleaners = cleaners.filter((cleaner) => cleaner.is_available !== false);\r\n\r\n    // Filter by location (suburb)\r\n    if (serviceSuburb && cleaners.length > 0) {\r\n      const suburbLower = serviceSuburb.toLowerCase().trim();\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        if (!cleaner.areas || cleaner.areas.length === 0) {\r\n          return true; // Serve all areas\r\n        }\r\n        return cleaner.areas.some((area: string) => {\r\n          const areaLower = area.toLowerCase();\r\n          return areaLower.includes(suburbLower) || suburbLower.includes(areaLower);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Filter by day of week availability if date is provided\r\n    if (serviceDate) {\r\n      const date = new Date(serviceDate);\r\n      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      cleaners = cleaners.filter((cleaner) => {\r\n        const dayMap: Record<number, keyof Cleaner> = {\r\n          0: 'available_sunday',\r\n          1: 'available_monday',\r\n          2: 'available_tuesday',\r\n          3: 'available_wednesday',\r\n          4: 'available_thursday',\r\n          5: 'available_friday',\r\n          6: 'available_saturday',\r\n        };\r\n        const dayField = dayMap[dayOfWeek];\r\n        return cleaner[dayField] !== false;\r\n      });\r\n    }\r\n\r\n    // Filter by minimum rating\r\n    if (minRating > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.rating || 0) >= minRating);\r\n    }\r\n\r\n    // Filter by minimum reliability score\r\n    if (minReliabilityScore > 0) {\r\n      cleaners = cleaners.filter((cleaner) => (cleaner.reliability_score || 0) >= minReliabilityScore);\r\n    }\r\n\r\n    // Enrich cleaners with availability and booking conflict information\r\n    const enrichedCleaners: CleanerWithAvailability[] = await Promise.all(\r\n      cleaners.map(async (cleaner) => {\r\n        let isAvailableForSlot = true;\r\n        let bookingConflict = false;\r\n\r\n        // Check booking conflict if date and time are provided\r\n        if (serviceDate && serviceTime && serviceDuration) {\r\n          bookingConflict = await checkCleanerBookingConflict(\r\n            cleaner.id,\r\n            serviceDate,\r\n            serviceTime,\r\n            serviceDuration\r\n          );\r\n          isAvailableForSlot = !bookingConflict;\r\n        }\r\n\r\n        // Calculate reliability score if not present\r\n        const reliabilityScore = cleaner.reliability_score ?? calculateReliabilityScore(cleaner);\r\n\r\n        return {\r\n          ...cleaner,\r\n          reliability_score: reliabilityScore,\r\n          isAvailableForSlot,\r\n          bookingConflict,\r\n          completionRate: calculateCompletionRate(cleaner),\r\n          onTimeRate: calculateOnTimeRate(cleaner),\r\n        };\r\n      })\r\n    );\r\n\r\n    // Sort by reliability score and rating (already sorted by query, but ensure consistency)\r\n    enrichedCleaners.sort((a, b) => {\r\n      const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n      const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n\r\n    return { success: true, cleaners: enrichedCleaners };\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching cleaners with criteria:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    };\r\n  }\r\n}\r\n\r\n","'use server';\r\n\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { PricingRule } from '@/types/booking';\r\n\r\n/**\r\n * Fetch all active pricing rules\r\n */\r\nexport async function getPricingRules(): Promise<PricingRule[]> {\r\n  try {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from('pricing_rules')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('display_order', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching pricing rules:', error);\r\n      return [];\r\n    }\r\n\r\n    return (data || []) as PricingRule[];\r\n  } catch (error) {\r\n    console.error('Unexpected error fetching pricing rules:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get base price for a service\r\n */\r\nexport async function getBasePrice(serviceId: string): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const basePriceRule = rules.find(\r\n    (rule) => rule.rule_type === 'base_price' && rule.service_id === serviceId\r\n  );\r\n  return basePriceRule?.price || 0;\r\n}\r\n\r\n/**\r\n * Get bedroom pricing\r\n */\r\nexport async function getBedroomPrice(bedroomCount: string): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const bedroomRule = rules.find(\r\n    (rule) => rule.rule_type === 'bedroom' && rule.rule_value === bedroomCount\r\n  );\r\n  return bedroomRule?.price || 0;\r\n}\r\n\r\n/**\r\n * Get bathroom pricing\r\n */\r\nexport async function getBathroomPrice(bathroomCount: string): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const bathroomRule = rules.find(\r\n    (rule) => rule.rule_type === 'bathroom' && rule.rule_value === bathroomCount\r\n  );\r\n  return bathroomRule?.price || 0;\r\n}\r\n\r\n/**\r\n * Get additional service pricing\r\n */\r\nexport async function getAdditionalServicePrice(serviceId: string): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const serviceRule = rules.find(\r\n    (rule) => rule.rule_type === 'additional_service' && rule.additional_service_id === serviceId\r\n  );\r\n  return serviceRule?.price || 0;\r\n}\r\n\r\n/**\r\n * Get service fee percentage\r\n */\r\nexport async function getServiceFeePercentage(): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const feeRule = rules.find(\r\n    (rule) => rule.rule_type === 'service_fee'\r\n  );\r\n  return feeRule?.percentage || 0;\r\n}\r\n\r\n/**\r\n * Get frequency discount percentage\r\n */\r\nexport async function getFrequencyDiscount(frequency: 'weekly' | 'bi-weekly' | 'monthly'): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const discountRule = rules.find(\r\n    (rule) => rule.rule_type === 'frequency_discount' && rule.rule_value === frequency\r\n  );\r\n  return discountRule?.percentage || 0;\r\n}\r\n\r\n/**\r\n * Get fitted room price (per room)\r\n */\r\nexport async function getFittedRoomPrice(): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const fittedRoomRule = rules.find(\r\n    (rule) => rule.rule_type === 'fitted_room' && rule.rule_key === 'per_room'\r\n  );\r\n  return fittedRoomRule?.price || 0;\r\n}\r\n\r\n/**\r\n * Get loose carpet/rug price (per carpet/rug)\r\n */\r\nexport async function getLooseCarpetPrice(): Promise<number> {\r\n  const rules = await getPricingRules();\r\n  const looseCarpetRule = rules.find(\r\n    (rule) => rule.rule_type === 'loose_carpet' && rule.rule_key === 'per_carpet'\r\n  );\r\n  return looseCarpetRule?.price || 0;\r\n}\r\n\r\n","/**\r\n * Service validation utilities for recurring bookings\r\n * \r\n * Only Standard Cleaning and Airbnb Cleaning support recurring bookings.\r\n * All other services (Deep Cleaning, Move In/Out, Carpet Cleaning) are One-Time only.\r\n */\r\n\r\n/**\r\n * Check if a service supports recurring bookings\r\n * @param serviceName - The name of the service (case-insensitive)\r\n * @returns true if the service supports recurring bookings, false otherwise\r\n */\r\nexport function supportsRecurringBookings(serviceName: string): boolean {\r\n  if (!serviceName) return false;\r\n  \r\n  const normalizedName = serviceName.toLowerCase().trim();\r\n  \r\n  // Standard Cleaning supports recurring\r\n  if (normalizedName.includes('standard')) {\r\n    return true;\r\n  }\r\n  \r\n  // Airbnb Cleaning supports recurring\r\n  if (normalizedName.includes('airbnb')) {\r\n    return true;\r\n  }\r\n  \r\n  // All other services are One-Time only\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get available frequencies for a service\r\n * @param serviceName - The name of the service (case-insensitive)\r\n * @returns Array of available frequency options\r\n */\r\nexport function getAvailableFrequencies(\r\n  serviceName: string\r\n): ('one-time' | 'weekly' | 'bi-weekly' | 'monthly')[] {\r\n  if (supportsRecurringBookings(serviceName)) {\r\n    return ['one-time', 'weekly', 'bi-weekly', 'monthly'];\r\n  }\r\n  \r\n  // Non-supported services only allow One-Time\r\n  return ['one-time'];\r\n}\r\n\r\n/**\r\n * Check if a frequency is valid for a service\r\n * @param serviceName - The name of the service\r\n * @param frequency - The frequency to check\r\n * @returns true if the frequency is valid for the service\r\n */\r\nexport function isValidFrequencyForService(\r\n  serviceName: string,\r\n  frequency: 'one-time' | 'weekly' | 'bi-weekly' | 'monthly'\r\n): boolean {\r\n  const availableFrequencies = getAvailableFrequencies(serviceName);\r\n  return availableFrequencies.includes(frequency);\r\n}\r\n\r\n/**\r\n * Check if a service requires team-based booking\r\n * \r\n * Deep Cleaning and Move In/Out services require team booking (3 teams available per day).\r\n * Each team can be booked once per day for the entire day.\r\n * \r\n * @param serviceName - The name of the service (case-insensitive)\r\n * @returns true if the service requires team booking, false otherwise\r\n */\r\nexport function requiresTeamBooking(serviceName: string): boolean {\r\n  if (!serviceName) return false;\r\n  \r\n  const normalizedName = serviceName.toLowerCase().trim();\r\n  \r\n  // Deep Cleaning requires team booking\r\n  if (normalizedName.includes('deep')) {\r\n    return true;\r\n  }\r\n  \r\n  // Move In/Out requires team booking\r\n  // Check for \"move\" and (\"in/out\" or \"in out\" or \"inout\")\r\n  if (normalizedName.includes('move')) {\r\n    if (normalizedName.includes('in/out') || \r\n        normalizedName.includes('in out') || \r\n        normalizedName.includes('inout')) {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  // All other services use individual cleaners\r\n  return false;\r\n}\r\n\r\n","'use server';\r\n\r\nimport { \r\n  getBasePrice, \r\n  getBedroomPrice, \r\n  getBathroomPrice, \r\n  getAdditionalServicePrice,\r\n  getServiceFeePercentage,\r\n  getFrequencyDiscount,\r\n  getFittedRoomPrice,\r\n  getLooseCarpetPrice\r\n} from './rules';\r\nimport { PriceBreakdown } from '@/types/booking';\r\nimport { AdditionalService } from '@/types/quote';\r\nimport { supportsRecurringBookings } from '@/lib/utils/service-validation';\r\n\r\ninterface CalculatePriceParams {\r\n  serviceId: string;\r\n  serviceName?: string; // Service name to check if recurring bookings are supported\r\n  bedrooms: string;\r\n  bathrooms: string;\r\n  additionalServiceIds: string[];\r\n  additionalServices?: AdditionalService[]; // For quantity-based pricing\r\n  cleaningFrequency: 'one-time' | 'weekly' | 'bi-weekly' | 'monthly';\r\n  discountAmount?: number;\r\n  numberOfFittedRooms?: string;\r\n  numberOfLooseCarpets?: string;\r\n  isCarpetCleaning?: boolean;\r\n  cleaningEquipment?: 'yes' | 'no' | '';\r\n  numberOfCleaners?: number; // Number of cleaners (1-5, only for Standard and Airbnb)\r\n}\r\n\r\n/**\r\n * Calculate complete price breakdown for a booking\r\n */\r\nexport async function calculatePrice(params: CalculatePriceParams): Promise<PriceBreakdown> {\r\n  const {\r\n    serviceId,\r\n    serviceName,\r\n    bedrooms,\r\n    bathrooms,\r\n    additionalServiceIds,\r\n    additionalServices = [],\r\n    cleaningFrequency,\r\n    discountAmount = 0,\r\n    numberOfFittedRooms = '',\r\n    numberOfLooseCarpets = '',\r\n    isCarpetCleaning = false,\r\n    cleaningEquipment = '',\r\n    numberOfCleaners = 1\r\n  } = params;\r\n\r\n  // Equipment supply charge constant\r\n  const EQUIPMENT_SUPPLY_CHARGE = 500;\r\n  \r\n  // Additional cleaner charge constant (R250 per additional cleaner)\r\n  const ADDITIONAL_CLEANER_CHARGE = 250;\r\n\r\n  // Base price\r\n  const basePrice = await getBasePrice(serviceId);\r\n\r\n  // Bedroom price (only for non-carpet services)\r\n  const bedroomsPrice = isCarpetCleaning ? 0 : await getBedroomPrice(bedrooms);\r\n\r\n  // Bathroom price (only for non-carpet services)\r\n  const bathroomsPrice = isCarpetCleaning ? 0 : await getBathroomPrice(bathrooms);\r\n\r\n  // Carpet pricing (for carpet cleaning service)\r\n  const fittedRoomPricePerUnit = await getFittedRoomPrice();\r\n  const fittedRoomsPrice = fittedRoomPricePerUnit * (parseFloat(numberOfFittedRooms) || 0);\r\n\r\n  const looseCarpetPricePerUnit = await getLooseCarpetPrice();\r\n  const looseCarpetsPrice = looseCarpetPricePerUnit * (parseFloat(numberOfLooseCarpets) || 0);\r\n\r\n  // Additional services price\r\n  let additionalServicesPrice = 0;\r\n  for (const serviceId of additionalServiceIds) {\r\n    const price = await getAdditionalServicePrice(serviceId);\r\n    \r\n    // Check if service requires quantity and has quantity specified\r\n    const service = additionalServices.find(s => s.id === serviceId);\r\n    if (service?.requires_quantity) {\r\n      // For quantity-based services, multiply by quantity if available\r\n      // This would need to be passed in the params if we track quantities\r\n      additionalServicesPrice += price; // For now, single unit price\r\n    } else {\r\n      additionalServicesPrice += price;\r\n    }\r\n  }\r\n\r\n  // Equipment supply charge - only for Standard and Airbnb services when user selects 'yes'\r\n  let equipmentSupplyPrice = 0;\r\n  if (cleaningEquipment === 'yes' && serviceName && supportsRecurringBookings(serviceName)) {\r\n    equipmentSupplyPrice = EQUIPMENT_SUPPLY_CHARGE;\r\n  }\r\n\r\n  // Additional cleaners charge - only for Standard and Airbnb services\r\n  // First cleaner is included in base price, charge for each additional cleaner\r\n  let additionalCleanersPrice = 0;\r\n  if (serviceName && supportsRecurringBookings(serviceName) && numberOfCleaners > 1) {\r\n    const additionalCleanersCount = Math.max(0, Math.min(numberOfCleaners - 1, 4)); // Max 4 additional (total 5 cleaners)\r\n    additionalCleanersPrice = additionalCleanersCount * ADDITIONAL_CLEANER_CHARGE;\r\n  }\r\n\r\n  // Subtotal before discounts\r\n  const subtotal = basePrice + bedroomsPrice + bathroomsPrice + fittedRoomsPrice + looseCarpetsPrice + additionalServicesPrice + equipmentSupplyPrice + additionalCleanersPrice;\r\n\r\n  // Frequency discount - only apply to Standard and Airbnb cleaning services\r\n  let frequencyDiscountPercent = 0;\r\n  let frequencyDiscountAmount = 0;\r\n  \r\n  // Only apply frequency discount if ALL conditions are met:\r\n  // 1. Frequency is not one-time\r\n  // 2. Service name is provided (not undefined, not empty)\r\n  // 3. Service supports recurring bookings (Standard or Airbnb only)\r\n  if (cleaningFrequency !== 'one-time' && serviceName && serviceName.trim() !== '') {\r\n    if (supportsRecurringBookings(serviceName)) {\r\n      frequencyDiscountPercent = await getFrequencyDiscount(cleaningFrequency);\r\n      frequencyDiscountAmount = (subtotal * frequencyDiscountPercent) / 100;\r\n    }\r\n    // Explicitly: If service doesn't support recurring, discount remains 0\r\n    // This ensures Deep Cleaning, Move In/Out, and Carpet Cleaning NEVER get discounts\r\n  }\r\n\r\n  // Subtotal after frequency discount\r\n  const subtotalAfterFrequencyDiscount = subtotal - frequencyDiscountAmount;\r\n\r\n  // Apply discount code (passed in as discountAmount)\r\n  const finalSubtotal = Math.max(0, subtotalAfterFrequencyDiscount - discountAmount);\r\n\r\n  // Service fee (calculated on subtotal after frequency discount, before discount code)\r\n  const serviceFeePercentage = await getServiceFeePercentage();\r\n  const serviceFee = (subtotalAfterFrequencyDiscount * serviceFeePercentage) / 100;\r\n\r\n  // Total amount (subtotal after all discounts + service fee)\r\n  const totalAmount = finalSubtotal + serviceFee;\r\n\r\n  return {\r\n    basePrice,\r\n    bedroomsPrice,\r\n    bathroomsPrice,\r\n    fittedRoomsPrice,\r\n    looseCarpetsPrice,\r\n    additionalServicesPrice,\r\n    equipmentSupplyPrice,\r\n    additionalCleanersPrice,\r\n    subtotal,\r\n    frequencyDiscountPercent,\r\n    frequencyDiscountAmount,\r\n    discountAmount,\r\n    serviceFee,\r\n    totalAmount\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate price breakdown for display (used in real-time updates)\r\n * This is a lighter version that can be called frequently\r\n */\r\nexport async function calculatePriceBreakdown(\r\n  serviceId: string,\r\n  bedrooms: string,\r\n  bathrooms: string,\r\n  additionalServiceIds: string[],\r\n  cleaningFrequency: 'one-time' | 'weekly' | 'bi-weekly' | 'monthly',\r\n  discountAmount: number = 0,\r\n  numberOfFittedRooms: string = '',\r\n  numberOfLooseCarpets: string = '',\r\n  isCarpetCleaning: boolean = false,\r\n  serviceName?: string,\r\n  cleaningEquipment?: 'yes' | 'no' | '',\r\n  numberOfCleaners: number = 1\r\n): Promise<PriceBreakdown> {\r\n  return calculatePrice({\r\n    serviceId,\r\n    serviceName,\r\n    bedrooms,\r\n    bathrooms,\r\n    additionalServiceIds,\r\n    cleaningFrequency,\r\n    discountAmount,\r\n    numberOfFittedRooms,\r\n    numberOfLooseCarpets,\r\n    isCarpetCleaning,\r\n    cleaningEquipment,\r\n    numberOfCleaners\r\n  });\r\n}\r\n\r\n","/**\r\n * Generate a unique booking number\r\n * Format: SHL followed by numbers only (e.g., SHL20250115123456)\r\n */\r\nexport function generateBookingNumber(): string {\r\n  const date = new Date();\r\n  const year = date.getFullYear();\r\n  const month = String(date.getMonth() + 1).padStart(2, '0');\r\n  const day = String(date.getDate()).padStart(2, '0');\r\n  \r\n  // Generate random 6-digit number (000000-999999)\r\n  const randomNumber = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');\r\n  \r\n  return `SHL${year}${month}${day}${randomNumber}`;\r\n}\r\n","/**\r\n * Paystack API client\r\n */\r\n\r\nconst PAYSTACK_SECRET_KEY = process.env.PAYSTACK_SECRET_KEY;\r\nconst PAYSTACK_PUBLIC_KEY = process.env.NEXT_PUBLIC_PAYSTACK_PUBLIC_KEY;\r\nconst PAYSTACK_API_URL = 'https://api.paystack.co';\r\n\r\nexport interface PaystackInitializeResponse {\r\n  status: boolean;\r\n  message: string;\r\n  data: {\r\n    authorization_url: string;\r\n    access_code: string;\r\n    reference: string;\r\n  };\r\n}\r\n\r\nexport interface PaystackVerifyResponse {\r\n  status: boolean;\r\n  message: string;\r\n  data: {\r\n    id: number;\r\n    domain: string;\r\n    status: string;\r\n    reference: string;\r\n    amount: number;\r\n    message: string | null;\r\n    gateway_response: string;\r\n    paid_at: string | null;\r\n    created_at: string;\r\n    channel: string;\r\n    currency: string;\r\n    ip_address: string;\r\n    metadata: {\r\n      booking_id?: string;\r\n      customer_email?: string;\r\n      custom_fields?: Array<{ display_name: string; variable_name: string; value: string }>;\r\n    };\r\n    log: any;\r\n    fees: number;\r\n    fees_split: any;\r\n    authorization: any;\r\n    customer: any;\r\n    plan: any;\r\n    split: any;\r\n    order_id: any;\r\n    paidAt: string | null;\r\n    createdAt: string;\r\n    requested_amount: number;\r\n    pos_transaction_data: any;\r\n    source: any;\r\n    fees_breakdown: any;\r\n  };\r\n}\r\n\r\n/**\r\n * Initialize a Paystack transaction\r\n */\r\nexport async function initializePayment(\r\n  email: string,\r\n  amount: number, // Amount in kobo (Nigerian Naira) or cents. For ZAR, convert to cents (amount * 100)\r\n  reference: string,\r\n  metadata?: {\r\n    booking_id?: string;\r\n    [key: string]: any;\r\n  }\r\n): Promise<PaystackInitializeResponse> {\r\n  if (!PAYSTACK_SECRET_KEY) {\r\n    throw new Error('Paystack secret key is not configured');\r\n  }\r\n\r\n  // Convert ZAR amount to kobo/cents (multiply by 100)\r\n  const amountInKobo = Math.round(amount * 100);\r\n\r\n  // Build callback URL for payment success page\r\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';\r\n  const callbackUrl = `${appUrl}/payment/success?reference=${reference}`;\r\n\r\n  const response = await fetch(`${PAYSTACK_API_URL}/transaction/initialize`, {\r\n    method: 'POST',\r\n    headers: {\r\n      'Authorization': `Bearer ${PAYSTACK_SECRET_KEY}`,\r\n      'Content-Type': 'application/json',\r\n    },\r\n    body: JSON.stringify({\r\n      email,\r\n      amount: amountInKobo,\r\n      reference,\r\n      metadata,\r\n      currency: 'ZAR', // South African Rand\r\n      callback_url: callbackUrl,\r\n    }),\r\n  });\r\n\r\n  if (!response.ok) {\r\n    const error = await response.json();\r\n    throw new Error(error.message || 'Failed to initialize payment');\r\n  }\r\n\r\n  return response.json();\r\n}\r\n\r\n/**\r\n * Verify a Paystack transaction\r\n */\r\nexport async function verifyPayment(reference: string): Promise<PaystackVerifyResponse> {\r\n  if (!PAYSTACK_SECRET_KEY) {\r\n    throw new Error('Paystack secret key is not configured');\r\n  }\r\n\r\n  const response = await fetch(`${PAYSTACK_API_URL}/transaction/verify/${reference}`, {\r\n    method: 'GET',\r\n    headers: {\r\n      'Authorization': `Bearer ${PAYSTACK_SECRET_KEY}`,\r\n      'Content-Type': 'application/json',\r\n    },\r\n  });\r\n\r\n  if (!response.ok) {\r\n    const error = await response.json();\r\n    throw new Error(error.message || 'Failed to verify payment');\r\n  }\r\n\r\n  return response.json();\r\n}\r\n\r\n/**\r\n * Verify Paystack webhook signature\r\n */\r\nexport function verifyWebhookSignature(\r\n  payload: string,\r\n  signature: string\r\n): boolean {\r\n  const crypto = require('crypto');\r\n  const secret = process.env.PAYSTACK_WEBHOOK_SECRET || PAYSTACK_SECRET_KEY || '';\r\n  \r\n  if (!secret) {\r\n    return false;\r\n  }\r\n\r\n  const hash = crypto\r\n    .createHmac('sha512', secret)\r\n    .update(payload)\r\n    .digest('hex');\r\n\r\n  return hash === signature;\r\n}\r\n\r\n/**\r\n * Get Paystack public key for client-side use\r\n */\r\nexport function getPaystackPublicKey(): string {\r\n  if (!PAYSTACK_PUBLIC_KEY) {\r\n    throw new Error('Paystack public key is not configured');\r\n  }\r\n  return PAYSTACK_PUBLIC_KEY;\r\n}\r\n\r\n","import { Cleaner, CleanerWithAvailability } from '@/types/booking';\r\n\r\nexport type SortCriteria = 'best-match' | 'highest-rated' | 'most-reliable' | 'most-experienced';\r\n\r\n/**\r\n * Calculate reliability score from booking metrics\r\n * Formula:\r\n * - Completion Rate (40%): (completed_bookings / total_bookings) * 40\r\n * - On-Time Rate (30%): (on_time_bookings / total_bookings) * 30\r\n * - Rating Factor (20%): (rating / 5.0) * 20\r\n * - Booking Volume (10%): min(total_bookings / 50, 1) * 10\r\n */\r\nexport function calculateReliabilityScore(cleaner: Cleaner): number {\r\n  const totalBookings = cleaner.total_bookings || 0;\r\n  const completedBookings = cleaner.completed_bookings || 0;\r\n  const onTimeBookings = cleaner.on_time_bookings || 0;\r\n  const rating = cleaner.rating || 0;\r\n\r\n  // If no bookings, return default score of 50\r\n  if (totalBookings === 0) {\r\n    return 50.0;\r\n  }\r\n\r\n  // Calculate completion rate score (40% weight)\r\n  const completionRateScore = (completedBookings / totalBookings) * 40.0;\r\n\r\n  // Calculate on-time rate score (30% weight)\r\n  const onTimeRateScore = (onTimeBookings / totalBookings) * 30.0;\r\n\r\n  // Calculate rating score (20% weight)\r\n  const ratingScore = (rating / 5.0) * 20.0;\r\n\r\n  // Calculate volume score (10% weight) - normalized to max 50 bookings\r\n  const volumeScore = Math.min(totalBookings / 50.0, 1.0) * 10.0;\r\n\r\n  // Calculate final score\r\n  let finalScore = completionRateScore + onTimeRateScore + ratingScore + volumeScore;\r\n\r\n  // Ensure score is between 0 and 100\r\n  finalScore = Math.max(0.0, Math.min(100.0, finalScore));\r\n\r\n  return Math.round(finalScore * 100) / 100; // Round to 2 decimal places\r\n}\r\n\r\n/**\r\n * Format reliability score for display\r\n */\r\nexport function formatReliabilityScore(score: number | null | undefined): string {\r\n  if (score === null || score === undefined) {\r\n    return 'N/A';\r\n  }\r\n  return `${score.toFixed(0)}%`;\r\n}\r\n\r\n/**\r\n * Sort cleaners by selected criteria\r\n */\r\nexport function sortCleanersByCriteria(\r\n  cleaners: CleanerWithAvailability[],\r\n  criteria: SortCriteria\r\n): CleanerWithAvailability[] {\r\n  const sorted = [...cleaners];\r\n\r\n  switch (criteria) {\r\n    case 'best-match':\r\n      // Sort by: reliability_score (60%) + rating (40%)\r\n      sorted.sort((a, b) => {\r\n        const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n        const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n        return scoreB - scoreA;\r\n      });\r\n      break;\r\n\r\n    case 'highest-rated':\r\n      sorted.sort((a, b) => (b.rating || 0) - (a.rating || 0));\r\n      break;\r\n\r\n    case 'most-reliable':\r\n      sorted.sort((a, b) => (b.reliability_score || 0) - (a.reliability_score || 0));\r\n      break;\r\n\r\n    case 'most-experienced':\r\n      sorted.sort((a, b) => (b.years_experience || 0) - (a.years_experience || 0));\r\n      break;\r\n\r\n    default:\r\n      // Default to best-match\r\n      sorted.sort((a, b) => {\r\n        const scoreA = (a.reliability_score || 0) * 0.6 + (a.rating || 0) * 0.4;\r\n        const scoreB = (b.reliability_score || 0) * 0.6 + (b.rating || 0) * 0.4;\r\n        return scoreB - scoreA;\r\n      });\r\n  }\r\n\r\n  return sorted;\r\n}\r\n\r\n/**\r\n * Calculate completion rate for a cleaner\r\n */\r\nexport function calculateCompletionRate(cleaner: Cleaner): number {\r\n  const total = cleaner.total_bookings || 0;\r\n  const completed = cleaner.completed_bookings || 0;\r\n  if (total === 0) return 0;\r\n  return Math.round((completed / total) * 100);\r\n}\r\n\r\n/**\r\n * Calculate on-time rate for a cleaner\r\n */\r\nexport function calculateOnTimeRate(cleaner: Cleaner): number {\r\n  const total = cleaner.total_bookings || 0;\r\n  const onTime = cleaner.on_time_bookings || 0;\r\n  if (total === 0) return 0;\r\n  return Math.round((onTime / total) * 100);\r\n}\r\n\r\n","/**\r\n * Calculate all booking dates for the current month based on frequency\r\n * @param startDate - The initial booking date selected by the user\r\n * @param frequency - 'one-time' | 'weekly' | 'bi-weekly' | 'monthly'\r\n * @returns Array of dates for bookings in the current month\r\n */\r\nexport function calculateBookingDatesForMonth(\r\n  startDate: Date,\r\n  frequency: 'one-time' | 'weekly' | 'bi-weekly' | 'monthly'\r\n): Date[] {\r\n  const dates: Date[] = [];\r\n  const currentDate = new Date(startDate);\r\n  \r\n  // Get the month and year of the start date\r\n  const month = currentDate.getMonth();\r\n  const year = currentDate.getFullYear();\r\n  \r\n  // Get the last day of the month\r\n  const lastDayOfMonth = new Date(year, month + 1, 0).getDate();\r\n  \r\n  switch (frequency) {\r\n    case 'one-time':\r\n      // Return only the start date\r\n      dates.push(new Date(startDate));\r\n      break;\r\n      \r\n    case 'weekly':\r\n      // Find all occurrences of the same day of week in the month\r\n      const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 1 = Monday, etc.\r\n      const startDay = currentDate.getDate();\r\n      \r\n      // Start from the selected date\r\n      let weeklyDate = new Date(year, month, startDay);\r\n      \r\n      // Add all remaining occurrences in the month\r\n      while (weeklyDate.getMonth() === month && weeklyDate.getDate() <= lastDayOfMonth) {\r\n        dates.push(new Date(weeklyDate));\r\n        weeklyDate.setDate(weeklyDate.getDate() + 7); // Add 7 days\r\n      }\r\n      break;\r\n      \r\n    case 'bi-weekly':\r\n      // Find occurrences every 2 weeks in the month\r\n      const biWeeklyStartDay = currentDate.getDate();\r\n      let biWeeklyDate = new Date(year, month, biWeeklyStartDay);\r\n      \r\n      // Add all occurrences in the month (every 2 weeks)\r\n      while (biWeeklyDate.getMonth() === month && biWeeklyDate.getDate() <= lastDayOfMonth) {\r\n        dates.push(new Date(biWeeklyDate));\r\n        biWeeklyDate.setDate(biWeeklyDate.getDate() + 14); // Add 14 days\r\n      }\r\n      break;\r\n      \r\n    case 'monthly':\r\n      // Return only the start date (one booking per month)\r\n      dates.push(new Date(startDate));\r\n      break;\r\n      \r\n    default:\r\n      dates.push(new Date(startDate));\r\n  }\r\n  \r\n  return dates;\r\n}\r\n\r\n/**\r\n * Calculate the next booking date for auto-creation\r\n * @param lastDate - The last booking date in the current series\r\n * @param frequency - 'one-time' | 'weekly' | 'bi-weekly' | 'monthly'\r\n * @returns The next booking date\r\n */\r\nexport function calculateNextBookingDate(\r\n  lastDate: Date,\r\n  frequency: 'one-time' | 'weekly' | 'bi-weekly' | 'monthly'\r\n): Date {\r\n  const nextDate = new Date(lastDate);\r\n  \r\n  switch (frequency) {\r\n    case 'one-time':\r\n      // Should not be called for one-time, but return next month just in case\r\n      nextDate.setMonth(nextDate.getMonth() + 1);\r\n      break;\r\n      \r\n    case 'weekly':\r\n      // Next booking is 1 week from last date, but we want first of next month\r\n      // So calculate first occurrence of next month\r\n      nextDate.setMonth(nextDate.getMonth() + 1);\r\n      // Keep the same day of week - find first occurrence in next month\r\n      const dayOfWeek = lastDate.getDay();\r\n      const dayOfMonth = lastDate.getDate();\r\n      \r\n      // Start from the 1st of next month\r\n      nextDate.setDate(1);\r\n      \r\n      // Find the first occurrence of the same day of week\r\n      while (nextDate.getDay() !== dayOfWeek) {\r\n        nextDate.setDate(nextDate.getDate() + 1);\r\n      }\r\n      break;\r\n      \r\n    case 'bi-weekly':\r\n      // Next booking is 2 weeks from last date, but we want first of next month\r\n      // Calculate first occurrence in next month (same day of week)\r\n      nextDate.setMonth(nextDate.getMonth() + 1);\r\n      const biWeeklyDayOfWeek = lastDate.getDay();\r\n      nextDate.setDate(1);\r\n      \r\n      // Find the first occurrence of the same day of week\r\n      while (nextDate.getDay() !== biWeeklyDayOfWeek) {\r\n        nextDate.setDate(nextDate.getDate() + 1);\r\n      }\r\n      break;\r\n      \r\n    case 'monthly':\r\n      // Next booking is same day next month\r\n      nextDate.setMonth(nextDate.getMonth() + 1);\r\n      // Handle edge case where day doesn't exist in next month (e.g., Jan 31 -> Feb 28/29)\r\n      const originalDay = lastDate.getDate();\r\n      const daysInNextMonth = new Date(nextDate.getFullYear(), nextDate.getMonth() + 1, 0).getDate();\r\n      nextDate.setDate(Math.min(originalDay, daysInNextMonth));\r\n      break;\r\n      \r\n    default:\r\n      nextDate.setMonth(nextDate.getMonth() + 1);\r\n  }\r\n  \r\n  return nextDate;\r\n}\r\n\r\n/**\r\n * Format date to YYYY-MM-DD string for database storage\r\n */\r\nexport function formatDateForDB(date: Date): string {\r\n  const year = date.getFullYear();\r\n  const month = String(date.getMonth() + 1).padStart(2, '0');\r\n  const day = String(date.getDate()).padStart(2, '0');\r\n  return `${year}-${month}-${day}`;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}